# System Telephony

* [SIP](#sip)
    * [SIP Header](#what-is-a-sip-header)
        * [To](#to)
        * [Via](#via)
        * [Call-ID](#call-id)
        * [Contact](#contact)
        * [From](#from)
        * [Content-Length](#content-length)
        * [CSeq](#cseq)
        * [Max-Forwards](#max-forwards)
        * [Content-Type](#content-type)
* [PBX](#what-is-pbx-private-brand-exchange)
* [Kamailio](#kamailio)
    * [what is Kamailio?](#so-what-is-kamailio)
    * [Configuration](#configuration)
    * [Request Route](#the-request_route-block)
    * [SIP Register](#sip-registrar)
    * [Table Script](#table-sql-script)
    * [Structure](#structure)
    * [Global Parameters Section](#global-parameters-section)
    * [Modules Settings Section](#modules-settings-section)
    * [Routing Blocks Section](#routing-blocks-section)
    * [Structure](#structure)
    * [REQINIT](#reqinit)
    * [onreply_route](#onreply_route)
    * [SIP route headers](#sip-route-headers)
    * [xlog](#xlog)
    * [sl_reply](#sl_reply)
    * [lookup](#lookup)
    * [t_relay](#t_relay)
    * [exit](#exit)
    * [Kamailio Module](#kamailio-module)
        * [Mysql Module](#mysql-module)
        * [Secfilter Module](#secfilter-module)
            * [Overview](#overview-secfilter)
            * [Dependencies](#dependencies)
            * [Database setup](#database-setup)
            * [Params](#params-secfilter)
            * [Functions](#funcs-secfilter)
        * [Sipdump Module](#sipdump-module)
            * [Overview](#overview-sipdump)
            * [Params](#params-sipdump) 
            * [Functions](#funcs-sipdump) 
        * [Dispatcher Module](#dispatcher-module)
            * [Links](#links)
            * [Params](#params-dispatcher)
            * [Functions](#funcs-dispatcher)
            * [RPC Command](#rpc-command-dispatcher)
            * [Destination Selection Algorithm](#destination-selection-algorithm)
            * [weight and rweight](#weight-and-rweight)
            * [Detection state node](#detection-state-node)
            * [Managing Failure](#managing-failure)
        * [Ctl Module](#ctl-module)
            * [Params](#params-ctl)
* [sipp](#sipp)     
* [Voice over IP](#voice-over-ip)       
        



# SIP
## What is a SIP Header?
A SIP Header is a component of a SIP message that is used to convey information about the SIP message. Including the correct SIP Header and correctly formatting these SIP Headers is critical to ensure that requests are successfully routed to the right recipients. We'll try and run through some of the most common SIP Headers in this blogpost.

## Headers for the Standard SIP Call
Usually, an  INVITE message initiates a session—essentially a phone call—on the SIP protocol. While there are many other SIP headers, the nine outlined below supply the minimum required information to initiate  a call over a SIP trunking network. A  BYE request is used to terminate calls.

## To
The To header specifies the recipient of the call.
To: Indicates the intended recipient of the SIP request or response

Format
```
To: “(name)” <sip: (user)@(domain)>
```

## Via
The  Via header identifies a call’s path with the protocol name, protocol version, transport type,  user agent client (UAC), the protocol port for the request and a branch parameter which serves as a unique identifier for each  SIP transaction . The Via header routes SIP responses to the correct device, similar to a return address on a package. If a SIP request is routed through multiple devices, each UAC adds its own VIA header to the request before sending it on.
Via: Provides information about the routing path and transport protocol used in the SIP message

Format
```
Via: SIP/(protocol version)/(transport type) (UAC):(protocol port);branch=(branch number) 
```

## Call-ID
The Call-ID SIP Header creates a globally unique identifier for the call. To ensure that each Call-ID identifier is globally unique, a random number is generated (which often looks like this: f_169eac17a017b0a4e0adfa8_I), and the sender’s IP address is appended to this number. This guarantees that the Call-ID number will be globally unique, since no two devices will have the same IP address.
Call-ID: Generated by the sender, it’s a unique identifier that allows the related SIP messages to be grouped as part of the same call

Format
```
Call-ID: (generated number)@(ip\_address) 
```

## Contact
The Contact header identifies the most direct route for sending future requests to the requesting device. The Contact header specifies a caller domain name or IP address and a transport type.

Format
```
Contact: sip:(user)@(domain);transport=(transport type) 
```

## From
The From header specifies who the call is coming from.
From: Specifies the sender of the SIP request or response

Format
```
From: “(name)” <sip: (user)@(domain)> 
```

## Content-Length
The Content-Length header specifies the size of the message content in bytes. A Content-Length of 0 indicates that there is no message body.

Format
```
Content-Length: (number of bytes in message body) 
```

## CSeq
The CSeq header specifies the number of requests of each type that have been sent. For example, CSeq: 15 INVITE means that is the 15th invite request. The number increases by one for each additional request of the same type.
CSeq: Contains a sequence number and method (such as INVITE, ACK, and BYE) to indicate the order of SIP messages in a transaction

Format
```
CSeq: (number) (request type) 
```

## Max-Forwards
The Max-Forwards header limits the number of times a request can be forwarded on its way to the recipient. The number is reduced by one each time the request is forwarded. The Max-Forwards header prevents a request from endlessly circling the SIP network if the recipient cannot be found. The default value is 70.

Format
```
Max-Forwards: (maximum number of forwards) 
```

## Content-Type
If the message has a body, the Content-Type header identifies how the body is formatted. A text message might be identified as text/HTML or an application making a call might identify the content as application/SDP.

Format
```
Content-Type: (type of content)
```

## Transactions:
A transaction consists of a Request, any non-final (1xx) Responses received, and a final Response (2xx, 3xx, 4xx, 5xx, or 6xx), as well as the acknowledgements of the Responses (ACK or PRACK), except for ACKs to 2xx Responses. For example:

SIP peer A sends an INVITE Request to SIP peer B

SIP peer B returns a Response of 100 TRYING; this is a non-final Response, so the transaction is not completed yet

SIP peer B returns 200 OK (a final response), accepting the invitation; this completes the transaction

   - A **transaction** in SIP represents a sequence of messages exchanged between a **client** (usually the initiator) and a **server** (which responds to the client's requests).
   - A transaction consists of the following components:
     - **Request**: The initial message sent by the client (e.g., an INVITE request to establish a call).
     - **Non-final Responses (1xx)**: Intermediate responses (such as 100 TRYING) that indicate the progress of the transaction.
     - **Final Response (2xx, 3xx, 4xx, 5xx, or 6xx)**: The conclusive response (e.g., 200 OK) that completes the transaction.
     - **Acknowledgments (ACK or PRACK)**: Acknowledgments for the received responses (except for ACKs to 2xx Responses).
   - Example:
     - SIP peer A sends an INVITE Request to SIP peer B.
     - SIP peer B responds with a 100 TRYING (non-final response).
     - SIP peer B then sends a 200 OK (final response), accepting the invitation, completing the transaction.

## Dialogs:
A dialog is just a series of transactions between two SIP peers. The purpose of a dialog is to setup, possibly modify, and then teardown a session. Hence the name Session Initiation Protocol. Since there could be many dialogs in progress between two SIP peers at any time (e.g. there could be many simultaneous calls in progress between two SIP servers), dialogs are identified by the From, To, and Call-ID fields in the header. So if SIP peer A gets two BYE Requests at the same time, it can look at these fields to determine which dialog they belong to.
A typical set of transactions you might see in a dialog could include:

SIP peer A invites SIP peer B to a session and suggests a certain codec, but does not include authentication and so is rejected

SIP peer A again invites SIP peer B to a session, this time supplying authentication, and the invitation is accepted

SIP peer B sends an invitation to change the codec used, and it is accepted

SIP peer A ends the session

   - A **dialog** is a series of related transactions between two SIP peers (user agents).
   - The purpose of a dialog is to set up, modify, and eventually tear down a **session**.
   - Dialogs are identified by specific fields in the SIP header, including:
     - **From**: Identifies the sender.
     - **To**: Identifies the recipient.
     - **Call-ID**: A globally unique identifier for the call.
   - Example:
     - SIP peer A invites SIP peer B to a session (e.g., a voice call) and suggests a codec.
     - If rejected, SIP peer A retries with authentication, and the invitation is accepted.
     - During the dialog, SIP peer B may propose a codec change, which is accepted.
     - Finally, SIP peer A ends the session.

## Sessions:
A session is just a media stream (e.g. audio or video) flowing between peers, usually consisting of RTP (and possibly RTCP) packets. For example, if SIP is used to make a voice call, the session is the voice data that is sent between endpoints

   - A **session** represents the actual media stream (e.g., audio or video) flowing between peers.
   - It consists of RTP (Real-time Transport Protocol) packets (and possibly RTCP for control).
   - For instance, in a voice call, the session corresponds to the voice data transmitted between endpoints.

![](http://telconotes.files.wordpress.com/2013/03/sip-transaction-vs-dialog.png)

## [Understanding ther SIP Via header](https://andrewjprokop.wordpress.com/2014/03/06/understanding-the-sip-via-header/)

When a user agent client (UAC) creates a SIP request, it must insert a Via header into that request.  The Via header identifies the protocol name (SIP), protocol version (2.0), transport type (e.g. UDP or TCP), IP address of the UAC, and the protocol port (typically 5060) used for the request.  This information allows the recipient of the request (a user agent server) to return SIP responses to the correct device.  For example, if my SIP soft-phone were to send an INVITE request, it would contain a Via similar to the following.

```
Via: SIP/2.0/UDP 10.11.228.67:5060
```

If I were operating in a point-to-point configuration, the soft-phone that received the INVITE would  inspect the Via header to determine the location of my PC.  It would then use that information to return a “100 Trying” response.  Of course, unless I am in a lab environment, I never use SIP in a point-to-point fashion.  Here at work, there are all sorts of SIP components between my soft-phone and the soft-phone I am calling.  There is a Session Manager, Communication Manager, and perhaps a Session Border Controller between us.  Thankfully, via headers are not reserved for endpoints.  Every SIP entity uses them.

The rules for processing Via headers are very simple.  Every UAC must add its own Via header before sending a SIP request.  If there is already a Via header in the message, the UAC adds the new one at the top of the list before sending it to the next hop.

Remember that INVITE I sent in my example?  When it ends up on the called party’s device, it might contain several Via headers.  When the called party is ready to send the “100 Trying,” it simply removes the top Via header and sends the response to the indicated party.  In my work configuration, that top Via would most likely identify a Session Manager.  However, if the soft client was a remote user, it would be my company’s SBC.  It doesn’t matter, though.  Whoever receives the response will remove the top Via header and send it to the next hop.  This keeps happening until the Trying message lands on my PC.

This Via stacking allows a SIP request to pass through any number of intermediaries and every recipient of that message will know exactly how to pass back any subsequent responses.

Ah, but there’s more

To keep things simple I failed to mention something important about Via headers.  Along with the protocol and IP information, every Via header contains a “branch” parameter.  Here is that Via again with a branch parameter I pulled from a Wireshark trace.

```
Via: SIP/2.0/UDP 10.11.228.67:5060; branch=z9hG4bK10_16a83292baa1de54e0b7843_I
```

The branch parameter must be unique across space and time for all requests sent by a user agent.  The exceptions to this rule are CANCEL and ACK for non-2xx responses.  A CANCEL will have the same branch parameter as the request it cancels.  An ACK for a non-2xx response will have the same branch parameter as the INVITE whose response it acknowledges.

The uniqueness of the branch header is used to facilitate its use as a transaction ID.  A SIP transaction is a message exchange between two user agents that starts with a request and ends with a final response.  For a simple call, the INVITE through final response is one transaction, the ACK is another transaction, and the Bye through the 200 OK is yet another transaction.  All these transactions combine to make a single dialog.

If you crave more knowledge about SIP message uniqueness, please see my blog, Let’s Play (SIP) Tag.

The branch parameter always begins with the same string of seven characters — “z9hG4bK.”  This requirement was added to identify that the branch was created in accordance with RFC 3261 and not the older RFC 2543 which did not require global uniqueness

## [Contact and Record-Route headers](https://kb.smartvox.co.uk/opensips/contact-and-record-route-headers-explained/)

### Some Acronyms and terminology
* UAC : User Agent Client (for example, a VoIP handset)
* UAS : User Agent Server (for example, an IP-PBX such as Asterisk)
* SIP Proxy : A server that operates as an intermediate node between the UAC and the UAS
* URI : Uniform Resource Identifier. Typical format “sip:<username>@<domain>”
* Sequential Request : A SIP request that is part of an already established dialogue. It will have a “to-tag”. Sequential requests follow after the initial request that established the dialogue

The <domain> element is often shown as <host>, possibly to show it can be a domain or an IP address. It may also have a port number appended (after a colon separator). e.g. sip:12345@192.168.20.123:5144

If you want to dig deeper into the terminology used to identify sub-components of the URI and see how it fits together with parameters in the context of a SIP header


# Kamailio Introduction
Kamailio (formerly OpenSER) is an open source SIP server, but Kamailio is a bit difficult to grasp what “it is“, but once you understand it’s all very logical.

Over this series I’ll attempt to explain what Kamailio is (and isn’t), and through a series of examples, show you how to use Kamailio to build cool stuff.

I’ll try and make it accessible for people with a background / understanding of VoIP, specifically with an understanding of SIP.

There’s a lot of meticulous documentation out there on specific Kamailio modules, but not much I could find that gives an overview of how the platform works, so over this series of Tutorials, I’ll attempt to cover the basics of using Kamailio to solve problems, as together we build a basic PBX with Kamailio, touching upon some of the common modules and core concepts of Kamailio.


## So what is Kamailio ?
Kamailio is a SIP Server.

It’s a bit confusing at the start, because Kamailio isn’t like FreeSWITCH, Asterisk, YATE, an SBC, a PBX or any of other telephony platforms you may have encountered before, because out of the box, Kamailio doesn’t really do anything.

You’ve got to tell Kamailio how to do everything.

Let’s take a SIP INVITE message, used to start a call (aka session) that we might send to a PBX with the domain name biloxi.example.com and a SIP endpoint registered as ‘101’:

INVITE sip:101@biloxi.example.com SIP/2.0
If we sent this message to a generic PBX, the PBX would have the logic to know that it has an extension 101 and the PBX would ring extension 101.

Our generic PBX looks at the Request URI in the INVITE message it received and has the logic predefined to know that 101 is a device it has registered and that we want to connect to that device, so sends the call to the matching device.

If we sent the same INVITE to an Asterisk box, Asterisk would take a look at our SIP INVITE message, and see if there’s an entry in the dialplan under the current context for 101. Asterisk doesn’t assume if you have a user registered on SIP/101 and receive a SIP INVITE to 101 that you want to get to SIP/101, it’d need to be told this through the dialplan.

Kamailio takes this example even further.

If we want to dial 101 on Kamailio and have it ring the device registered on 101, you have to tell Kamailio what to do when it receives an INVITE message in the first place, lookup if that destination is in our AOR (we’ll get to that) table, and then forward the INVITE to the destination if it exists, and forward the provisional responses (1xx) and finally the final response (200 OK) from the remote end back to the originator. Plus we’ve got to think about how we handle a scenario where the destination doesn’t exist, or isn’t registered, of if the destination returns a 4xx response to the INVITE, how we handle provisional responses and CANCEL messages and finally the BYE message (if we’re record routing).

Phew. This seems like a lot to handle.

It all seems pretty daunting at first, calling from one SIP Endpoint to another seems like a pretty rudimentary thing in a telephony product, but by putting how the system thinks, routes and manipulates messages up to you, we open the doors to all the possibilities.

What if you want something to sit in front of your servers and only allow certain SIP User Agents? Or load balance between several soft-switches? Or route least-cost between connected carriers and seamlessly failover if one is lost? Rate limit dodgy traffic before it hits your environment? Manage hundreds of thousands of registrations?

Kamailio can do all of that.

Kamailio can do anything you can think of (to do with signaling).

And that’s the awesome part of Kamailio. It is, what you define it to be.


## Configuration
We’ll open kamailio.cfg – the text file that contains all our routing info, and get to work.

```
vi /etc/kamailio/kamailio.cfg
```

You’ll see the config starts by defining what modules to load, and the config for each of these modules. For us, the defaults will work for now, let’s get to the juicy bits. Keep moving down the config file until you hit this section:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
```
The request_route section is what handles the initial SIP message that comes through.

We’ll remove all the text after request_route { leaving us with a blank canvas in terms of how we handle messages. We’ll then put in a single line to log to syslog when we get a SIP message:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        xlog("I got a message");
}
```

If we were to stop here and restart Kamailio, when a SIP message comes into our SIP server, we’d just write an entry to syslog saying “I got a message” each time we get a SIP message, but Kamailio won’t respond to the received SIP message, it’ll just enter a log entry each time it gets a SIP message. So let’s respond to any SIP message we get with a 501 “Not Implemented” message.

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        xlog("I got a message");
        sl_reply("501", "Not Implemented");
}
```

So let’s break down the two functions we just used.

## xlog("");
xlog is your friend.
Put simply xlog prints whatever you put inside the parenthesis to syslog.
You can use it to check to see if your messages are getting to the part of the config you want, check what pseudovariables are doing and many other things, but I’m getting ahead of myself. For now you just need to know xlog is like NoOp() in Asterisk, print() in Python, etc.

## sl_reply();
sl_reply is stateless reply.
It takes two parameters, the SIP Response Code and the text to go with it, when called it sends the SIP response code and text back to the requester.
In this case we’re using SIP Response Code 501, which translates to Not Implemented, meaning the server does not support the functionality required to fulfill the request aka:

## What is PBX (Private Brand Exchange)?
PBX stands for Private Branch Exchange. Think of it as an internal telephone network of a business or other entity. PBX phone system users can communicate with one another over the phone via internal lines, and make and receive external calls as well. A PBX phone system usually delivers business telephony features such as call forwarding, call transfer, call queue, auto-attendant, voicemail, etc.

PBX systems operate by using either VoIP (Voice Over Internet Protocol) or via analog or digital phone lines. With a PBX phone system, the physical phone line coming into your business can be split into multiple lines, allowing you to support more telephones. Better yet, calls between users are free

![](https://getvoip.com/uploads/VoIP-vs-PBX-e1662681663590.png)

## General Rules
Some rules of thumb to get you started with writing Kamailio configs:

* All lines that do things (instructions) have to end with a semicolon
* Comments start with # if single line or /* blah */ for multi-line
* Changes to the config only take effect when you restart Kamailio
* With what we have setup restarting Kamailio causes it to forget all about your active Registrations (Even though your devices might say they’re still registered) (For now, although we can change this behaviour)

Now we’ve got that out of the way let’s continue on from our last tutorial and start routing requests!

(We’ll skip all the config above the request_route{} block that configures the modules and their setup, it’s all very important, but we’ll touch upon that in a later tutorial I promise)

As I touched upon in the Introduction post, you define what Kamailio is and does in terms of routing SIP requests, so let’s jump straight in and get started on the blocks that take care of this.

## The request_route{} Block
The request_route{} block is where all our incoming SIP requests start off. Replies / responses are handled a bit differently (more on that later), but essentially every new SIP request / message / dialog starts off here.

We can create new blocks other than request_route{} to help keep our code clean, in the same way we might define functions while programming.

```
Let’s take a look:

request_route {
        route(RESPOND_501);    #Jump to the RESPOND_501 block
}

route[RESPOND_501]{
        sl_reply("501", "Not Implemented");   #Send 501 reply
}
```

We can see in the above example, any SIP Request coming in will enter our request_route{},

In our request_route{} block we only have one instruction, which is route().

The route() command allows us to then specify another block of the config file / code to continue on from. Think of it kind of like calling a function or god forbid – a GoTo. So in this example the call comes in and then routed off to a new routing block called route[RESPOND_501],

This allows us to reuse bits of code multiple times and generally keep everything a lot cleaner.

It’s worth noting that unless you tell it to, routing to another block won’t stop Kamailio from continuing to execute it’s way through the code, it’ll do what it’s told in the other routing block and then finish what it started.

Let’s look at an example:

```
request_route {
        xlog("Hello, I am in the request_route");
        route(RESPOND_501);    #Jump to the RESPOND_501 block
        xlog("Back in request_route");
}

route[RESPOND_501]{
        xlog("Now I am in the respond 501 route");
        sl_reply("501", "Not Implemented");   #Send 501 reply
}
```

If we’re to run this code and send a SIP Request to it, we’d see each of these xlog entries in your syslog,

* As the message firsts hits the xlog(“Hello, I am in the request_route”);, then is routed off to route[RESPOND_501]
* In route[RESPOND_501] we’ll see the xlog(Now I am in the respond 501 route”); – Kamailio has now executed the route[RESPOND_501] block and resumes from where it was in request_route{}

When we get back to request_route we get the final xlog(“Back in request_route”);.
We can stop routing in a specific block using the exit; command which stops processing that request once hit. For example:

```
request_route {
        xlog("Hello, I am in the request_route");
        route(RESPOND_501);    #Jump to the RESPOND_501 block
        xlog("Back in request_route");
}

route[RESPOND_501]{
        xlog(Now I am in the respond 501 route");
        sl_reply("501", "Not Implemented");   #Send 501 reply
        exit;
}
```

Because of the exit we added in the route[RESPOND_501] Kamailio stops executing at that point, so we don’t continue passing through the config file and this time we won’t get the final xlog(“Back in request_route”); call

## Basic Message Routing
Let’s take a very basic use case, and write some code in the request_route{} block.

We’ll set it up so if we receive an INVITE request, we’re going to respond with a 480 Temporarily Unavailable message, and for everything else, we’ll respond with 501 “Not Implemented”.

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

So let’s break this down,
First we have a an if statement – If the method of the SIP message is an INVITE request, then execute the code inside the curly brackets.

Inside the curly brackets we’ll respond with 480 Temporarily Unavailable, using sl_reply() (You may remember from the last post that sl_reply sends a reply back to the sender of the message with the response code and text specified) and then exit, meaning we won’t continue executing what’s next in the config.

Finally outside of our if statement (so catching any SIP requests who’s method isn’t INVITE) we’ll respond with 501 “Not Implemented”.

Here we can see our REGISTER message got back a 501 Not Implemented response, while our INVITE got a 480 Temporarily Unavailable response.

## SIP Registrar
As we talked about in the post on SIP Registrars, SIP Registrars take the REGISTER requests from SIP endpoints and store their contact details in the form of an Address on Record (AoR). This AoR contains the URI and the endpoints’ current IP it just sent the REGISTER message from.

The primary use of this is it allow us to know how to reach people. It’s kind of like an address book for mapping current IP against a SIP URI, as IP Addresses of SIP endpoints may change often.

So our Kamailio instance is going to receive an REGISTER message, store the Contact as an address on record, and respond 200 OK. Let’s build upon the config we started with in the last tutorial:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

So let’s add an if statement to manage REGISTER messages, and save their location:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        if(method=="REGISTER"){
                save("location");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```
So we’ve added an IF statement to find if the SIP method is a REGISTER message, and if it is, we’ll call the save(“location”); function.

The save() function saves the Contact address we just received to a database (in this case one in memory) in the form of a SIP URI and current Contact location, these two bits of info combined are known as an address on record (AoR) and the save function, if successful, responds with a 200 OK automatically.

So that’s it – Our SIP endpoint is happy and by calling the save(“location”) we’ve called the built in function to store the Contact as an Address on Record and respond with 200 OK.

So how do we access this information and what can we do with it?

Kamailio comes with two tools for accessing Kamailio while it’s running. In this example we’ll use kamcmd to check what’s registered on our system. After we’ve seen a device register, from command line we’ll run:

```
kamcmd ul.dump
```

This calls kamcmd the Kamailio command line tool, and calls the ul.dump function. ul is short for userloc – The module for user location management, and dump outputs all the contents of the userloc table.

![](https://nickvsnetworking.com/wp-content/uploads/2018/12/image-12.png)

## First Call
So now we’ve got Kamailio handling REGISTER traffic, and we know what IPs endpoints are on, so let’s join this together and let’s route a call between two endpoints via our Proxy!

We’ll work on the config we were working on in the previous tutorial:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        if(method=="REGISTER"){
                save("location");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

Let’s change how we handle the INVITE messages in our if(method==”INVITE”) block so instead of responding with a 480 Unavailable response, let’s lookup the location we saved if it was a REGISTER and forward the INVITE to the IP we’ve got.
```
if(method=="INVITE"){
        lookup("location");
        t_relay();
        exit();
}
```

Let’s break down each of the new functions we’ve introduced:


### lookup(“location”);
In the last post we introduced save(“location”); which saves an Address on Record for the URI. lookup(“location”); looks up the IP address of the URI we’re after in the Address on Record table we wrote to with our save(“location”); call and automatically sets it as the destination IP of where we’re going to send the message.

When a user registered via a SIP REGISTER request, we saved their details, now we’re looking them up.

You could even replace the lookup(“location”) call with say a SQL lookup on an address book, and save the output to the IP the INVITE will be forwarded to, but lookup(“location”); does this it all in one function.

### t_relay();
t_relay is transactional relay function. By transactional it means Kamailio remembers this session next time it’s referenced, we’ll touch upon transaction aware / stateful SIP proxies later, but for now what you need to know is it forwards the INVITE we just received to the address we got from our lookup(“location”).

### exit();
Exit bails out so we won’t keep processing after that, it doesn’t just bail out of our current conditional but stops processing this request further. Without it we’d still go on and send the 501 Not Implemented reply.

## **SIP Basics**:
   - SIP is a protocol used for initiating, maintaining, modifying, and terminating real-time communication sessions over IP networks. It's widely used for voice and video calls, instant messaging, and other multimedia applications.
   - SIP operates through a series of **methods** (requests) and corresponding **responses**.

## **SIP Methods**:
   - SIP requests are sent by the **User Agent Client (UAC)** to establish and manage sessions.
   - The first six basic SIP request methods are:
     - **INVITE**: Initiates a session (e.g., when you make a call).
     - **ACK**: Confirms an INVITE request.
     - **BYE**: Ends a session (hangs up the call).
     - **CANCEL**: Cancels the establishment of a session.
     - **REGISTER**: Communicates user location (host name, IP).
     - **OPTIONS**: Provides information about the capabilities of the calling and receiving SIP devices.

## **The "Trying" Response**:
   - When you initiate a call (send an INVITE request), the **User Agent Server (UAS)** receives it.
   - The UAS responds with a **provisional response** called **"100 Trying"**.
   - This response indicates that the call setup process is underway. It doesn't confirm success or failure; it's simply an acknowledgment that the request is being processed.
   - After the "100 Trying," the UAS may send a final response (e.g., "200 OK" for a successful call setup).

## **Example Scenario**:
   - Imagine you're calling a friend. Here's how it works:
     - You (UAC) send an INVITE to your friend (UAS).
     - Your friend's device responds with "100 Trying" to let you know they're processing the call.
     - If your friend accepts the call, they'll send a final "200 OK" response, and the call is established.


Kamailio allows you to deal with all these problems yourself, writing your own routing blocks, but it also comes with a bunch of useful routing blocks in the [example config](https://github.com/kamailio/kamailio/blob/master/etc/kamailio.cfg), that we can re-use so we don’t need to specify how to manage every little thing ourselves – unless we want to.

So lets add some of these useful routing blocks,

We’ll add this at the start of our request_route{ block
```
request_route {

        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }


        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }

        # handle requests within SIP dialogs
        route(WITHINDLG);
}
```

So now our config looks like this:

```
request_route {
        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }


        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }

        # handle requests within SIP dialogs
        route(WITHINDLG);


        if(method=="INVITE"){
            if(!lookup("location")){
                            sl_reply("404", "User not Registered");
                            exit;
            }

            lookup("location");
            t_relay();
            exit();
        }


        if(method=="REGISTER"){
                save("location");
                exit;
        }
        xlog("No idea how to respond to method $rm");
        sl_reply("501", "Not Implemented");
}
```

As you can see we’ve added an if statement to match if the method is CANCEL or ACK, and referenced some routing blocks:

* route(RELAY);
* route(WITHINDLG);

## t_check_trans()
t_check_trans() can be used to quickly check if a message belongs or is related to a transaction. It behaves differently for different types of messages:

* For a SIP Reply it returns true if the reply belongs to an existing transaction and false otherwise.
* For a CANCEL it behaves exactly as t_lookup_cancel(): returns true if a corresponding INVITE transaction exists for the CANCEL and false otherwise.
* For ACKs to negative replies or for ACKs to local transactions it will terminate the script if the ACK belongs to a transaction (it would make very little sense to process an ACK to a negative reply for an existing transaction in some other way then to simply pass it to tm) or return false if not.
* For end-to-end ACKs (ACKs to 2xx responses for forwarded INVITE transactions) it will return true if the corresponding INVITE transaction is found and still
active and false if not

## t_precheck_trans()
Check if current processed message is handled by other process. This function is useful to catch retransmissions before transaction is created. The function returns true if the request is handled by another process.

Note that ACK and CANCEL requests are not tracked by this function, the return code being false for them.

This function can be used from REQUEST_ROUTE .

Example 1.15. t_precheck_trans usage
```
...
# handle retransmissions
if(t_precheck_trans()) {
t_check_trans();
exit;
}
t_check_trans();
...
```

## Security in Theory
In this series we’ll ultimately end up with a basic PBX with the ability to make and receive calls between registered users and via trunks from a carrier.

Soon we’ll add the ability to call numbers not registered on our system (trunks) to our system, but now is a good time to talk about securing your system, as the threat of toll fraud is very real, as well as calls from random devices waking you up in the middle of the night.

VoIP security is a big topic, there’s a whole lot of wrong ways to do things, so think before you do.

## Authentication, Authorisation and Accounting
Most telephony platforms employ some form of AAA, it’s a good minimum starting point for our system to ensure we Authenticate traffic, to make sure it is who it claims to be, we Authorise traffic to make sure it’s allowed to traverse this part of the network and use theses resources, and finally we’ll Account for resources used, for example recording CDRs and cost for the services used.

## Authentication
Authentication in this example we’ll using the Challenge / Response based authentication for traffic from users (Such as REGISTER and INVITE messages), as [shown in this example](https://tools.ietf.org/html/rfc3665#section-2.1).

When we get an INVITE or a REGISTER from a user, we’ll check their username / password matches what we’ve got on record.

For this we’ll use Kamailio’s [Auth_DB](https://www.kamailio.org/docs/modules/devel/modules/auth_db.html) module.

## Authorization
We’ll use IP Address authorisation for inbound traffic from carriers (so we can make sure that we’ll only allow calls from carriers, not just any IP on the internet sending INVITES).

This means when we get an INVITE from a Carrier to send us an inbound call, we’ll make sure it’s from the Carrier’s IP address before we start our user’s phones ringing.

For this we’ll use Kamailio’s [Permissions](https://www.kamailio.org/docs/modules/devel/modules/permissions.html) module.

## Accounting
We’ll skip Accounting for now as we’re not going to be charging users at this stage.

Kamailio has the [Accounting](https://www.kamailio.org/docs/modules/devel/modules/acc.html) module you can use for this, which we’ll talk about another day.

## Traffic Validation
Now’s probably a good time to talk about validating your traffic in the wild west world that is the internet.

Let’s say we implement a database lookup in Kamailio to take the To part of the Request URI and lookup where to route it, we receive something like:

```
INVITE sip:1234567@example.com
```

So we’ve got that and we lookup 1234567 in our database and get where we need to route it to:

```
SELECT 'forward_destination' FROM 'imaginary_route_database' WHERE 'dialed_number' = '1234567';
```

Seems harmless enough right?

Now imagine someone sends an INVITE that looks like this:

```
INVITE sip:'; DROP TABLE *;@example.com
```

Now let’s look at how our SQL query would look:

```
SELECT 'forward_destination' FROM 'imaginary_route_database' WHERE 'dialed_number' = ''; 
DROP TABLE *; 
'';
```

And suddenly we find all our tables have been deleted.

So it’s important we filter everything, and make sure the traffic is valid.

SQL injection is a fun example, but more common examples could include not checking the Max Forwards header and looping packets out and back in infinitely (imagine no spanning tree and plugging a switch into itself) and not responding to known bad user agents like sipcli and sipvicious.

Luckily again the Kamailio team have covered this before, Kamailio comes with a module for handling a lot of the common threats.

With the boilerplate routes we talked about in the last tutorial all you have to do is add **route(REQINIT);** at the start of your routing block and you’ll get:

* Dodgy UA filtering (You may want to add your own)
* Basics of Flood Prevention (if you want it)
* max_forward checking (for handling routing loops)
* OPTIONS response handling
* Sanity checking

### REQINIT
for more read [link](https://telecom.altanai.com/2018/02/17/kamailio-security/)
```
route[REQINIT] {
	# no connect for sending replies
	set_reply_no_connect();
	# enforce symmetric signaling
	# - send back replies to the source address of request
	force_rport();

        #!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xalert("ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
        #!endif
	if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent|pplsip") {
		# silent drop for scanners - uncomment next line if want to reply
		# sl_send_reply("200", "OK");
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483", "Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200", "Keepalive");
		exit;
	}

	if(!sanity_check("17895", "7")) {
		xlog("Malformed SIP request from $si:$sp\n");
		exit;
	}
}

```

### set_forward_no_connect
The message will be forwarded only if there is already an existing connection to the destination. It applies only to connection oriented protocols like TCP and TLS (TODO: SCTP), for UDP it will be ignored. The behavior depends in which route block the function is called:

* normal request route: affects stateless forwards and tm. For tm it affects all the branches and the possible retransmissions (in fact there are no retransmission for TCP/TLS).

* it applies specifically to connection-oriented protocols like TCP and TLS (and potentially SCTP, although that’s still a TODO).
Here’s what it means:
  * Imagine you have a message (like a SIP request) that you want to forward to a destination (another server or client).
  * With set_forward_no_connect, the message will be forwarded only if there is already an existing connection to   that destination.
  * In other words, if there’s no active connection, the message won’t be forwarded.
  * However, for UDP, this setting is ignored because UDP is connectionless.

So, think of it like this: set_forward_no_connect ensures that the message takes the existing “road” (connection) to reach its destination

set_forward_no_connect in a straightforward way:
* What Is It?
  * Imagine you’re sending a letter (a SIP message) to a friend (a destination).
  * Now, your friend lives in a house (server or client).
  * The set_forward_no_connect setting is like saying, “Hey, if there’s already a road (connection) to your friend’s house, use it to deliver the letter.”
  * But if there’s no road (no existing connection), the letter won’t be forwarded.
  * This concept applies mainly to protocols like TCP (think of it as a reliable road) and TLS (a secure road).
  * When you forward a message using set_forward_no_connect, Kamailio checks if there’s an active connection to the destination


### set_reply_no_connect
Like set_forward_no_connect(), but for replies to the current message (local generated replies and replies forwarded by tm). The behavior depends in which route block the function is called:

* normal request route: affects all replies sent back on the transaction (either local or forwarded) and all local stateless replies (sl_reply()).

* For replies coming from local users , usually behind NAT , do not open a new TCP connection on each reply

* onreply_route: affects the current reply (so the send_flags set in the onreply_route will be used if the reply for which they were set is the winning final reply or it's a provisional reply that is forwarded)


### onreply_route
The `onreply_route` in Kamailio (formerly known as OpenSER) is a powerful feature that allows you to handle SIP replies within the context of an active transaction. Let me break it down for you:

1. **What Is `onreply_route`?**
   - The `onreply_route` is a SIP reply routing block executed by the Transaction Module (TM) in Kamailio.
   - It contains a set of actions to be taken for SIP replies.
   - The main `onreply_route` is executed for **all** replies received.
   - Certain `onreply_route` blocks can be executed by the TM module for special replies.

2. **How Does It Work?**
   - When a SIP request generates a reply, Kamailio checks if there's an `onreply_route` associated with that request.
   - If armed for the specific SIP request, the `onreply_route` processes the reply.
   - You can use `t_on_reply("onreply_route_index")` to arm the `onreply_route` for specific requests.

3. **Example Usage:**
   - Suppose you want to handle replies from a specific IP address (e.g., 192.168.1.110) back to the originator.
   - You can add an `onreply_route` block to handle these replies.
   - Here's a simplified example:
     ```kamailio
     onreply_route {
         # Your custom logic here to handle the reply
         # For instance, logging or modifying the reply
     }
     ```

4. **Additional Notes:**
   - The `onreply_route` is a powerful tool for customizing how Kamailio processes SIP replies.
   - You can use it to implement features like logging, modifying headers, or triggering specific actions based on reply content.

For more detailed information, you can refer to the official Kamailio documentation on the [Core Cookbook](https://www.kamailio.org/dokuwiki/doku.php/core-cookbook:3.0.x) or explore other resources like [Kamailio Bytes](https://nickvsnetworking.com/kamailio-bytes-onreply-route/).


### force_rport
Force_rport() adds the rport parameter to the first Via header of the received message. Thus, Kamailio will add the received port to the top most Via header in the SIP message, even if the client does not indicate support for rport. This enables subsequent SIP messages to return to the proper port later on in a SIP transaction.

This is useful for NAT traversal, to enforce symmetric response signaling.

The rport parameter is defined in RFC 3581.

Note: there is also a force_rport parameter which changes the gobal behavior of the SIP proxy.

Example of usage:
```
force_rport();
```

### add_rport
Alias for force_rport();

----------------------

#### Record-Route
The Record-Route header is inserted into requests by proxies that wanted to be in the path of subsequent requests for the same call-id. It is then used by the user agent to route subsequent requests.

#### Via
Via headers are inserted by servers into requests to detect loops and to help responses to find their way back to the client. This is helpful for only responses to reach their destination.

## SIP Route Headers
The Record-Route and Via headers are fundamental components of the Session Initiation Protocol (SIP), which is a signalling protocol used for initiating, managing, and terminating real-time sessions that involve video, voice, messaging, and other communications applications across IP networks. Both headers play critical roles in SIP's operation, ensuring proper routing of requests and responses between SIP entities. Their development and use are closely tied to the history and evolution of SIP itself.


### Via Header
The Via header is used to track the path of request messages as they traverse through the network of SIP servers to reach the intended recipient. It also provides a route for the responses to follow back to the originator. Each SIP proxy or server that forwards a request adds its address to the top of the Via header list. When the response is generated, it travels back through the list of Via headers, ensuring it follows the same path back to the originator.

 
The Via header has been part of SIP since its inception. SIP was developed by the Internet Engineering Task Force (IETF) and first standardised in RFC 2543 in 1999. The Via header was designed to solve the problem of response routing in IP networks, where requests could traverse multiple nodes, and responses needed a way to navigate back through the same nodes.

### Record-Route Header
The Record-Route header is used by SIP proxies to ensure that the signalling for subsequent SIP messages (such as mid-dialog requests) follows the same path as the initial request. When a SIP proxy wants to stay in the path of future requests in a dialog, it adds a Record-Route header to the initial INVITE request. This ensures that all subsequent messages within the same dialog traverse through the recorded route, enabling features like billing, call recording, or session management to be applied consistently.

Like the Via header, the Record-Route header has been a part of SIP since its early days. It was introduced to address the need for maintaining the signalling path for the duration of a SIP session, especially in complex scenarios involving multiple proxies and network elements. The concept of recording the route was crucial for deploying SIP in real-world networks, where the control over media and signalling paths needed to be maintained for the functionality and security of communication sessions.

Both headers reflect SIP's flexibility and its ability to navigate the complexities of IP network architectures. Over the years, SIP has evolved through various RFCs (Request for Comments), with significant updates including RFC 3261 in 2002, which solidified many of the protocol's core operations, including the behaviours of the Via and Record-Route headers. These headers ensure that SIP can operate effectively over the diverse and distributed nature of the Internet, supporting the reliable delivery and routing of communication sessions across multiple hops and domains.

### Introduction
When managing SIP (Session Initiation Protocol) communications, ensuring seamless call setup and media flow is crucial for both service providers and their customers. A common issue encountered during SIP transactions is the failure of ACK messages to reach the end device, confirming the final response to the initial SIP INVITE. This can prevent the establishment of media sessions, leading to call setup failures and, ultimately, calls being dropped with a SIP BYE message and the reason as "media_timeout." In this article, we'll delve into the intricacies of the Route headers in inbound calls and explain why omitting these headers in a 200 OK response can cause such problems.

### The Role of Route Headers in SIP Communications
SIP utilises various headers to facilitate communication sessions between endpoints. Among these, Route headers play a pivotal role in defining the path that SIP messages should follow through the network. When an INVITE request is made to initiate a call, it traverses through proxies and other network elements before reaching the intended recipient. The Route headers ensure that subsequent messages, including the critical ACK response, follow the same path back to the originator, navigating through the network's topology correctly.

 
### The Consequence of Omitting Route Headers in 200 OK Responses
When a callee sends a 200 OK response to accept an INVITE request, this response should include Route headers that mirror the path taken by the initial INVITE. This inclusion ensures that the ACK message, which confirms receipt of the 200 OK, is routed back through the same network elements, reaching the callee and signalling that the session can proceed with media exchange.

If the 200 OK omits these Route headers, the network may not have the necessary information to route the ACK back to the callee correctly. As a result, even though the call appears to be established from the perspective of the initiating party (such as Telnyx), the lack of ACK receipt at the callee's end means the session cannot transition to media exchange. Consequently, without media flow, the call is eventually terminated with a "media_timeout" hang-up cause after a predefined period, typically 5 minutes.

 
### SIP Record Route Example
To provide a clear understanding, let's illustrate two examples based on the provided SIP INVITE and 200 OK messages. These examples aim to showcase the issue arising from the omission of Record-Route headers in the 200 OK response and how their inclusion ensures successful SIP call establishment.

 
### Example 1: Problematic Scenario Without Record-Route Headers

#### Telnyx SIP INVITE to Customer
```
INVITE sip:+12345678901@sip.example.com:5060 SIP/2.0 
Record-Route: <sip:192.76.120.10;r2=on;lr;ftag=BUXDty7v06tXH> 
Record-Route: <sip:10.255.0.1;r2=on;lr;ftag=BUXDty7v06tXH> 
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0 
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp
Max-Forwards: 60 
From: "+19876543210" <sip:+19876543210@sip.telnyx.com>;tag=BUXDty7v06tXH To: <sip:+12345678901@sip.example.com:5060> 
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE 
Content-Type: application/sdp 
...
```

#### Customer's 200 OK Response (Without Record-Route Headers)
```
SIP/2.0 200 OK 
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0 
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp 
To: sip:+12345678901@sip.example.com:5060;tag=8b240ac5236e0c71 
From: sip:+19876543210@sip.telnyx.com;tag=BUXDty7v06tXH 
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE 
Contact: <sip:+12345678901@another.example.com:5060> 
Content-Type: application/sdp 
...
```

Without the Record-Route headers in the 200 OK response, the ACK message sent by Telnyx might not follow the intended path, potentially failing to reach the customer's system. This misrouting can prevent the call from being fully established, leading to issues such as calls not connecting or being dropped unexpectedly.

 
### Example 2: Successful Scenario With Record-Route Headers

#### Telnyx SIP INVITE to Customer (Same as Example 1)
```
INVITE sip:+12345678901@sip.example.com:5060 SIP/2.0 
Record-Route: <sip:192.76.120.10;r2=on;lr;ftag=BUXDty7v06tXH> 
Record-Route: <sip:10.255.0.1;r2=on;lr;ftag=BUXDty7v06tXH> 
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0 
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp
Max-Forwards: 60 
From: "+19876543210" <sip:+19876543210@sip.telnyx.com>;tag=BUXDty7v06tXH To: <sip:+12345678901@sip.example.com:5060> 
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE 
Content-Type: application/sdp 
...
```

#### Customer's 200 OK Response (With Record-Route Headers)
```
SIP/2.0 200 OK
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp
Record-Route: <sip:192.76.120.10;r2=on;lr;ftag=BUXDty7v06tXH>
Record-Route: <sip:10.255.0.1;r2=on;lr;ftag=BUXDty7v06tXH>
To: sip:+12345678901@sip.example.com:5060;tag=8b240ac5236e0c71
From: sip:+19876543210@sip.telnyx.com;tag=BUXDty7v06tXH
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE
Contact: <sip:+12345678901@another.example.com:5060> 
Content-Type: application/sdp 
...
```

By including the Record-Route headers in the 200 OK response, the customer ensures that the ACK message sent by Telnyx correctly follows the predefined path through any intermediate

* Forward Path (INVITE): For the initial INVITE request, Record-Route headers are added in the order the request passes through each proxy. The first proxy the request encounters adds its Record-Route header first, and so on. This order determines the path that the initial request takes through the network.

* Backward Path (Responses): For responses, such as the 200 OK, SIP messages traverse the proxies in reverse order, following the "Via" headers back to the originator. However, for subsequent requests within the dialog (like ACK and BYE), the order of the Record-Route headers dictates the path. 

The UAC constructs the "Route" header field for these messages based on the Record-Route headers it received in the first final response (e.g., 200 OK). It reverses the order of the Record-Route headers to ensure that subsequent messages follow the path back through the proxies in the correct sequence.

### The rport parameter
When you have a SIP Via: header like
```
Via: SIP/2.0/UDP 95.117.121.206:18050;rport;branch=z9hG4bKabc123
```

the rport parameter means respond to the port from which the request was received

When a server compliant to this specification (which can be a proxy or UAS) receives a
request, it examines the topmost Via header field value.  If this Via header field value
contains an "rport" parameter with no value, it MUST set the value of the parameter to
the source port of the request. This is analogous to the way in which a server will insert
the "received" parameter into the topmost Via header field value. In fact, the server
MUST insert a "received" parameter containing the source IP address that the request
came from, even if it is identical to the value of the "sent-by" component.


#### Consider an example.
A client sends an INVITE which looks like:

```
INVITE sip:user@domain SIP/2.0 Via: SIP/2.0/UDP 10.1.1.1:4540;rport
```

This INVITE is sent with a source port of 4540 and source IP of 10.1.1.1. The request is natted, so that the source IP appears as 68.44.20.1 and the source port as 9988. This is received at a proxy.The proxy forwards the request, but not before appending a value to the rport parameter in the proxied request:

```
INVITE sip:user@domain2 SIP/2.0 Via: SIP/2.0/UDP proxy.domain.com Via: SIP/2.0/UDP 10.1.1.1:4540;received=68.44.20.1;rport=9988
```

This request generates a response, which arrives at the proxy:

```
SIP/2.0 200 OK Via: SIP/2.0/UDP proxy.domain.com Via: SIP/2.0/UDP 10.1.1.1:4540;received=68.44.20.1;rport=9988
```

The proxy strips its top Via, and then examines the next one. It con- tains both a received param, and an rport. The result is that the follow response is sent to IP address 68.44.20.1, port 9988:

```
SIP/2.0 200 OK Via: SIP/2.0/UDP 10.1.1.1:4540;received=68.44.20.1;rport=9988
```

The NAT rewrites the destination address of this packet back to IP 10.1.1.1, port 4540, and is received by the client.

### AntiFlood
```
#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xalert("ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif
```

#### src_ip
Reference to source IP address of the SIP message.

Example of usage:
```
if(src_ip==127.0.0.1)
{
        log("the message was sent from localhost!\n");
};
```

### myself
This is a reference to the list of local IP addresses, hostnames and aliases that has been set in the Kamailio configuration file. This lists contain the domains served by Kamailio.

The variable can be used to test if the host part of an URI is in the list. The usefulness of this test is to select the messages that has to be processed locally or has to be forwarded to another server.

See “alias” to add hostnames,IP addresses and aliases to the list.

Example of usage:
```
if(uri==myself) {
        log("the request is for local processing\n");
};
```

### alias
Parameter to set alias hostnames for the server. It can be set many times, each value being added in a list to match the hostname when 'myself' is checked.

It is necessary to include the port (the port value used in the “port=” or “listen=” defintions) in the alias definition otherwise the loose_route() function will not work as expected for local forwards. Even if you do not use 'myself' explicitly (for example if you use the domain module), it is often necessary to set the alias as these aliases are used by the loose_routing function and might be needed to handle requests with pre-loaded route set correctly.

Example of usage:
```
    alias=other.domain.com:5060
    alias=another.domain.com:5060
```

### $si - Source IP address
$si - reference to IP source address of the message

### $sht(htable=>key)
Access hash table entries.

It is R/W variable, you can assign values to it directly in configuration file. Hash table entry can be deleted by assigning value $null to it.

The “htname” must be a hash table name defined via “htable” parameter.

The “key” can be:

* static string - set of characters without pseudo-variables
* dynamic string - set of characters that include pseudo-variables. The pseudo-variables will be evaluated at runtime.
```
...
modparam("htable", "htable", "a=>size=4;")
...
$sht(a=>$au) = 1;
$sht(a=>$ru) = $fu;
...
```

### pike_check_req()
Process the source IP of the current request and return false if the IP was exceeding the blocking limit.

Return codes:
* 1 (true) - IP is not to be blocked or internal error occurred.

Warning
IMPORTANT: in case of internal error, the function returns true to avoid reporting the current processed IP as blocked.
* -1 (false) - IP is source of flooding, previously detected
* -2 (false) - IP is detected as a new source of flooding - first time detection

This function can be used from REQUEST_ROUTE|ONREPLY_ROUTE.

Example 1.5. pike_check_req usage
```
...
if (!pike_check_req()) { exit; };
...
```

### sampling_time_unit (integer)
Time period in seconds used for sampling (or the sampling accuracy). The smaller the better, but slower. If you want to detect peeks, use a small one. To limit the access (like total number of requests on a long period of time) to a proxy resource (a gateway for example), use a bigger value of this parameter.

IMPORTANT: a too small value may lead to performance penalties due to timer process overloading.

Default value is “2”.

Example 1.1. Set sampling_time_unit parameter
```
...
modparam("pike", "sampling_time_unit", 10)
...
```

### reqs_density_per_unit (integer)
How many requests should be allowed per sampling_time_unit before blocking all the incoming request from that IP. Practically, the blocking limit is between ( let's have x=reqs_density_per_unit) x and 3*x for IPv4 addresses and between x and 8*x for IPv6 addresses.

Default value is 30.

Example 1.2. Set reqs_density_per_unit parameter
```
...
modparam("pike", "reqs_density_per_unit", 30)
...
```

### remove_latency (integer)
Specifies for how long the IP address will be kept in memory after the last request from that IP address. It's a sort of timeout value, in seconds. Note that it is not the duration to keep the IP in state 'blocked'. An IP is unblocked next occurrence of 'sampling_time_unit' that does not exceed 'reqs_density_per_unit'. Keeping an IP in memory results in faster reaching of blocked state -- see the notes about the limits of getting to state 'blocked'.

Default value is 120.

Example 1.3. Set remove_latency parameter
```
...
modparam("pike", "remove_latency", 130)
...
```

### Scanner
```
if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent|pplsip") {
        # silent drop for scanners - uncomment next line if want to reply
        # sl_send_reply("200", "OK");
        exit;
}
```

### $ua - User agent header
$ua - reference to user agent header field

### Operators
The logical operators that can be used in 'expr':
```
  ==      equal
  !=      not equal
  =~      regular expression matching: Note: Posix regular expressions will be used, e.g. use [[:digit:]]{3} instead of \d\d\d
  !~      regular expression not-matching (NOT PORTED from Kamailio 1.x, use '!(x =~ y)')
  >       greater
  >=      greater or equal
  <       less
  <=      less or equal
  &&      logical AND
  ||      logical OR
  !       logical NOT
  [ ... ] test operator - inside can be any arithmetic expression
```

### sl_send_reply(code, reason)
For the current request, a reply is sent back having the given code and text reason. The reply is sent stateless, totally independent of the Transaction module and with no retransmission for the INVITE's replies. 'code' and 'reason' can contain pseudo-variables that are replaced at runtime.

Meaning of the parameters is as follows:

* code - Return code.
* reason - Reason phrase.

This function can be used from REQUEST_ROUTE, ERROR_ROUTE.

Example 1.2. sl_send_reply usage
```
...
sl_send_reply("404", "Not found");
...
sl_send_reply("$err.rcode", "$err.rreason");
...
```

### Max Forward
```
if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
}
```

### mf_process_maxfwd_header(max_value)
Same as maxfwd_process(max_value).


### maxfwd_process(max_value)
If no Max-Forward header is present in the received request, a header will be added having the original value equal with “max_value”. If a Max-Forward header is already present, its value will be decremented (if not 0). The parameter can be a variable.

Return codes:

* 2 (true) - header was not found and a new header was successfully added.
* 1 (true) - header was found and its value was successfully decremented (had a non-0 value).
* -1 (false) - the header was found and its value is 0 (cannot be decremented).
* -2 (false) - error during processing.

The return code may be extensively tested via script variable “retcode” (or “$?”).

Meaning of the parameters is as follows:
* max_value - Value to be added if there is no Max-Forwards header field in the message.

This function can be used from REQUEST_ROUTE.

Example maxfwd_process usage
```
...
# initial sanity checks -- messages with
# max_forwards==0, or excessively long requests
if (!maxfwd_process("10") && $retcode==-1) {
	sl_send_reply("483","Too Many Hops");
	exit;
};
...
```

### max_limit (integer)
Set an upper limit for the max-forward value in the outgoing requests. If the header is present, the decremented value is not allowed to exceed this max_limits - if it does, the header value will by decreased to “max_limit”.

Note: This check is done when calling the maxfwd_process() function.

The range of values stretches from 1 to 256, which is the maximum MAX-FORWARDS value allowed by RFC 3261. The value can be changed at runtime.

Default value is “70”.

Example Set max_limit parameter
```
...
modparam("maxfwd", "max_limit", 32)
...
```

**Max-Forward** header in the context of **Kamailio** and how it affects SIP requests:

1. **Purpose of Max-Forward Header**:
   - The Max-Forward header is used to prevent loops in a SIP (Session Initiation Protocol) network. 
   - Each server that processes and forwards a SIP request decrements the Max-Forward value by one.
   - When the value reaches zero, the request is not forwarded further, and an error response is sent back to the User Agent Client (UAC).

2. **Kamailio's Implementation**:
   - Kamailio provides a module called **maxfwd** that handles operations related to the Max-Forward header.
   - If no Max-Forward header is present in the received request, the module adds a header with an original value (specified as "max_value").
   - If a Max-Forward header is already present, the module decrements its value.
   - If the decremented value is positive and nonzero, an OK code is returned.
   - If the decremented value becomes zero, an error code is returned.
   - The module also allows setting an upper limit for the Max-Forward value in outgoing requests. The default maximum value is 256, as defined by RFC 3261¹³.


Remember that the Max-Forward header plays a crucial role in ensuring proper routing and preventing infinite loops in SIP networks


### Option Request
```
if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
}
```

### $ru - Request URI
$ru - reference to request's URI (address in the first line of a SIP request)

It is R/W variable (you can assign values to it directly in configuration file)

### $rU - Username in R-URI
$rU - reference to username in request's URI or to the Namespace Identifier of a URN (see RFC 2141)

### Snaity
```
if(!sanity_check("17895", "7")) {
        xlog("Malformed SIP request from $si:$sp\n");
        exit;
}
```

### Snaity Overview
This module aims to implement several sanity checks on incoming requests which are suggested or even required by a RFC, but are not available yet in the core of Kamailio.

These checks are not required by Kamailio itself for its functionality. But on the other side it does not make much sense if a broken request traverses through a SIP network if it is rejected sooner or later by a SIP device any way. As every sanity check cost extra performance because of additional parsing and evaluation it is with this module now up to the Kamailio administrator what checks should be done on which request.

The following checks are available:

* ruri sip version - (1) - checks if the SIP version in the request URI is supported, currently only 2.0.
* ruri scheme - (2) - checks if the URI scheme of the request URI is supported (sip[s]|tel[s]) by Kamailio
* required headers - (4) -checks if the minimum set of required headers To, From, CSeq, Call-ID and Via is present in the request.
* via sip version - (8) - disabled.
* via protocol - (16) - disabled.
* Cseq method - (32) - checks if the method from the CSeq header is equal to the request method.
* Cseq value - (64) - checks if the number in the CSeq header is a valid unsigned integer.
* content length - (128) - checks if the size of the body matches with the value from the Content-Length header.
* expires value - (256) - checks if the value of the Expires header is a valid unsigned integer.
* proxy require - (512) - checks if all items of the Proxy-Require header are present in the list of the extensions from the module parameter proxy_require.
* parse uri's - (1024) - checks if the specified URIs are present and parseable by the Kamailio parsers
* digest credentials (2048) - Check all instances of digest credentials in a message. The test checks whether there are all required digest parameters and that they have meaningful values. NOTE: the message will be considered invalid if the authorization scheme differs from "digest",
* duplicated To/From tags (4096) - checks for the presence of duplicated tags in To/From headers.
* Authorization header (8192) - checks if the Authorization header is valid if the scheme is "digest" (see "digest credentials" above), always returns success for other schemes.
* first via header (16384) - checks if the first Via header is available, can be parsed and has an address value.

### default_checks (integer)
This parameter determines which of the checks from the sanity module are executed if no parameter was given to the sanity_check function call. By default all implemented checks are included in the execution of the sanity_check function. The integer value is the sum of the check numbers which should be executed by default.

Default value is “3047”. This resolves to the following list of checks: ruri_sip_version (1), ruri_scheme (2), required_headers (4), cseq_method (32), cseq_value (64), content_length (128), expires_value (256), proxy_require (512), digest credentials (2048).

Example 1.1. Set default_checks parameter
```
...
modparam("sanity", "default_checks", 1)
...
```

### uri_checks (integer)
This parameter determines which URIs are going to be checked if the 'parse uri' will be executed.

Default value is 7. This resolves to the following list of parsed URIs: Request URI (1), From URI (2) and To URI (4). Additionally the Contact URI can be also checked (8).

Example 1.2. Set uri_checks parameter
```
...
modparam("sanity", "uri_checks", 3)
...
```

### autodrop (integer)
This parameter controls whether the module drops the SIP message automatically if the sanity checks fail. Default value is 1 (auto drop). If set to 0, sanity_check() function will return -1 (false) to configuration file, allowing to write log messages for example - be sure you “exit” execution of config without sending a SIP reply because it is sent by module itself.

Example 1.4. Set autodrop parameter
```
...
modparam("sanity", "autodrop", 1)
...
```

### sanity_check([msg_checks [, uri_checks]])
This function makes a row of sanity checks over the given SIP request. The behavior of the function is also controlled by autodrop parameter. If autodrop=0, the function returns false (-1) if one of the checks failed. When autodrop=1, the function stops the execution of configuration file. In both cases, if one of the checks fails the module sends a precise error reply via SL send_reply(). Thus there is no need to reply with a generic error message.

The parameters can be static integers or variables holding integer values.

Example 1.6. sanity_check usage
```
...
if (!sanity_check()) {
	exit;
}
...
```

Optionally the function takes an integer argument which overwrites the global module parameter default_checks. This makes it possible to run certain tests from script regions. The integer value is again the sum of the checks (like for the module parameter) which should be executed at this function call.

Example 1.7. sanity_check usage with parameter
```
...
if (method=="REGISTER" && !sanity_check("256")) {
	/* the register contains an invalid expires value and is replied with a 400 */
	exit;
}
...
```

Optionally the function takes a second integer argument which overwrites the global module parameter uri_checks and thus determines which URIs will be checked if the parse uri test will be executed.

Example 1.8. sanity_check usage with two parameters
```
...
if (method=="INVITE" && !sanity_check("1024", "6")) {
	/* the INVITE contains an invalid From or To header and is replied with a 400 */
	exit;
}
...
```

## Table Sql Script
[sql script](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql)

## Structure
The structure of the kamailio.cfg can be seen as three parts:

* global parameters
* modules settings
* routing blocks

### Global Parameters Section
This is the first part of the configuration file, containing the parameters for the core of kamailio and custom global parameters.

Typically this is formed by directives of the form:

```
name=value
```

The name corresponds to a core parameter as listed in one of the next sections of this document. If a name is not matching a core parameter, then Kamailio will not start, rising an error during startup.

The value is typically an integer, boolean or a string

### Modules Settings Section
This is the second section of the configuration file, containing the directives to load modules and set their parameters.

It contains the directives loadmodule and modparam. In the default configuration file starts with the line setting the path to modules (the assignment to mpath core parameter).

Example of content:
```
loadmodule "debugger.so"
...
modparam("debugger", "cfgtrace", 1)

```

### Routing Blocks Section
This is the last section of the configuration file, typically the biggest one, containing the routing blocks with the routing logic for SIP traffic handled by Kamailio.

The only mandatory routing block is request_route, which contains the actions for deciding the routing for SIP requests.

See the chapter Routing Blocks in this document for more details about what types of routing blocks can be used in the configuration file and their role in routing SIP traffic and Kamailio behaviour.

Example of content:
```
request_route {

    # per request initial checks
    route(REQINIT);

    ...
}

branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}
```

# Kamailio Module
## Mysql Module
This is a module which provides MySQL connectivity for Kamailio. It implements the DB API defined in Kamailio.

### Install 
1. install mysql 
2. setup kamailio
in kamailio.config

    Pre-Processor
    ```
    #!define WITH_MYSQL
    ```

## SecFilter Module
### Overview Secfilter
This module has been designed to offer an additional layer of security over our communications. To achieve this, the following features are available:

- Blacklist to block user agents, IP addresses, countries, domains and users.
- Whitelist to allow user agents, IP addresses, countries, domains and users.
- Blacklist of destinations where the called number is not allowed.
- SQL injection attacks prevention.

When a function is called, it will be searched in the whitelist. If the value is not found, then the blacklist will be searched.

All data will be loaded into memory when the module is started. There is an RPC reload command to update all the data from database. It is also possible to add new data to the blacklist or whitelist using other RPC commands.

### Dependencies
The following modules must be loaded before this module:
* database -- Any db_* database module


### Database setup
Before running Kamailio with the secfilter module, it is necessary to setup the database table where the module will read the blacklist data from. In order to do that, if the table was not created by the installation script or you choose to install everything by yourself you can use the secfilter-create.sql SQL script in the database directories in the kamailio/scripts folder as a template. Database and table name can be set with module parameters so they can be changed, but the name of the columns must match the ones in the SQL script. You can also find the complete database documentation on the project webpage, https://www.kamailio.org/docs/db-tables/kamailio-db-devel.html.

Example 1.25. Example database content - secfilter table
```
		...
		+----+-----------+-----------+------------------+
		| id | action    | type      | data             |
		+----+-----------+-----------+------------------+
		|  1 | 0         | 2         | 1.1.1.1          |
		|  2 | 0         | 0         | friendly-scanner |
		|  3 | 0         | 0         | pplsip           |
		|  4 | 0         | 0         | sipcli           |
		|  5 | 0         | 4         | sipvicious       |
		|  6 | 0         | 1         | ps               |
		|  7 | 0         | 3         | 5.56.57.58       |
		|  8 | 1         | 0         | asterisk pbx     |
		|  9 | 1         | 2         | sip.mydomain.com |
		| 10 | 2         | 0         | 555123123        |
		| 11 | 2         | 0         | 555998776        |
		+----+-----------+-----------+------------------+
		...
```

Action values are:
* 0 (blacklist)
* 1 (whitelist)
* 2 (destination)

Type values are:
* 0 (user-agent)
* 1 (country)
* 2 (domain)
* 3 (IP address)
* 4 (user)

### Params secfilter
#### db_url (string)
Database URL.
Default value is ""
```
...
modparam("secfilter", "db_url", "mysql://user:pass@localhost/kamailio")
```

### Funcs secfilter
#### secf_check_ip ()
It checks if the source IP address is blacklisted. The search is approximate and data stored in the database will be compared as a prefix. For example, if we have blacklisted IP address 192.168.1. all messages from IPs like 192.168.1.% will be rejected.

Return values are:

* 2 = the value is whitelisted
* 1 = the value is not found
* -2 = the value is blacklisted

Example 1.9. secf_check_ip usage
```
        ...
secf_check_ip();
if ($? == -2) {
        xlog("L_ALERT", "$rm from $si blocked because IP address is blacklisted");
        exit;
}
        ...
```

#### secf_check_ua ()
It checks if the user-agent is blacklisted. The search is approximate and the comparison will be made using the values of the database as a prefix. If we add to the user-agent blacklist the word sipcli, every message whose user-agent is named, for example, sipcli/1.6 or sipcli/1.8 will be blocked. It is very useful to block different versions of the same program.

Return values are:

2 = the value is whitelisted
1 = the value is not found
-1 = error
-2 = the value is blacklisted
Example 1.10. secf_check_ua usage
```
        ...
secf_check_ua();
if ($? == -2) {
        xlog("L_ALERT", "$rm from $si blocked because UserAgent '$ua' is blacklisted");
        exit;
}
        ...
```

#### secf_check_country (string)
Similar to secf_check_ua. It checks if the country (IP address) is blacklisted. Geoip module must be loaded to get the country code.

Return values are:

2 = the value is whitelisted
1 = the value is not found
-1 = error
-2 = the value is blacklisted
Example 1.11. secf_check_country usage
```
        ...
if (geoip2_match("$si", "src")) {
        secf_check_country($gip2(src=>cc));
        if ($avp(secfilter) == -2) {
                xlog("L_ALERT", "$rm from $si blocked because Country '$gip2(src=>cc)' is blacklisted");
                exit;
        }
}
        ...
```

#### secf_check_from_hdr ()
It checks if any value of from header is blacklisted. It checks if from name or from user are in the users blacklist or whitelist. It also checks if the from domain is in the domains blacklist or whitelist. The blacklisted value will be used as a prefix and if we block, for example, the user sipvicious, all users whose name starts with this word will be considered as blacklisted.

Return values are:

4 = from name is whitelisted
3 = from domain is whitelisted
2 = from user is whitelisted
1 = from header not found
-1 = error
-2 = from user is blacklisted
-3 = from domain is blacklisted
-4 = from name is blacklisted
Example 1.12. secf_check_from_hdr usage
```
        ...
secf_check_from_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because From user '$fU' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because From domain '$fd' is blacklisted");
                exit;
        case -4:
                xlog("L_ALERT", "$rm to $si blocked because From name '$fn' is blacklisted");
                exit;
};
        ...
```

#### secf_check_to_hdr ()
Do the same as secf_check_from_hdr function but with the to header.

Return values are:
4 = to name is whitelisted
3 = to domain is whitelisted
2 = to user is whitelisted
1 = to header not found
-1 = error
-2 = to user is blacklisted
-3 = to domain is blacklisted
-4 = to name is blacklisted

Example 1.13. secf_check_to_hdr usage
```
        ...
secf_check_to_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because To user '$tU' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because To domain '$td' is blacklisted");
                exit;
        case -4:
                xlog("L_ALERT", "$rm to $si blocked because To name '$tn' is blacklisted");
                exit;
};
        ...
```

#### secf_check_contact_hdr ()
Do the same as secf_check_from_hdr function but with the contact header.

Return values are:
3 = contact domain is whitelisted
2 = contact user is whitelisted
1 = contact header not found
-1 = error
-2 = contact user is blacklisted
-3 = contact domain is blacklisted

Example 1.14. secf_check_contact_hdr usage
```
        ...
secf_check_contact_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because Contact user '$ct' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because Contact domain '$ct' is blacklisted");
                exit;
};
        ...
```

#### secf_check_dst (string)
It checks if the destination number is blacklisted. It must be user for INVITE messages. If the value of dst_exact_match is 1, the call will appear as blacklisted if the destination is exactly the same. If the value is 0, every destination whose number begins with a number appearing on the destination blacklist will be rejected.

Return values are:
2 (if the value is whitelisted)
1 (if the value not found)
-2 (if the value is blacklisted)

Example 1.15. secf_check_dst usage
```
...
if (is_method("INVITE")) {
        secf_check_dst($rU);
        if ($? == -2) {
                xlog("L_ALERT", "$rm from $si blocked because destination $rU is blacklisted");
                send_reply("403", "Forbidden");
                exit;
        }
}
...
```

## Sipdump Module
### Overview sipdump
This module writes SIP traffic and some associated details into local files. It intercepts automatically all the SIP traffic received or sent by Kamailio and provides a function to trigger storage from configuration file.

Received traffic has the tag 'rcv' and the one to be sent has the tag 'snd'. The tag value is provided as parameter for the config function.

Besides the SIP packets, the module aims to save details related to Kamailio runtime environment that are useful for troubleshooting, like process id, child rank, a.s.o.

The module should be useful for troubleshooting during development or testing of new deployments, especially when dealing with traffic over TLS with forward privacy, when other tools such as wireshark cannot decrypt. For production environments with a lot of SIP traffic, look at siptrace and sipcapture modules for a scalable alternative to capture all the SIP traffic and then search using Homer Sipcapture web toolkit.


### Params sipdump


### Funcs sipdump

## Dispatcher Module
### Links
* [kamailio.org](https://www.kamailio.org/docs/modules/devel/modules/dispatcher.html)
* [nickvsnetworking.com](https://nickvsnetworking.com/kamailio-dispatcher/)

### Tables
[standard](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql/standard-create.sql)
```
CREATE TABLE `version` (
    `id` INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,
    `table_name` VARCHAR(32) NOT NULL,
    `table_version` INT UNSIGNED DEFAULT 0 NOT NULL,
    CONSTRAINT table_name_idx UNIQUE (`table_name`)
);

INSERT INTO version (table_name, table_version) values ('version','1');
```

[Dispatcher](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql/dispatcher-create.sql)
```
CREATE TABLE `dispatcher` (
    `id` INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,
    `setid` INT DEFAULT 0 NOT NULL,
    `destination` VARCHAR(192) DEFAULT '' NOT NULL,
    `flags` INT DEFAULT 0 NOT NULL,
    `priority` INT DEFAULT 0 NOT NULL,
    `attrs` VARCHAR(128) DEFAULT '' NOT NULL,
    `description` VARCHAR(64) DEFAULT '' NOT NULL
);

INSERT INTO version (table_name, table_version) values ('dispatcher','4');
```


![](https://nickvsnetworking.com/wp-content/uploads/2019/01/dispatcher-kamctl.png)

[dispatcher table schema](https://kamailio.org/docs/db-tables/kamailio-db-4.3.x.html#idp15170408)


#### Fields
Each destination point must be on one line. First token is the **set id** (an integer value, also referenced by group id), followed by **destination address** (string value in full SIP URI format).

Optionally, these fields can be followed by:

**flags** - control the mode of using the destination address and sending keepalives. It is a bitwise value that can be built using the following flags:
* 1 (bit at index 0 - 1 <<0) - inactive destination
* 2 (bit at index 1 - 1 <<1) - temporary trying destination (in the way to become inactive if it does not reply to keepalives - there is a module parameter to set the threshold of failures)
* 4 (bit at index 2 - 1 <<2) - admin disabled destination
* 8 (bit at index 3 - 1 <<3) - probing destination (sending keep alives);
* 16 (bit at index 4 - 1 <<4) - skip DNS A/AAAA resolve at startup, useful when the hostname of the destination address is a NAPTR or SRV record only. Such addresses cannot be matched anymore with ds_is_from_list(...).

**priority**: sets the priority in destination list (based on it is done the initial ordering inside the set)

**attributes**: extra fields in form of name1=value1;...;nameN=valueN.

#### Special Attributes
There are some predefined names:
* 'duid' - used for call load dispatching. It must be an unique value to identify a destination (gateway address). Practically the load within the group is associated with this value.>
* 'maxload' - used for call load dispatching. It must be a positive integer, defining the upper limit of active calls per destination. When the limit is reached, then the gateway is no longer selected for new calls until an exiting call via that gateway is terminated. If set to 0, then no active call limit is used.>
* 'weight' - used for weight based load distribution. It must be set to a positive integer value between 1 and 100 (inclusive the limits), otherwise the destination address is ignored (its weight set to 0). The value represents the percent of calls to be sent to that gateways. The sum must not exceed 100, otherwise the destinations whose weight added to the sum go over 100 are ignored. If the sum is less than 100, then the last destination is used to fill the missing percentage. See also the description of the corresponding algorithm parameter for ds_select_dst().
* 'rweight' - used for relative weight based load distribution. It must be set to a positive integer value between 1 and 100 (inclusive the limits) otherwise host will be excluded from relative weight distribution type - its rweight is set to 0. See also the description of the corresponding algorithm parameter for ds_select_dst().
* 'socket' - used to set the sending socket for the gateway. It is used for sending the SIP traffic as well as OPTIONS keepalives.
* 'sockname' - used to set by name the sending socket for the gateway. It is used for sending the SIP traffic as well as OPTIONS keepalives and has priority over 'socket' attribute.
* 'ping_from' - used to set the From URI in OPTIONS keepalives. It overwrites the general ds_ping_from parameter.
* 'obproxy' - SIP URI of outbound proxy to be used when sending pings. It overwrites the general ds_outbound_proxy parameter.
* 'latency' - latency_stats initialization in ms.

### Params dispatcher
#### ds_ping_interval (int)
With this parameter you can define the interval for sending a request to a gateway marked as inactive upon a failed request routing to it. This parameter is only used, when the TM-Module is loaded. If set to “0”, the pinging of inactive gateway is disabled.

Default value is “0”.

Example 1.22. Set the “ds_ping_interval” parameter
```
...
modparam("dispatcher", "ds_ping_interval", 30)
...
```

#### ds_ping_method (string)
With this method you can define, with which method you want to probe the gateways. Pinging gateways feature depends on ds_ping_interval parameter.

Default value is “OPTIONS”.

Example 1.20. Set the “ds_ping_method” parameter

...
modparam("dispatcher", "ds_ping_method", "INFO")
...

##### SIP requests
There are fourteen SIP Request methods of which the first six are the most basic request / method types:

* INVITE = Establishes a session
* ACK = Confirms an INVITE request
* BYE = Ends a session
* CANCEL = Cancels establishing of a session
* REGISTER = Communicates user location (host name, IP)
* OPTIONS = Communicates information about the capabilities of the calling and receiving SIP phones
* PRACK = Provisional Acknowledgement
* SUBSCRIBE = Subscribes for Notification from the notifier
* NOTIFY = Notifies the subscriber of a new event
* PUBLISH = Publishes an event to the Server
* INFO = Sends mid session information
* REFER = Asks the recipient to issue call transfer
* MESSAGE = Transports Instant Messages
* UPDATE = Modifies the state of a session

##### SIP responses
SIP Requests are answered with SIP responses, of which there are six classes:

* 1xx = Informational responses, such as 180 (ringing)
* 2xx = Success responses
* 3xx = Redirection responses
* 4XX = Request failures
* 5xx = Server errors
* 6xx = Global failures

#### ds_ping_from (string)
With this Method you can define the "From:"-Line for the request, sent to the failed gateways. This method is only available, if compiled with the probing of failed gateways enabled.

Default value is “sip:dispatcher@localhost”.

Example 1.21. Set the “ds_ping_from” parameter

...
modparam("dispatcher", "ds_ping_from", "sip:proxy@sip.somehost.com")
...

#### ds_mark_dst([state])
Mark the last used address from destination set as inactive ("i"/"I"), active ("a"/"A"), disabled ("d"/"D") or trying ("t"/"T"). Apart of disabled state, a destination can be set in probing mode by adding ("p"/"P") flag. With this function, an automatic detection of failed gateways can be implemented. When an address is marked as inactive or disabled, it will be ignored by 'ds_select_dst' and 'ds_select_domain'.

The parameter state is optional, when it is missing, then the destination will be marked inactive (i.e., same as 'i').

Possible values for state parameter:

* "a" or "A" - the last destination should be set to active and the error-counter should set to "0".
* "i" or "I" - the last destination should be set to inactive and will be ignored in future requests.
* "t" or "T" - the last destination should be set to temporary trying state and failure counter is incremented. When the failure counter reaches the threshold, the destination will be set inactive.
* "p" and "P" - this has to be used in addition to one of the previous flags - the last destination will be set to probing. This mean the destination will be pinged with SIP OPTIONS requests from time to time to detect if it is up or down.

This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.

Example 1.53. ds_mark_dst usage
```
...
failure_route[tryagain] {
...
   if(t_check_status("500"))
      ds_mark_dst("ip"); # set to inactive and probing
...
}
...
```

#### ds_probing_threshold (int)
If you want to set a gateway into inactive mode, there can be a specific number of failed requests until it will change from "active" to "inactive". It is using the state "trying", that allows selection of gateway but indicates there was a failure previously with the gateway. The number of attempts can be set with this parameter. This parameter can be modified via ser config framework.

Default value is “1” (set inactive with first failure).

Example 1.23. Set the “ds_probing_threshold” parameter
```
...
modparam("dispatcher", "ds_probing_threshold", 10)
...
```

#### ds_inactive_threshold (int)
If you want to set a gateway into active mode (after being inactive), there can be a specific number of successful requests until it will change from "inactive" to "active". The number of attempts can be set with this parameter. This parameter can be modified via ser config framework.

Default value is “1” (set active with first success).

Example 1.24. Set the “ds_inactive_threshold” parameter

...
modparam("dispatcher", "ds_inactive_threshold", 10)
...


#### ds_ping_latency_stats (int)
Enable latency measurement when pinging nodes The estimator can be initialized at startup and reload using the attribute latency.

* If set to 0, disable latency measurement.
* If set to 1, enable latency measurement.

Default value is “0”.

Example 1.27. accessing the metrics
```
# using the command :
kamcmd dispatcher.list
...
DEST: {
	URI: sip:1.2.3.4
	FLAGS: AX
	PRIORITY: 9
	ATTRS: {
		BODY: latency=24
	}
	LATENCY: {
		AVG: 24.250000 # weighted moving average for the last few weeks
		STD: 1.035000  # standard deviation of AVG
		EST: 25.000000 # short term estimate, see parameter: ds_latency_estimator_alpha
		MAX: 26        # maximum value seen
		TIMEOUT: 0     # count of ping timeouts
	}
}
...
```

Example 1.28. Set the “ds_ping_latency_stats” parameter
```
...
modparam("dispatcher", "ds_ping_latency_stats", 1)
...
```

#### ds_probing_mode (int)
Controls what gateways are tested to see if they are reachable.

* Value 0: If set to 0, only the gateways with state PROBING are tested. After a gateway is probed, the PROBING state is cleared in this mode. This means that no probing will be executed at all only if flag in config file is set to 8/PROBING (please check destination list file syntaxis for more details), it will probe only one time at startup or after dispatcher reload.

* Value 1: If set to 1, all gateways are tested. If set to 1 and there is a failure of keepalive to an active gateway, then it is set to TRYING state. This means that probing will be executed all the time, but you can skip some servers with flag 4 in destination list file, for example.

* Value 2: if set to 2, only gateways in INACTIVE state with PROBING mode set are tested.

* Value 3: If set to 3, any gateway with state PROBING is continually probed without modifying/removing the PROBING state. This allows selected gateways to be probed continually, regardless of state changes.

Default value is “0”.

Example 1.26. Set the “ds_probing_mode” parameter
```
...
modparam("dispatcher", "ds_probing_mode", 1)
...
```

#### flags (int)
Various flags that affect dispatcher's behaviour. The flags are defined as a bitmask on an integer value. If flag 1 is set only the username part of the URI will be used when computing an URI based hash. If no flags are set the username, hostname and port will be used. The port is used only if different from 5060 (normal sip URI) or 5061 (in the sips: case).

If flag 2 is set, then failover support is enabled. The functions exported by the module will store the rest of addresses from the destination set in XAPVs, and use these XAVPs to try next address if the current-tried destination fails.

Default value is “0”.

Example 1.10. Set the “flags” parameter
```
...
modparam("dispatcher", "flags", 3)
...
```

#### ds_retain_latency_stats (int)
Retain latency stats for existing destinations when reloading from file or database.

If set to 0, stats for all destinations will be reset on reload.

If set to 1, stats for existing destinations will persist across reloads.

Default value is “0”.

Example 1.29. Set the “ds_retain_latency_stats” parameter
```
...
modparam("dispatcher", "ds_retain_latency_stats", 1)
...
```

#### use_default (int)
If the parameter is set to 1, the last address in destination set is used as a final option to send the request to. For example, it is useful when wanting to send the call to an announcement server saying: "the gateways are full, try later".

Default value is “0”.

Example 1.11. Set the “use_default” parameter
```
...
modparam("dispatcher", "use_default", 1)
...
```     

#### xavp_dst (str)
The name of the XAVP which will hold the list with addresses and associated properties, in the order they have been selected by the chosen algorithm. If use_default is 1, the values of last XAVP correspond to the last address in destination set. In case of using dispatcher.list file, you have to set the priority field for each destination to ensure a particular order there. The first XAVP is the current selected destination. All the other addresses from the destination set will be added in the XAVP list to be able to implement serial forking.

Note
You must set this parameter if you want to do load balancing fail over.

Default value is “_dsdst_”.

Example 1.12. Set the “xavp_dst” parameter
```
...
modparam("dispatcher", "xavp_dst", "_dsdst_")
...
```

#### $avp(id) - AVPs
$avp(id) - the value of the AVP identified by 'id'.
$(avp(id)[N]) - represents the value of N-th AVP identified by 'id'.

The 'id' can be:

“[(s|i):]name” - name is the id of an AVP; 's' and 'i' specifies if the id is string or integer. If missing, it is considered to be string.
“name” - the name is an AVP alias, or if the alias is not found, it is a string name
pseudo variable - if value of pv is integer, id is integer, if string, id is string
$(avp(id)[0]) can be written in shorter form as $avp(id) and $avp(s:name) as $avp(name).

AVPs are special variables that are attached to SIP transactions. It is a list of pairs (name,value). Before the transaction is created, the AVP list is attached to SIP request. Note that the AVP list works like a stack, last added value is retrieved first, and there can be many values for same AVP name, an assignment to the same AVP name does not overwrite old value, it will add the new value in the list.

To delete the first AVP with name 'id' you have to assign to it '$null':

```
$avp(id) = $null;
```

To delete all the AVP with name 'id' you have to assign $null to the index '*':

```
$(avp(id)[*]) = $null;
```

To overwrite the value of the AVP with name 'id' you have to assign the new value to the index '*':

```
$(avp(id)[*]) = newvalue;
```

The value of an AVP can be integer or string. To assign a value as string, it has to be enclosed in double quotes. To assign the value as integer, it has to be a valid number given without quotes.

Example of usage:
```
$avp(x) = 1;  # assign of integer value
$avp(x) = 2;
$avp(y) = "abc"; # assign of string value
if($(avp(x)[1])==1) {
  ...
}
$(avp(x)[1]) = $null;
It is R/W variable (you can assign values to it directly in configuration file).
```

#### $xavp(id) - XAVPs
xavp - eXtended AVPs - are variables that can store multiple values, which can also be grouped in a structure-like fashion. Their value can be a string, an integer number or a list of named values (child values).

They work like a stack, similar to AVPs, and are attached to SIP transactions and automatically destroyed when the transaction is finished.

Each xavp has a string name and can contain a string, and integer or a list of named values. The structure name (or root list name) and the value name (or field name, or child value name) are separated by => like $xavp(root=>field) where “root” is the name of the structure and “field” is the name of the (child) value.

To assign a single value use:

```
$xavp(root)="string value";
$xavp(root)=intnumber;
```

To assign a named value use:
```
$xavp(root=>field)="string value";
$xavp(root=>field)=intnumber;
```

Like avps, xavp act like a stack. To refer to an existing value, use an index. The newest xavp has index zero [0].
```
$xavp(root[0]=>field)=12;
```

If you assign a value without an index, a new xavp is allocated and the old one is pushed up the stack, becoming index [1]. Old index [1] becomes [2] etc.
```
# new item (person => [(lastname = "Smith")])
$xavp(person=>lastname)="Smith";
 
# add new item (person => [(lastname = "Doe")])
$xavp(person=>lastname)="Doe";
 
# add another named value to the last example item
#   (person => [(firstname="John"), (lastname = "Doe")])
$xavp(person[0]=>firstname)="John";
 
# add another named value to first example item
#   (person => [(firstname="Alice"), (lastname = "Smith")])
xavp(person[1]=>firstname)="Alice";
```

Another example:
```
# create new (the first) root xavp with a named value of string type
$xavp(sf=>uri)="sip:10.10.10.10";
 
# add named values (child values)
$xavp(sf[0]=>fr_timer)=10;
$xavp(sf[0]=>fr_inv_timer)=15;
$xavp(sf[0]=>headers)="X-CustomerID: 1234\r\n";
 
# create new (the second) root xavp with a named value of string type, moving previous one to sf[1]
$xavp(sf=>uri)="sip:10.10.10.11";
# add named values (child values)
$xavp(sf[0]=>fr_timer)=20;
$xavp(sf[0]=>fr_inv_timer)=35;
 
# create new (the third) xavp with a named value of string type, moving previous one to sf[1] and the other one to sf[2]
$xavp(sf=>uri)="sip:10.10.10.12";
# add named values (child values)
$xavp(sf[0]=>fr_timer)=10;
$xavp(sf[0]=>fr_inv_timer)=15;
$xavp(sf[0]=>headers)="X-CustomerID: pw45\r\n";
```

### Funcs dispatcher
#### ds_select(set, alg [, limit])
The method selects a destination from addresses set and adds it in the XAVP specified for this module. It is not updating R-URI nor the destination URI. The parameters have same meaning as for ds_select_dst().

If the bit 2 in 'flags' is set, the rest of the addresses from the destination set are stored in XAVP list (limited with an optional 'limit' parameter). You can execute 'ds_next_domain()' or 'ds_next_dst()' to use next address to achieve serial forking to all possible destinations.

This function can be used from ANY_ROUTE.

Example 1.51. ds_select usage
```
...
$var(a) = 4;
if(ds_select("1", "$var(a)")) {
    ds_next_domain();
    t_relay();
    exit;
}
...
```

#### ds_next_dst()
Takes the next destination address from the corresponding XAVPs and sets the dst_uri (outbound proxy address).

This function can be used from REQUEST_ROUTE, FAILURE_ROUTE


### RPC command dispatcher
#### dispatcher.set_state
Sets the state for a destination address (can be use to mark the destination as active or inactive).

Name: dispatcher.set_state

Parameters:

_state_ : state of the destination address
* “a”: active
* “i”: inactive
* “t”: trying
* “d”: disabled
The states “a”, “i” or “t” can be followed by “p” to set probing mode (e.g. 'ap', 'ip' or 'tp').

_group_: destination group id

_address_: address of the destination in the _group_ or 'all' to update all destinations in the group

Example:
```
...
# prototype: kamcmd dispatcher.set_state _state_ _group_ _address_
kamcmd dispatcher.set_state ip 2 sip:127.0.0.1:5080
kamcmd dispatcher.set_state ip 3 all
...
```

#### dispatcher.set_duid_state
Sets the state for a destination by matching on 'duid' attribute. The first two parameters 'state' and 'group' are the same like for RPC command 'dispatcher.set_state'. The third parameter 'duid' is the value to be matched against the 'duid' attribute of dispatcher destinations.

Example:
```
...
# prototype: kamcmd dispatcher.set_duid_state _state_ _group_ _duid_
kamcmd dispatcher.set_duid_state ip 2 xyz
...
```

#### dispatcher.list
Lists the routing groups with destination addresses and corresponding attributes.

Name: dispatcher.list

Parameters:

_rmode_ - (optional) response mode - can be: 'short' to get a shorter version of groups and destinations; 'full' to get more attributes per destination

Example:
```
kamcmd dispatcher.list
...
DEST: {
        URI: sip:192.168.0.1:5060
        FLAGS: AP
        PRIORITY: 12
}
...
```

FLAGS consist out of 2 letters. First letter describe status of destination: A-active, (I) inactive, (T) trying, (D) disabled. Second letter might be P or X. P is for probing, so AP means destination is active and it is tested by SIP options continuously. X means that there are no probing or sip pinging. So AX means that destination is assumed as active and it is not tested by SIP options. DX respectively is disabled destination that is not tested, etc.

#### dispatcher.reload
Reloads the groups and included destinations. The command is disabled for call load based dispatching (algorithm 10) since removal of destinations may leave the list of active calls with broken references.

Name: dispatcher.reload

Parameters: none

Example
```
kamcmd dispatcher.reload
```

#### dispatcher.ping_active
Sets the global state for sending keepalive requests to destinations.

Name: dispatcher.ping_active

Parameters:

_state_ : state of sending keepalives

* “0”: inactive (don't send)
* “1”: active (send)

If the state parameter is missing, the current state is returned. When state is changed, new and old values of the state are returned. Default value for state is 1.

Example:
```
...
# prototype: kamcmd dispatcher.ping_active _state_
kamcmd dispatcher.ping_active 0
...
```

#### dispatcher.add
Add a destination address to the in-memory dispatcher list. Reloading the dispatcher will remove any destinations that are only added to the in-memory dispatcher list.

Name: dispatcher.add

Parameters:

_group_: destination group id

_address_: address of the destination in the _group_

_flags_ (optional): as described in the list file format, default 0

_priority_ (optional): as described in the list file format, default 0

_attrs_ (optional): as described in the list file format, default ""

Example:
```
...
# prototype: kamcmd dispatcher.add _group_ _address_ _flags_ _priority_ _attrs_
kamcmd dispatcher.add 2 sip:127.0.0.1:5080
kamcmd dispatcher.add 3 sip:127.0.0.1:5075 8
kamcmd dispatcher.add 3 sip:127.0.0.1:5075 0 0 duid=abc;socket=udp:127.0.0.1:5060
...
```

#### dispatcher.remove
Remove a destination address from the in-memory dispatcher list. Reloading the dispatcher from file or database will re-add destinations that are removed using this command.

This command will remove all entries that match the group and address.

Name: dispatcher.remove

Parameters:

_group_: destination group id

_address_: address of the destination in the _group_

Example:
```
...
# prototype: kamcmd dispatcher.remove _group_ _address_
kamcmd dispatcher.remove 2 sip:127.0.0.1:5080
kamcmd dispatcher.remove 3 sip:127.0.0.1:5075;transport=udp
...
```

### Configuration
### Parameters
You’ll need to load the dispatcher module, by adding the below line with the rest of your loadmodules:
```
loadmodule "dispatcher.so"
```
Next we’ll need to set the module specific config using modparam for dispatcher:
```
modparam("dispatcher", "db_url", DBURL)                 #Use DBURL variable for database parameters
modparam("dispatcher", "ds_ping_interval", 10)          #How often to ping destinations to check status
modparam("dispatcher", "ds_ping_method", "OPTIONS")     #Send SIP Options ping
modparam("dispatcher", "ds_probing_threshold", 10)      #How many failed pings in a row do we need before we consider it down
modparam("dispatcher", "ds_inactive_threshold", 10)     #How many sucessful pings in a row do we need before considering it up
modparam("dispatcher", "ds_ping_latency_stats", 1)      #Enables stats on latency
modparam("dispatcher", "ds_probing_mode", 1)            #Keeps pinging gateways when state is known (to detect change in state)
```

Most of these are pretty self explanatory but you’ll probably need to tweak these to match your environment.

### Destination Setup
Like the permissions module, dispatcher module has groups of destinations.

For this example we’ll be using dispatch group 1, which will be a group containing our Media Gateways, and the SIP URIs are sip:mg1:5060 and sip:mg2:5060

From the shell we’ll use kamctl to add a new dispatcher entry.
```
kamctl dispatcher add 1 sip:mg1:5060 0 0 '' 'Media Gateway 1'
kamctl dispatcher add 1 sip:mg2:5060 0 0 '' 'Media Gateway 2' 
```

Alternately you could do this in the database itself:

```
INSERT INTO `dispatcher` (`id`, `setid`, `destination`, `flags`, `priority`, `attrs`, `description`) VALUES (NULL, '1', 'sip:mg3:5060', '0', '0', '', 'Media Gateway 3'); 
Or you could use Siremis GUI to add the entries.
```

You can use kamctl to show you the database entries:

```
kamctl dispatcher show
```

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/dispatcher-kamctl.png)

### Destination Status / Control
Checking Status
Next up we’ll check if our gateways are online, we’ll use kamcmd to show the current status of the destinations:
```
kamcmd dispatcher.list
```
![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamcmd-dispatcher.list-All-active-probing.png)

Here we can see our two media gateways, quick response times to each, and everything looks good.

Take a note of the FLAGS field, it’s currently set to AP which is good, but there’s a few states:

* AP – Active Probing – Destination is responding to pings & is up
* IP – Inactive Probing – Destination is not responding to pings and is probably unreachable
* DX – Destination is disabled (administratively down)
* AX – Looks like is up or is coming up, but has yet to satisfy minimum thresholds to be considered up (ds_inactive_threshold)
* TX – Looks like or is, down. Has stopped responding to pings but has not yet satisfied down state failed ping count (ds_probing_threshold)

### Adding Additional Destinations without Restarting
If we add an extra destination now, we can add it without having to restart Kamailio, by using kamcmd:
```
kamcmd dispatcher.reload
```
There’s some sanity checks built into this, if the OS can’t resolve a domain name in dispatcher you’ll get back an error:

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamcmd-failing-to-add-dispatcher.png)

### Administratively Disable Destinations
You may want to do some work on one of the Media Gateways and want to nicely take it offline, for this we use kamcmd again:

```
kamcmd dispatcher.set_state dx 1 sip:mg1:5060
```

Now if we check status we see MG1’s status is DX:

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamailio-dispatcher-destination-down.png)

Once we’re done with the maintenance we could force it into the up state by replacing dx with ap.

It’s worth noting that if you restart Kamailio, or reload dispatcher, the state of each destination is reset, and starts again from AX and progresses to AP (Up) or IP (Down) based on if the destination is responding.

### Routing using Dispatcher
The magic really comes down to single simple line, ds_select_dst();

The command sets the destination address to an address from the pool of up addresses in dispatcher.

You’d generally give ds_select_dst(); two parameters, the first is the destination set, in our case this is 1, because all our Media Gateway destinations are in set ID 1. The next parameter is is the algorithm used to work out which destination from the pool to use for this request.

Some common entries would be random, round robin, weight based or priority value.

In our example we’ll use a random selection between up destinations in group 1:

```
if(method=="INVITE"){
   ds_select_dst(1, 4);    #Get a random up destination from dispatcher
   route(RELAY);           #Route it
}
```

Now let’s try and make a call:

```
UA > Kamailio: SIP: INVITE sip:1111111@Kamailio SIP/2.0

Kamailio > UA: SIP: SIP/2.0 100 trying -- your call is important to us

Kamailio > MG1: SIP: INVITE sip:1111111@MG1 SIP/2.0 

MG1 > Kamailio: SIP: SIP/2.0 100 Trying
 
Kamailio > UA : SIP: SIP/2.0 100 Trying 

MG1 > Kamailio:  SIP: SIP/2.0 200 OK
 
Kamailio > UA :  SIP: SIP/2.0 200 OK 
```

And bingo, we’re connected to a Media Gateway 1.
If I try it again I’ll get MG2, then MG1, then MG2, as we’re using round robin selection.

### Destination Selection Algorithm
We talked a little about the different destination select algorithm, let’s dig a little deeper into the common ones, this is taken from the Dispatcher documentation:

* “0” – hash over callid
* “4” – round-robin (next destination).
* “6” – random destination (using rand()).
* “8” – select destination sorted by priority attribute value (serial forking ordered by priority).
* “9” – use weight based load distribution.
* “10” – use call load distribution. 
* “12” – dispatch to all destination in setid at once

For select destination sorted by priority (8) to work you need to include a priority, you can do this when adding the dispatcher entry or after the fact by editing the data. In the below example if MG1 is up, calls will always go to MG1, if MG1 is down it’ll go to the next highest priority (MG2).

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/priorities.png)

The higher the priority the more calls it will get
For use weight based load distribution (9) to work, you’ll need to set a weight as well, this is similar to priority but allows you to split load, for example you could put weight=25 on a less powerful or slower destination, and weight=75 for a faster or more powerful destination, so the better destination gets 75% of traffic and the other gets 25%. (You don’t have to do these to add to 100%, I just find it easier to think of them as percentages).

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamailio-dispatcher-weight.png)

use call load distribution (10) allows you to evenly split the number of calls to each destination. This could be useful if you’ve got say 2 SIP trunks with x channels on each trunk, but only x concurrent calls allowed on each. Like adding a weight you need to set a duid= value with the total number of calls each destination can handle.

dispatch to all destination in setid at once (12) allows you to perform parallel branching of your call to all the destinations in the address group and whichever one answers first will handle the call. This adds a lot of overhead, as for each destination you have in that set will need a new dialog to be managed, but it sure is quick for the user. The other major issue is let’s say I have three carriers configured in dispatcher, and I call a landline.

That landline will receive three calls, which will ring at the same time until the called party answers one of the calls. When they do the other two calls will stop ringing. This can get really messy.

### weight and rweight 
weight: use weight based load distribution. You have to set the attribute 'weight' for each address (gateway) in destination set. See also the description of the 'weight' attribute in the 'Special Attributes' section

rweight: use relative weight based load distribution. You have to set the attribute 'rweight' per each address in destination set. Active host usage probability is rweight/(SUM of all active host rweights in destination group).

The major difference from the weight distribution is the probability recalculation according to rweight value in case of destinations being active or inactive.

For example, 100 calls in 3-destinations group with rweight params 1/2/1 will be distributed as 25/50/25. If the third destination becomes inactive, the distribution is changed to 33/67/0. If the computation of percentage per destination is not an exact integer number, the value is trucated and the last destination is used to fill the remaining percentage till 100

### weight
|   id  |  setid  |  destination         | flags | priority |     attrs      | description |
| :---: | :-----: |    :------------:    | :---: | :------: |     :---:      | :--------:  | 
|   1   |     1   |  192.168.21.80:5060  |       |          |   weight=25    | node1       |
|   2   |     1   |  192.168.21.81:5060  |       |          |   weight=50    | node2       |
|   3   |     1   |  192.168.21.82:5060  |       |          |   weight=25    | node3       |

#### Example 1
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node1 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   0      |    75   |    25   | 


#### Example 2
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node2 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    25    |    0    |    75   | 

#### Example 3
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node3 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    50    |    50   |    0    | 


### rweight
|   id  |  setid  |  destination         | flags | priority |     attrs      | description |
| :---: | :-----: |    :------------:    | :---: | :------: |     :---:      | :--------:  | 
|   1   |     1   |  192.168.21.80:5060  |       |          |   rweight=25    | node1       |
|   2   |     1   |  192.168.21.81:5060  |       |          |   rweight=50    | node2       |
|   3   |     1   |  192.168.21.82:5060  |       |          |   rweight=25    | node3       |

#### Example 1
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node1 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   0      |    66   |    34   | 


#### Example 2
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node2 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    50    |    0    |    50   | 

#### Example 3
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node3 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    34    |    66   |    0    | 


### Detection state node
#### fr_timer (integer)
Timer which hits if no final reply for a request or ACK for a negative INVITE reply arrives (in milliseconds).

Default value is 30000 ms (30 seconds).

Example 1.1. Set fr_timer parameter
```
...
modparam("tm", "fr_timer", 10000)
...
```

state node
```
A(active) ---> T(trying)[active] ---> I(inactive) ---> A(active)
```
```
AX -> AP -> TP -> IP -> AP
```

params
```
modparam("tm", "fr_timer", 30000)                      # default retransmission timeout: 30sec

modparam("dispatcher", "ds_ping_interval", 10)         # How often to ping destinations to check status: 10sec
modparam("dispatcher", "ds_ping_method", "OPTIONS")    # Send SIP Options ping
modparam("dispatcher", "ds_probing_threshold", 5)      # How many failed pings in a row do we need before we consider it down (active -> inactive)
modparam("dispatcher", "ds_inactive_threshold", 2)     # How many sucessful pings in a row do we need before consider it up (inactive -> active)
```

```
AX --(10sec)--> AP --(30sec)--> TP --(50sec)--> IP --(20sec)--> AP
```


------------

for state AX to AP: 
```
AX -> AP = 1 * ping_interval
```

example:
```
AX -> AP = 1 * 10sec = 10sec
```

------------

for state AP to TP: 
```
AP -> TP = fr_timer
```

example:
```
AP -> TP = 30sec
```

------------

for state TP to IP: 
```
TP -> IP = probing_threshold * ping_interval
```

example:
```
TP -> IP = 5 * 10sec = 50sec 
```

------------


for state AP to IP:
```
AP -> IP = fr_timer + (probing_threshold * ping_interval)
```

example:
```
AP -> IP = 30sec + (5 * 10sec) = 80sec 
```

------------

for state IP to AP:
```
IP -> AP = inactive_threshold * ping_interval
```

example:
```
IP -> AP = 2 * 10sec = 20sec 
```

------------


### Managing Failure
Let’s say we try and send a call to one of our Media Gateways and it fails, we could forward that failure response to the UA, or, better yet, we could try on another Media Gateway.

Let’s set a priority of 10 to MG1 and a priority of 5 to MG2, and then set MG1 to reject the call.
![](https://nickvsnetworking.com/wp-content/uploads/2019/01/priorities-2.png)

We’ll also need to add a failure route, so let’s tweak our code:

```
if(method=="INVITE"){
        ds_select_dst(1, 12);
        t_on_failure("DISPATCH_FAILURE");
        route(RELAY);
}
```

And the failure route:
```
failure_route[DISPATCH_FAILURE]{
        ds_mark_dst("ip");
        xlog("Trying next destination");
        ds_next_dst();
        route(RELAY);
}
```

flag 2 is set, then failover support is enabled
...
modparam("dispatcher", "flags", 2)
...


ds_next_dst() gets the next available destination from dispatcher. Let’s see how this looks in practice:

``` 
UA > Kamailio: SIP: INVITE sip:1111111@Kamailio SIP/2.0

Kamailio > UA: SIP: SIP/2.0 100 trying -- your call is important to us

Kamailio > MG1: SIP: INVITE sip:1111111@MG1 SIP/2.0 

MG1 > Kamailio: SIP: SIP/2.0 100 Trying

MG1 > Kamailio:  SIP: SIP/2.0 404 Not Found
 
Kamailio > MG1 :  SIP: SIP/2.0 ACK

Kamailio > MG2: SIP: INVITE sip:1111111@MG2 SIP/2.0  

MG2 > Kamailio: SIP: SIP/2.0 100 Trying

MG2 > Kamailio:  SIP: SIP/2.0 200 OK
 
Kamailio > UA :  SIP: SIP/2.0 200 OK
```

### t_on_failure(failure_route)
Sets failure routing block, to which control is passed after a transaction completed with a negative result but before sending a final reply. In the referred block, you can either start a new branch (good for services such as forward_on_no_reply) or send a final reply on your own (good for example for message silo, which received a negative reply from upstream and wants to tell upstream "202 I will take care of it"). Note that the set of commands which are usable within failure_routes is strictly limited to rewriting URI, initiating new branches, logging, and sending stateful replies (t_reply). Any other commands may result in unpredictable behavior and possible server failure. Note that whenever failure_route is entered, uri is reset to value which it had on relaying. If it temporarily changed during a reply_route processing, subsequent reply_route will ignore the changed value and use again the original one.

Meaning of the parameters is as follows:

failure_route - Failure route block to be called.

Example 1.58. t_on_failure usage
```
...
route {
    t_on_failure("1");
    t_relay();
}

failure_route[1] {
    revert_uri();
    setuser("voicemail");
    append_branch();
}
...
```

[dispatcher explain 10 algorithm](https://www.kwancro.com/post/kamailio-dispatcher-module-hidden-gem/)

## Routing based on call load distribution
Imagine having to route calls to 30 media gateways but also ensuring that the number of calls across all of them is evenly maintained. Some have come up with solutions where a frequent query for call volume is sent to the media gateways and the results are stored and used to make routing decisions. Smart, but there are too many moving parts. Also, the routing decision based on call volume is as close to real time as the frequency of the gateway queries.

With call load distribution set as the algorithm in the dispatcher module, Kamailio can keep track of the calls (by call-ID) routed to the gateways. The gateway call volume will then be maintained through the configuration file by tracking each INVITE, BYE, CANCEL, positive and negative response code received. The beauty of this is that it does not have to be aware of call dialogs so is really lightweight.

## Setup
1. Set unique gateway IDs (duid)
Each gateway in the dispatcher table must have its own unique id called duid. This id is populated in the attribute (attrs) column of the dispatcher table. An example table of 3 gateways with druids of 1015, 1016 and 1017 would look like this:

```
+-----+--------+------------------+-------+----------+-----------+---------------+
| id  | setid  | destination      | flags | priority | attrs     | description   |
+-----+--------+------------------+-------+----------+-----------+---------------+
|  10 |  100   | sip:192.68.10.15 |     0 |       50 | duid=1015 |  gateway-01   |
|  11 |  100   | sip:192.68.10.16 |     0 |       50 | duid=1016 |  gateway-02   |
|  12 |  100   | sip:192.68.10.17 |     0 |       50 | duid=1017 |  gateway-03   |
+-----+--------+------------------+-------+----------+-----------+---------------+
```

2. Enable dispatcher to route calls to media gateways
In your configuration logic you can route calls to the gateways like this:

```
if(!ds_select_dst("100", "10")) {
    send_reply("404", "No destination");
    Exit;
}
```

3. Track calls
After sending the call to the gateway, in our configuration file we now have to make sure we keep track of the call and update the call load status of the gateway. The idea of how to go about tracking the calls can be split in 2 steps. Tracking a successful call attempt and tracking a failed call attempt.

ds_load_update() is the function used to track successful call attempts. We will call it when:
* we get a positive response (200 - 299) for the INVITE we sent to a gateway, update internal tracking as call confirmed
* we receive a BYE or CANCEL , update gateway load tracker

ds_load_unset() is the function for tracking failed call attempts. We will call it when:
* we receive a negative response code (300 - 799) then clear that call attempt from the gateway tracker.
Using th functions in the config file it would look something like this:

In the main route:
```
route {
    ...
	if(is_method("BYE|CANCEL"))
        ds_load_update();
    ...
}
In the onreply_route:

onreply_route {
    ...
    if(is_method("INVITE")
	{
        if(status=~"2[0-9][0-9]")
            ds_load_update();
        else if(status=~"[3-7][0-9][0-9]")
            ds_load_unset();
    }
    ...
}
```

And that is it. With this in place, the load on the gateways will always be evenly spread.

The latest dispatcher module documentation is quite detailed with options and example code and would definitely recommend reading it.

# Ctl Module
This module implements the binrpc transport interface for Kamailio RPCs. It supports various transports over which it speaks binrpc: Unix datagram sockets, Unix stream sockets, UDP and TCP. It also supports a backward compatible FIFO interface (using the old Kamailio FIFO protocol).

By default (if no parameters are changed in the config file) it uses a Unix stream socket under /tmp: /tmp/ser_ctl. This socket is also the default for kamcmd.

In general it's used in conjunction with kamcmd. kamcmd is a Unix tool for invoking Kamailio RPC functions. It can be used both in interactive mode (supports tab-completion and history) or command line mode.

Example 1.1. kamcmd example usage
```
$ kamcmd ps
11262	attendant
11268	udp receiver child=0 sock=127.0.0.1:5060
11269	udp receiver child=1 sock=127.0.0.1:5060
11270	udp receiver child=0 sock=192.168.1.101:5060
11271	udp receiver child=1 sock=192.168.1.101:5060
11272	slow timer
11273	timer
11274	ctl handler
11275	tcp receiver child=0
11276	tcp receiver child=1
11277	tcp main process
```

## params ctl
### binrpc (string)
Specifies the transport used for the binrpc protocol. The following transport protocol are supported: Unix datagram sockets, Unix stream sockets, UDP and TCP.

The format is: [ protocol:] address_port|path .

* For Unix sockets: [unixd|unixs|unix]:path where "unixd" means Unix datagram sockets and "unix" "unixs" mean Unix stream sockets. Examples: "unixd:/tmp/unix_dgram", "unixs:/tmp/unix_stream", "unix:/tmp/unix_stream".
* For UDP or TCP sockets: [udp|tcp]:address:port. If the address is "*" or missing, it will bind to all the local addresses (0.0.0.0). Examples: "udp:localhost:2046", "tcp:localhost:2046", "tcp:3012", "udp:*:3012".

If the protocol part is missing and the address/path part looks like a file system path it will default to a Unix stream socket and if not to an Unix UDP socket. Examples:

* "/tmp/unix_test" - equivalent to "unixs:/tmp/unix_test".
* "localhost:3000" - equivalent to "udp:localhost:3000".
Multiple transports / listen addresses can be specified, just by setting the parameter multiple times.

Default:"unix:/tmp/ser_ctl" (Unix stream socket). The default value is used only if no binrpc parameter is found in the config file.

Example 1.2. Set binrpc parameter
```
loadmodule "ctl"

# optional listen addresses, if no one is specified,
# ctl will listen on unixs:/tmp/ser_ctl

modparam("ctl", "binrpc", "unix:/tmp/ser_ctl") # default
modparam("ctl", "binrpc", "udp:localhost:2046")
modparam("ctl", "binrpc", "tcp:localhost:2046")
modparam("ctl", "binrpc", "unixd:/tmp/unix_dgram")  # unix datagram
modparam("ctl", "binrpc", "unixs:/tmp/unix_stream") # unix stream
modparam("ctl", "binrpc", "unix:/tmp/unix_default") # unix stream
modparam("ctl", "binrpc", "/tmp/unix_test")         # unix stream
modparam("ctl", "binrpc", "localhost:3000")         # udp
modparam("ctl", "binrpc", "tcp:3012")               # tcp any , port 3012
modparam("ctl", "binrpc", "udp:*:3012")             # udp any , port 3012
```

for example 
```
modparam("ctl", "binrpc", "tcp:localhost:8000")
```
```
kamcmd -s tcp:<IP>:8000 <Kamcmd_Command>
```

# sipp
## Main features
SIPp allows to generate one or many SIP calls to one remote system. The tool is started from the command line. In this example, two SIPp are started in front of each other to demonstrate SIPp capabilities.

Run sipp with embedded server (uas) scenario:

```
# ./sipp -sn uas
```

* must set remote_ip and remote_port in SIPp server 

On the same host, run sipp with embedded client (uac) scenario:
```
# ./sipp -sn uac 127.0.0.1
```

## Integrated scenarios
Integrated scenarios? Yes, there are scenarios that are embedded in SIPp executable. While you can create your own custom SIP scenarios (see how to create your own XML scenarios), a few basic (yet useful) scenarios are available in SIPp executable.

### UAC
Scenario file: uac.xml
```
SIPp UAC            Remote
    |(1) INVITE         |
    |------------------>|
    |(2) 100 (optional) |
    |<------------------|
    |(3) 180 (optional) |
    |<------------------|
    |(4) 200            |
    |<------------------|
    |(5) ACK            |
    |------------------>|
    |                   |
    |(6) PAUSE          |
    |                   |
    |(7) BYE            |
    |------------------>|
    |(8) 200            |
    |<------------------|
```

### UAC with media
Scenario file: uac_pcap.xml
```
SIPp UAC            Remote
    |(1) INVITE         |
    |------------------>|
    |(2) 100 (optional) |
    |<------------------|
    |(3) 180 (optional) |
    |<------------------|
    |(4) 200            |
    |<------------------|
    |(5) ACK            |
    |------------------>|
    |                   |
    |(6) RTP send (8s)  |
    |==================>|
    |                   |
    |(7) RFC2833 DIGIT 1|
    |==================>|
    |                   |
    |(8) BYE            |
    |------------------>|
    |(9) 200            |
    |<------------------|
```

### UAS
Scenario file: uas.xml
```
Remote              SIPp UAS
    |(1) INVITE         |
    |------------------>|
    |(2) 180            |
    |<------------------|
    |(3) 200            |
    |<------------------|
    |(4) ACK            |
    |------------------>|
    |                   |
    |(5) PAUSE          |
    |                   |
    |(6) BYE            |
    |------------------>|
    |(7) 200            |
    |<------------------|
```

## Create your own XML scenarios
Of course embedded scenarios will not be enough. So it’s time to create your own scenarios. A SIPp scenario is written in XML (a DTD that may help you write SIPp scenarios does exist and has been tested with jEdit - this is described in a later section). A scenario will always start with:

```
<?xml version="1.0" encoding="ISO-8859-1" ?>
<scenario name="Basic Sipstone UAC">
```

And end with:

```
</scenario>
```

Easy, huh? Ok, now let’s see what can be put inside. You are not obliged to read the whole table now! Just go in the next section for an example.

There are many common attributes used for flow control and statistics, that can be used for all of the message commands (i.e., <send> , <recv> , <nop> , <pause> , <sendCmd> and <recvCmd> ).

## Keyword list
### [service]
* Default:	(service)
* Description:	Service field, as passed in the -s service_name

### [remote_ip]
Description:	Remote IP address, as passed on the command line.

### [remote_port]
* Default:	5060
* Description:	Remote IP port, as passed on the command line. You can add a computed offset   remote_port+3 to this value.

## Options
* -sf : Loads an alternate XML scenario file.  To learn more about XML scenario
        syntax, use the -sd option to dump embedded scenarios. They contain all the

* -sn : Use a default scenario (embedded in the SIPp executable). If this option is
        omitted, the Standard SipStone UAC scenario is loaded.
        Available values in this version:

        * 'uac'      : Standard SipStone UAC (default).                                                                           
        * 'uas'      : Simple UAS responder.
        * 'regexp'   : Standard SipStone UAC - with regexp and variables.
        * 'branchc'  : Branching and conditional branching in scenarios - client.
        * 'branchs'  : Branching and conditional branching in scenarios - server.

* -inf : Inject values from an external CSV file during calls into the scenarios.
        First line of this file say whether the data is to be read in sequence
        (SEQUENTIAL), random (RANDOM), or user (USER) order.
        Each line corresponds to one call and has one or more ';' delimited data
        fields. Those fields can be referred as [field0], [field1], ... in the xml
        scenario file.  Several CSV files can be used simultaneously (syntax: -inf
        f1.csv -inf f2.csv ...)

* -r  : Set the call rate (in calls per seconds).  This value can bechanged during
        test by pressing '+', '_', '*' or '/'. Default is 10.
        pressing '+' key to increase call rate by 1 * rate_scale,
        pressing '-' key to decrease call rate by 1 * rate_scale,
        pressing '*' key to increase call rate by 10 * rate_scale,
        pressing '/' key to decrease call rate by 10 * rate_scale.


* -rp : Specify the rate period for the call rate.  Default is 1 second and default
        unit is milliseconds.  This allows you to have n calls every m milliseconds
        (by using -r n -rp m).
        Example: -r 7 -rp 2000 ==> 7 calls every 2 seconds.
        -r 10 -rp 5s => 10 calls every 5 seconds.

```
# -r 5 -rp 1s
0 ---1s--- 5 ---1s--- 10 ---1s--- 15 ---1s--- 20 ...
```


* -rate_scale : Control the units for the '+', '-', '*', and '/' keys.

* -rate_increase : Specify the rate increase every -rate_interval units (default is seconds).
                This allows you to increase the load for each independent logging period.
                Example: -rate_increase 10 -rate_interval 10s
                ==> increase calls by 10 every 10 seconds.

* -rate_max  : If -rate_increase is set, then quit after the rate reaches this value.
                Example: -rate_increase 10 -rate_max 100
                ==> increase calls by 10 until 100 cps is hit.

* -rate_interval : Set the interval by which the call rate is increased. Defaults to the value
                of -fd.

```
# -rate_increase 10 -rate_interval 1s 
1s -> 0+10=10
2s -> +10+10=20
3s -> +20+10=30
4s -> +30+10=40
5s -> +40+10=50

0 ---1s--- 10 ---1s--- 30 ---1s--- 60 ---1s--- 100 ---1s--- 150
```


* -no_rate_quit : If -rate_increase is set, do not quit after the rate reaches -rate_max.

* -l    : Set the maximum number of simultaneous calls. Once this limit is reached,
        traffic is decreased until the number of open calls goes down. Default:
        (3 * call_duration (s) * rate).

* -m  : Stop the test and exit when 'calls' calls are processed

* -users : Instead of starting calls at a fixed rate, begin 'users' calls at startup,
        and keep the number of calls constant.

* -p  : Set the local port number.  Default is a random free port chosen by the
        system.

* -s  : Set the username part of the resquest URI. Default is 'service'.

* -rsa : Set the remote sending address to host:port for sending the messages.

Example : 

server
```
# Server:  192.168.10.20:5060
sipp -sn uas 
```

client 
```
sipp -sn usc -rsa 192.168.10.20:5060 
```

Example : 

client 
```
# FreeSwitch:  192.168.10.20:5060
# Dialplan : 1010

sipp -sn usc -rsa 192.168.10.30:5060 -s 1010 
```

* -d : Controls the length of calls. More precisely, this controls the duration of
        'pause' instructions in the scenario, if they do not have a 'milliseconds'
        section. Default value is 0 and default unit is milliseconds.


Example :

when use -d not use miliseconds in pause

command
```
./sipp -sn uac 
```

scenario
```
<pause milliseconds="8000"/>
```

that config equal with :

command
```
./sipp -sn uac -d 8s
```

scenario
```
<pause/>
```


## Remote control
SIPp can be “remote-controlled” through a UDP socket. This allows for example

* To automate a series of actions, like increasing the call rate smoothly, wait for 10 seconds, increase more, wait for 1 minute and loop
* Have a feedback loop so that an application under test can remote control SIPp to lower the load, pause the traffic, …
Each SIPp instance is listening to a UDP socket. It starts to listen to port 8888 and each following SIPp instance (up to 60) will listen to base_port + 1 (8889, 8890, …).

It is then possible to control SIPp like this:

```
echo p >/dev/udp/x.y.z.t/8888 -> put SIPp in pause state (p key)
echo q >/dev/udp/x.y.z.t/8888 -> quit SIPp (q key)
```

## SIPp command line options:
Following a list of the most common command line options. You can obtain the full list executing the command sipp -h.

Scenario options
* -sn <scenario>: use a builtin scenario (uas, uac, regexp, ...)
* -sd <scenario>: dump the XML implementing the builtin scenario
* -sf <scenario-file>: load a custom scenario file
* -set <var> <val>: set the variable var with val value, the variable can then used into the scenario file as [$var]

SIP IP address and port
* -i <local_ip>: set the local IP address for the Contact, Via and From headers, can be referenced with [local_ip] keyword into a scenario file. Applies to the SIP protocol only.
* -p <local_port>: set the local port for the SIP protocol. Can be referenced using the [local_port]keyword.

Media and RTP options
* -mi <media_ip>: set the local media IP address, this value can also be referred using the [media_ip] keyword into the scenario file
* -mp <media_port>: set the local media port, this value can also be referred using the [media_port] keyword into the scenario file
* -rtp_echo: Enable RTP echo. RTP/UDP packets received on port defined by -mp are echoed to their sender.

Call rate options
* -l <max_calls>: set the maximum number of simultaneous calls
* -m <calls>: Stop the test and exit when calls calls are processed

Tracing and logging options
* -trace_msg: dump sent and received SIP messages in <scenario_file_name>_<pid>_messages.log
* -message_file: Set the name of the message log file
* -trace_err: trace all unexpected messages in <scenario_file_name>_<pid>_errors.log
* -error_file: set the name of the error log file
* -trace_logs: allow tracing of actions in <scenario_file_name>_<pid>_logs.log
* -log_file: set the name of the log actions log file

## SIPp scenario file syntax
root XML tag is named scenario and must have the name attribute:
```
<?xml version="1.0" encoding="utf-8" ?>
<scenario name="Basic UAC custom scenario">
  <!-- here your scenario -->
</scenario>
```

### Scenario commands
Here is a lost of the most important scenario commands:

* <send>: send a SIP message or a response. Important attributes are:
   * retrans: set the T1 timer for this message in milliseconds
   * lost: emulate packet lost, value in percentage
<recv>: wait for a SIP message or response. Important attributes are:

* response: indicates what SIP message code is expected
* request: indicates what SIP message request is expected
* optional: Indicates if the message to receive is optional. If optional is set to "global", SIPp will look every previous steps of the scenario
* lost: emulate packet lost, value in percentage
* timeout: specify a timeout while waiting for a message. If the message is not received, the call is aborted
* ontimeout: specify a label to jump to if the timeout popped regexp_match: boolean. Indicates if 'request' ('response' is not available) is given as a regular expression.
The recv command can also include the action tag defining the action to execute upon the message reception

* pause: pause the scenario execution. Important attributes are:
   * milliseconds: time to pause in milliseconds
   * variable: scenario variable defining the pause time

* nop: the nop action doesn’t do nothing at SIP signalling level, is just a tag containing the action subtag

* sendCmd: content to be sent to the twin 3PCC (3rd Party Call Control) SIPp instance. The Call-ID must be included

* recvCmd: specify an action when receiving the command

* label: a label is used when you want to branch to specific parts in your scenarios

## Common command attributes
Here is a list of attributes common to all the scenario commands:

* crlf: Displays an empty line after the arrow for the message in main SIPp screen
* next: You can put a "next" in any command element to go to another part of the script when you are done with sending the message. For optional receives, the next is only taken if that message was received
* test: You can put a "test" next to a "next" attribute to indicate that you only want to branch to the label specified with "next" if the variable specified in "test" is set
* display: Display a text into the SIPp screen

## Scenario keywords
Inside the send command, you have to enclose your SIP message between the <![CDATA and the ]]> tags.

Everything between those tags is going to be sent toward the remote system. Into the SIP message you can include some keywords (Eg. [service], [remote_ip], etc..).

Those keywords will get replaced at runtime by SIPp.

* [service]: service field, as passed in the -s <service_name> command line option (default: service)
* [remote_ip] and [remote_port]: remote IP address and port
* [transport]: the transport mode (depending on the -t CLI parameter) (default: UDP)
* [local_ip], [local_ip_type], [local_port]: depending on the -l and -p CLI params. Type can be 4 or 6
* [len]: computed length of the SIP body. To be used in Content-Length header
* [cseq]: generates automatically the CSeq number
* [call_id]: a call_id identifies a call and is generated by SIPp for each new call. In client mode, it is mandatory to use the value generated by SIPp in the Call-ID header
* [media_ip], [media_ip_type], [media_port]: depending on the value of -mi and -mp params.
* [last_*]: is replaced automatically by the specified header if it was present in the last message received (Eg. [last_From])
The ‘[last_*]’ keyword is replaced automatically by the specified header if it was present in the last message received (except if it was a retransmission). If the header was not present or if no message has been received, the ‘[last_*]’ keyword is discarded, and all bytes until the end of the line are also discarded. If the specified header was present several times in the message, all occurences are concatenated (CRLF separated) to be used in place of the ‘[last_*]’ keyword.
* [routes]: If the “rrs” attribute in a recv command is set to “true”, then the “Record-Route:” header of the message received is stored and can be recalled using the [routes] keyword.
* [next_url]: If the “rrs” attribute in a recv command is set to “true”, then the [next_url] contains the contents of the Contact header (i.e within the ‘<’ and ‘>’ of Contact)


## SIPp Scenarios for two way media call
for statefull scenario 

### Client
[client.xml](SIPp/client.xml)

1. Add rrs to receive response(200 ok)
```
  <recv response="200" rtd="true" rrs="true">
  </recv>
```

2. Add next_url and routes in ACK method
```
  <send>
    <![CDATA[

      ACK [next_url] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]
      From: sipp <sip:sipp@[local_ip]:[local_port]>;tag=[pid]SIPpTag00[call_number]
      To: [service] <sip:[service]@[remote_ip]:[remote_port]>[peer_tag_param]
      [routes]
      Call-ID: [call_id]
      CSeq: 1 ACK
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Content-Length: 0

    ]]>
  </send>
```

3. Add next_url and routes in BYE method
```
  <send retrans="500" crlf="true">
    <![CDATA[

      BYE [next_url] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]
      From: sipp <sip:sipp@[local_ip]:[local_port]>;tag=[pid]SIPpTag00[call_number]
      To: [service] <sip:[service]@[remote_ip]:[remote_port]>[peer_tag_param]
      [routes]
      Call-ID: [call_id]
      CSeq: 2 BYE
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]>
  </send>
```

### Server
[server.xml](SIPp/server.xml)

1. Add rrs to receive response INVITE method
```
  <recv request="INVITE" crlf="true" rrs="true">
  </recv>
```

2. Add last_Record-Route to send response (200 ok) 
```

  <send retrans="500">
    <![CDATA[

      SIP/2.0 200 OK
      [last_Via:]
      [last_From:]
      [last_To:];tag=[call_number]
      [last_Call-ID:]
      [last_CSeq:]
      Contact: <sip:[local_ip]:[local_port];transport=[transport]>
      [last_Record-Route:]
      Content-Type: application/sdp
      Content-Length: [len]

      v=0
      o=sipp 87308505 1 IN IP[local_ip_type] [local_ip]
      s=-
      t=0 0
      m=audio [media_port] RTP/AVP 8 101
      c=IN IP[media_ip_type] [media_ip]
      a=rtpmap:8 PCMA/8000
      a=rtpmap:101 telephone-event/8000
      a=fmtp:101 0-15
      a=ptime:20

    ]]>
  </send>

```

3. Add play pcap file 
* server pcap file and client pcap file are diffrent SSRC(Synchronization source identifier) in RTP packet(server and client) is must diffrent

* SSRC : Synchronization source identifier uniquely identifies the source of a stream. The synchronization sources within the same RTP session will be unique.
SSRC Identifies the synchronization source. The value is chosen randomly, with the intent that no two synchronization sources within the same RTP session will have the same SSRC. Although the probability of multiple sources choosing the same identifier is low, all RTP implementations must be prepared to detect and resolve collisions. If a source changes its source transport address, it must also choose a new SSRC to avoid being interpreted as a looped source

```
  <nop>
    <action>
        <exec play_pcap_audio="pcap/g711u.pcap"/>
    </action>
  </nop>
```

### Kmailio config

1. Add ewritehostport in request_route

```
if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484", "Address Incomplete");
        exit;
}

# dispatch destinations to PSTN
route(PSTN);

# add this lines
rewritehostport("1.2.3.4:5080"); # add ip and port SIPp server
route(RELAY);

# user location service
route(LOCATION);
```

## Scenario actions
In a recv, recvCmd or nop command you can execute one or more actions:

* ereg: execute a regular expression matching
* log: write a log message
* exec: execute a command on the operating system shell, or an internal SIPp command or play a pcap file
* jump: jump to an arbitrary scenario index


## Media/RTP commands
RTP streaming allows you to stream audio from a PCMA, PCMU, G722, iLBC or G729-encoded audio file (e.g. a .wav file). The “rtp_stream” action controls this.

* <exec rtp_stream=”file.wav” /> will stream the audio contained in file.wav, assuming it is a PCMA-format file.
* <exec rtp_stream=”[filename],[loopcount],[payloadtype]” /> will stream the audio contained in [filename], repeat the stream [loopcount] times (the default is 1, and -1 indicates it will repeat forever), and will treat the audio as being of [payloadtype] (where 8 is the default of PCMA, 0 indicates PCMU, 9 indicates G722, 18 indicates G729 and 98 indicates iLBC in 30ms 13.33kbps).
* <exec rtp_stream=”pause” /> will pause any currently active playback.
* <exec rtp_stream=”resume” /> will resume any currently paused playback.
PCAP play commands (specified using play_pcap_audio / play_pcap_video attributes) allow you to send a pre-recorded RTP stream using the pcap library. Choose play_pcap_audio to send the pre-recorded RTP stream using the “m=audio” SIP/SDP line port as a base for the replay.

Choose play_pcap_video to send the pre-recorded RTP stream using the “m=video” SIP/SDP line port as a base.

The play_pcap_audio/video command has the following format: play_pcap_audio=”[file_to_play]” with:

* file_to_play: the pre-recorded pcap file to play

The audio file should be the raw samples, example files are included for PCMA, G722 and iLBC (mode=30).

```
Codec	Payload id	Packet size	Packet time	FFMpeg arguments
PCMU	0	160 bytes	20 ms	-f ulaw -ar 8k -ac 1
PCMA	8	160 bytes	20 ms	-f alaw -ar 8k -ac 1
G722	9	160 bytes	20 ms	-f g722 -ar 16k -ac 1
G729	18	20 bytes	20 ms	not supported by ffmpeg
iLBC	98	50 bytes	30 ms	-f ilbc -ar 8k -ac 1 -b:a 13.33k
```

# Voice Over IP
## Chapter 1
## Introduction 
