# System Telephony

* [SIP](#sip)
    * [SIP Header](#what-is-a-sip-header)
        * [To](#to)
        * [Via](#via)
        * [Call-ID](#call-id)
        * [Contact](#contact)
        * [From](#from)
        * [Content-Length](#content-length)
        * [CSeq](#cseq)
        * [Max-Forwards](#max-forwards)
        * [Content-Type](#content-type)
* [PBX](#what-is-pbx-private-brand-exchange)
* [Kamailio](#kamailio)
    * [what is Kamailio?](#so-what-is-kamailio)
    * [Configuration](#configuration)
    * [Request Route](#the-request_route-block)
    * [SIP Register](#sip-registrar)
    * [Table Script](#table-sql-script)
    * [Structure](#structure)
    * [Global Parameters Section](#global-parameters-section)
    * [Modules Settings Section](#modules-settings-section)
    * [Routing Blocks Section](#routing-blocks-section)
    * [Structure](#)
    * [xlog](#xlog)
    * [sl_reply](#sl_reply)
    * [lookup](#lookup)
    * [t_relay](#t_relay)
    * [exit](#exit)
    * [Kamailio Module](#kamailio-module)
        * [Mysql Module](#mysql-module)
        * [Secfilter Module](#secfilter-module)
            * [Overview](#overview)
            * [Dependencies](#dependencies)
            * [Database setup](#database-setup)
            * [Parameters](#parameters)
            * [Functions](#functions)
        * [Dispatcher Module](#dispatcher-module)
            * [Links](#links)
            * [Params](#params)
            * [Functions](#functions-1)
            * [RPC Command](#rpc-command)
            * [Destination Selection Algorithm](#destination-selection-algorithm)
            * [Managing Failure](#managing-failure)
        * [Ctl Module](#ctl-module)
            * [Params](#params-1)
            
        



# SIP
## What is a SIP Header?
A SIP Header is a component of a SIP message that is used to convey information about the SIP message. Including the correct SIP Header and correctly formatting these SIP Headers is critical to ensure that requests are successfully routed to the right recipients. We'll try and run through some of the most common SIP Headers in this blogpost.

## Headers for the Standard SIP Call
Usually, an  INVITE message initiates a session—essentially a phone call—on the SIP protocol. While there are many other SIP headers, the nine outlined below supply the minimum required information to initiate  a call over a SIP trunking network. A  BYE request is used to terminate calls.

## To
The To header specifies the recipient of the call.
To: Indicates the intended recipient of the SIP request or response

Format
```
To: “(name)” <sip: (user)@(domain)>
```

## Via
The  Via header identifies a call’s path with the protocol name, protocol version, transport type,  user agent client (UAC), the protocol port for the request and a branch parameter which serves as a unique identifier for each  SIP transaction . The Via header routes SIP responses to the correct device, similar to a return address on a package. If a SIP request is routed through multiple devices, each UAC adds its own VIA header to the request before sending it on.
Via: Provides information about the routing path and transport protocol used in the SIP message

Format
```
Via: SIP/(protocol version)/(transport type) (UAC):(protocol port);branch=(branch number) 
```

## Call-ID
The Call-ID SIP Header creates a globally unique identifier for the call. To ensure that each Call-ID identifier is globally unique, a random number is generated (which often looks like this: f_169eac17a017b0a4e0adfa8_I), and the sender’s IP address is appended to this number. This guarantees that the Call-ID number will be globally unique, since no two devices will have the same IP address.
Call-ID: Generated by the sender, it’s a unique identifier that allows the related SIP messages to be grouped as part of the same call

Format
```
Call-ID: (generated number)@(ip\_address) 
```

## Contact
The Contact header identifies the most direct route for sending future requests to the requesting device. The Contact header specifies a caller domain name or IP address and a transport type.

Format
```
Contact: sip:(user)@(domain);transport=(transport type) 
```

## From
The From header specifies who the call is coming from.
From: Specifies the sender of the SIP request or response

Format
```
From: “(name)” <sip: (user)@(domain)> 
```

## Content-Length
The Content-Length header specifies the size of the message content in bytes. A Content-Length of 0 indicates that there is no message body.

Format
```
Content-Length: (number of bytes in message body) 
```

## CSeq
The CSeq header specifies the number of requests of each type that have been sent. For example, CSeq: 15 INVITE means that is the 15th invite request. The number increases by one for each additional request of the same type.
CSeq: Contains a sequence number and method (such as INVITE, ACK, and BYE) to indicate the order of SIP messages in a transaction

Format
```
CSeq: (number) (request type) 
```

## Max-Forwards
The Max-Forwards header limits the number of times a request can be forwarded on its way to the recipient. The number is reduced by one each time the request is forwarded. The Max-Forwards header prevents a request from endlessly circling the SIP network if the recipient cannot be found. The default value is 70.

Format
```
Max-Forwards: (maximum number of forwards) 
```

## Content-Type
If the message has a body, the Content-Type header identifies how the body is formatted. A text message might be identified as text/HTML or an application making a call might identify the content as application/SDP.

Format
```
Content-Type: (type of content)
```

# Kamailio Introduction
Kamailio (formerly OpenSER) is an open source SIP server, but Kamailio is a bit difficult to grasp what “it is“, but once you understand it’s all very logical.

Over this series I’ll attempt to explain what Kamailio is (and isn’t), and through a series of examples, show you how to use Kamailio to build cool stuff.

I’ll try and make it accessible for people with a background / understanding of VoIP, specifically with an understanding of SIP.

There’s a lot of meticulous documentation out there on specific Kamailio modules, but not much I could find that gives an overview of how the platform works, so over this series of Tutorials, I’ll attempt to cover the basics of using Kamailio to solve problems, as together we build a basic PBX with Kamailio, touching upon some of the common modules and core concepts of Kamailio.


## So what is Kamailio ?
Kamailio is a SIP Server.

It’s a bit confusing at the start, because Kamailio isn’t like FreeSWITCH, Asterisk, YATE, an SBC, a PBX or any of other telephony platforms you may have encountered before, because out of the box, Kamailio doesn’t really do anything.

You’ve got to tell Kamailio how to do everything.

Let’s take a SIP INVITE message, used to start a call (aka session) that we might send to a PBX with the domain name biloxi.example.com and a SIP endpoint registered as ‘101’:

INVITE sip:101@biloxi.example.com SIP/2.0
If we sent this message to a generic PBX, the PBX would have the logic to know that it has an extension 101 and the PBX would ring extension 101.

Our generic PBX looks at the Request URI in the INVITE message it received and has the logic predefined to know that 101 is a device it has registered and that we want to connect to that device, so sends the call to the matching device.

If we sent the same INVITE to an Asterisk box, Asterisk would take a look at our SIP INVITE message, and see if there’s an entry in the dialplan under the current context for 101. Asterisk doesn’t assume if you have a user registered on SIP/101 and receive a SIP INVITE to 101 that you want to get to SIP/101, it’d need to be told this through the dialplan.

Kamailio takes this example even further.

If we want to dial 101 on Kamailio and have it ring the device registered on 101, you have to tell Kamailio what to do when it receives an INVITE message in the first place, lookup if that destination is in our AOR (we’ll get to that) table, and then forward the INVITE to the destination if it exists, and forward the provisional responses (1xx) and finally the final response (200 OK) from the remote end back to the originator. Plus we’ve got to think about how we handle a scenario where the destination doesn’t exist, or isn’t registered, of if the destination returns a 4xx response to the INVITE, how we handle provisional responses and CANCEL messages and finally the BYE message (if we’re record routing).

Phew. This seems like a lot to handle.

It all seems pretty daunting at first, calling from one SIP Endpoint to another seems like a pretty rudimentary thing in a telephony product, but by putting how the system thinks, routes and manipulates messages up to you, we open the doors to all the possibilities.

What if you want something to sit in front of your servers and only allow certain SIP User Agents? Or load balance between several soft-switches? Or route least-cost between connected carriers and seamlessly failover if one is lost? Rate limit dodgy traffic before it hits your environment? Manage hundreds of thousands of registrations?

Kamailio can do all of that.

Kamailio can do anything you can think of (to do with signaling).

And that’s the awesome part of Kamailio. It is, what you define it to be.


## Configuration
We’ll open kamailio.cfg – the text file that contains all our routing info, and get to work.

```
vi /etc/kamailio/kamailio.cfg
```

You’ll see the config starts by defining what modules to load, and the config for each of these modules. For us, the defaults will work for now, let’s get to the juicy bits. Keep moving down the config file until you hit this section:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
```
The request_route section is what handles the initial SIP message that comes through.

We’ll remove all the text after request_route { leaving us with a blank canvas in terms of how we handle messages. We’ll then put in a single line to log to syslog when we get a SIP message:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        xlog("I got a message");
}
```

If we were to stop here and restart Kamailio, when a SIP message comes into our SIP server, we’d just write an entry to syslog saying “I got a message” each time we get a SIP message, but Kamailio won’t respond to the received SIP message, it’ll just enter a log entry each time it gets a SIP message. So let’s respond to any SIP message we get with a 501 “Not Implemented” message.

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        xlog("I got a message");
        sl_reply("501", "Not Implemented");
}
```

So let’s break down the two functions we just used.

## xlog("");
xlog is your friend.
Put simply xlog prints whatever you put inside the parenthesis to syslog.
You can use it to check to see if your messages are getting to the part of the config you want, check what pseudovariables are doing and many other things, but I’m getting ahead of myself. For now you just need to know xlog is like NoOp() in Asterisk, print() in Python, etc.

## sl_reply();
sl_reply is stateless reply.
It takes two parameters, the SIP Response Code and the text to go with it, when called it sends the SIP response code and text back to the requester.
In this case we’re using SIP Response Code 501, which translates to Not Implemented, meaning the server does not support the functionality required to fulfill the request aka:

## What is PBX (Private Brand Exchange)?
PBX stands for Private Branch Exchange. Think of it as an internal telephone network of a business or other entity. PBX phone system users can communicate with one another over the phone via internal lines, and make and receive external calls as well. A PBX phone system usually delivers business telephony features such as call forwarding, call transfer, call queue, auto-attendant, voicemail, etc.

PBX systems operate by using either VoIP (Voice Over Internet Protocol) or via analog or digital phone lines. With a PBX phone system, the physical phone line coming into your business can be split into multiple lines, allowing you to support more telephones. Better yet, calls between users are free

![](https://getvoip.com/uploads/VoIP-vs-PBX-e1662681663590.png)

## General Rules
Some rules of thumb to get you started with writing Kamailio configs:

* All lines that do things (instructions) have to end with a semicolon
* Comments start with # if single line or /* blah */ for multi-line
* Changes to the config only take effect when you restart Kamailio
* With what we have setup restarting Kamailio causes it to forget all about your active Registrations (Even though your devices might say they’re still registered) (For now, although we can change this behaviour)

Now we’ve got that out of the way let’s continue on from our last tutorial and start routing requests!

(We’ll skip all the config above the request_route{} block that configures the modules and their setup, it’s all very important, but we’ll touch upon that in a later tutorial I promise)

As I touched upon in the Introduction post, you define what Kamailio is and does in terms of routing SIP requests, so let’s jump straight in and get started on the blocks that take care of this.

## The request_route{} Block
The request_route{} block is where all our incoming SIP requests start off. Replies / responses are handled a bit differently (more on that later), but essentially every new SIP request / message / dialog starts off here.

We can create new blocks other than request_route{} to help keep our code clean, in the same way we might define functions while programming.

```
Let’s take a look:

request_route {
        route(RESPOND_501);    #Jump to the RESPOND_501 block
}

route[RESPOND_501]{
        sl_reply("501", "Not Implemented");   #Send 501 reply
}
```

We can see in the above example, any SIP Request coming in will enter our request_route{},

In our request_route{} block we only have one instruction, which is route().

The route() command allows us to then specify another block of the config file / code to continue on from. Think of it kind of like calling a function or god forbid – a GoTo. So in this example the call comes in and then routed off to a new routing block called route[RESPOND_501],

This allows us to reuse bits of code multiple times and generally keep everything a lot cleaner.

It’s worth noting that unless you tell it to, routing to another block won’t stop Kamailio from continuing to execute it’s way through the code, it’ll do what it’s told in the other routing block and then finish what it started.

Let’s look at an example:

```
request_route {
        xlog("Hello, I am in the request_route");
        route(RESPOND_501);    #Jump to the RESPOND_501 block
        xlog("Back in request_route");
}

route[RESPOND_501]{
        xlog("Now I am in the respond 501 route");
        sl_reply("501", "Not Implemented");   #Send 501 reply
}
```

If we’re to run this code and send a SIP Request to it, we’d see each of these xlog entries in your syslog,

* As the message firsts hits the xlog(“Hello, I am in the request_route”);, then is routed off to route[RESPOND_501]
* In route[RESPOND_501] we’ll see the xlog(Now I am in the respond 501 route”); – Kamailio has now executed the route[RESPOND_501] block and resumes from where it was in request_route{}

When we get back to request_route we get the final xlog(“Back in request_route”);.
We can stop routing in a specific block using the exit; command which stops processing that request once hit. For example:

```
request_route {
        xlog("Hello, I am in the request_route");
        route(RESPOND_501);    #Jump to the RESPOND_501 block
        xlog("Back in request_route");
}

route[RESPOND_501]{
        xlog(Now I am in the respond 501 route");
        sl_reply("501", "Not Implemented");   #Send 501 reply
        exit;
}
```

Because of the exit we added in the route[RESPOND_501] Kamailio stops executing at that point, so we don’t continue passing through the config file and this time we won’t get the final xlog(“Back in request_route”); call

## Basic Message Routing
Let’s take a very basic use case, and write some code in the request_route{} block.

We’ll set it up so if we receive an INVITE request, we’re going to respond with a 480 Temporarily Unavailable message, and for everything else, we’ll respond with 501 “Not Implemented”.

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

So let’s break this down,
First we have a an if statement – If the method of the SIP message is an INVITE request, then execute the code inside the curly brackets.

Inside the curly brackets we’ll respond with 480 Temporarily Unavailable, using sl_reply() (You may remember from the last post that sl_reply sends a reply back to the sender of the message with the response code and text specified) and then exit, meaning we won’t continue executing what’s next in the config.

Finally outside of our if statement (so catching any SIP requests who’s method isn’t INVITE) we’ll respond with 501 “Not Implemented”.

Here we can see our REGISTER message got back a 501 Not Implemented response, while our INVITE got a 480 Temporarily Unavailable response.

## SIP Registrar
As we talked about in the post on SIP Registrars, SIP Registrars take the REGISTER requests from SIP endpoints and store their contact details in the form of an Address on Record (AoR). This AoR contains the URI and the endpoints’ current IP it just sent the REGISTER message from.

The primary use of this is it allow us to know how to reach people. It’s kind of like an address book for mapping current IP against a SIP URI, as IP Addresses of SIP endpoints may change often.

So our Kamailio instance is going to receive an REGISTER message, store the Contact as an address on record, and respond 200 OK. Let’s build upon the config we started with in the last tutorial:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

So let’s add an if statement to manage REGISTER messages, and save their location:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        if(method=="REGISTER"){
                save("location");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```
So we’ve added an IF statement to find if the SIP method is a REGISTER message, and if it is, we’ll call the save(“location”); function.

The save() function saves the Contact address we just received to a database (in this case one in memory) in the form of a SIP URI and current Contact location, these two bits of info combined are known as an address on record (AoR) and the save function, if successful, responds with a 200 OK automatically.

So that’s it – Our SIP endpoint is happy and by calling the save(“location”) we’ve called the built in function to store the Contact as an Address on Record and respond with 200 OK.

So how do we access this information and what can we do with it?

Kamailio comes with two tools for accessing Kamailio while it’s running. In this example we’ll use kamcmd to check what’s registered on our system. After we’ve seen a device register, from command line we’ll run:

```
kamcmd ul.dump
```

This calls kamcmd the Kamailio command line tool, and calls the ul.dump function. ul is short for userloc – The module for user location management, and dump outputs all the contents of the userloc table.

![](https://nickvsnetworking.com/wp-content/uploads/2018/12/image-12.png)

## First Call
So now we’ve got Kamailio handling REGISTER traffic, and we know what IPs endpoints are on, so let’s join this together and let’s route a call between two endpoints via our Proxy!

We’ll work on the config we were working on in the previous tutorial:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        if(method=="REGISTER"){
                save("location");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

Let’s change how we handle the INVITE messages in our if(method==”INVITE”) block so instead of responding with a 480 Unavailable response, let’s lookup the location we saved if it was a REGISTER and forward the INVITE to the IP we’ve got.
```
if(method=="INVITE"){
        lookup("location");
        t_relay();
        exit();
}
```

Let’s break down each of the new functions we’ve introduced:


### lookup(“location”);
In the last post we introduced save(“location”); which saves an Address on Record for the URI. lookup(“location”); looks up the IP address of the URI we’re after in the Address on Record table we wrote to with our save(“location”); call and automatically sets it as the destination IP of where we’re going to send the message.

When a user registered via a SIP REGISTER request, we saved their details, now we’re looking them up.

You could even replace the lookup(“location”) call with say a SQL lookup on an address book, and save the output to the IP the INVITE will be forwarded to, but lookup(“location”); does this it all in one function.

### t_relay();
t_relay is transactional relay function. By transactional it means Kamailio remembers this session next time it’s referenced, we’ll touch upon transaction aware / stateful SIP proxies later, but for now what you need to know is it forwards the INVITE we just received to the address we got from our lookup(“location”).

### exit();
Exit bails out so we won’t keep processing after that, it doesn’t just bail out of our current conditional but stops processing this request further. Without it we’d still go on and send the 501 Not Implemented reply.

## **SIP Basics**:
   - SIP is a protocol used for initiating, maintaining, modifying, and terminating real-time communication sessions over IP networks. It's widely used for voice and video calls, instant messaging, and other multimedia applications.
   - SIP operates through a series of **methods** (requests) and corresponding **responses**.

## **SIP Methods**:
   - SIP requests are sent by the **User Agent Client (UAC)** to establish and manage sessions.
   - The first six basic SIP request methods are:
     - **INVITE**: Initiates a session (e.g., when you make a call).
     - **ACK**: Confirms an INVITE request.
     - **BYE**: Ends a session (hangs up the call).
     - **CANCEL**: Cancels the establishment of a session.
     - **REGISTER**: Communicates user location (host name, IP).
     - **OPTIONS**: Provides information about the capabilities of the calling and receiving SIP devices.

## **The "Trying" Response**:
   - When you initiate a call (send an INVITE request), the **User Agent Server (UAS)** receives it.
   - The UAS responds with a **provisional response** called **"100 Trying"**.
   - This response indicates that the call setup process is underway. It doesn't confirm success or failure; it's simply an acknowledgment that the request is being processed.
   - After the "100 Trying," the UAS may send a final response (e.g., "200 OK" for a successful call setup).

## **Example Scenario**:
   - Imagine you're calling a friend. Here's how it works:
     - You (UAC) send an INVITE to your friend (UAS).
     - Your friend's device responds with "100 Trying" to let you know they're processing the call.
     - If your friend accepts the call, they'll send a final "200 OK" response, and the call is established.


## Table Sql Script
[sql script](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql)

## Structure
The structure of the kamailio.cfg can be seen as three parts:

* global parameters
* modules settings
* routing blocks

### Global Parameters Section
This is the first part of the configuration file, containing the parameters for the core of kamailio and custom global parameters.

Typically this is formed by directives of the form:

```
name=value
```

The name corresponds to a core parameter as listed in one of the next sections of this document. If a name is not matching a core parameter, then Kamailio will not start, rising an error during startup.

The value is typically an integer, boolean or a string

### Modules Settings Section
This is the second section of the configuration file, containing the directives to load modules and set their parameters.

It contains the directives loadmodule and modparam. In the default configuration file starts with the line setting the path to modules (the assignment to mpath core parameter).

Example of content:
```
loadmodule "debugger.so"
...
modparam("debugger", "cfgtrace", 1)

```

### Routing Blocks Section
This is the last section of the configuration file, typically the biggest one, containing the routing blocks with the routing logic for SIP traffic handled by Kamailio.

The only mandatory routing block is request_route, which contains the actions for deciding the routing for SIP requests.

See the chapter Routing Blocks in this document for more details about what types of routing blocks can be used in the configuration file and their role in routing SIP traffic and Kamailio behaviour.

Example of content:
```
request_route {

    # per request initial checks
    route(REQINIT);

    ...
}

branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}
```

# Kamailio Module
## Mysql Module
This is a module which provides MySQL connectivity for Kamailio. It implements the DB API defined in Kamailio.

### Install 
1. install mysql 
2. setup kamailio
in kamailio.config

    Pre-Processor
    ```
    #!define WITH_MYSQL
    ```

## SecFilter Module
### Overview
This module has been designed to offer an additional layer of security over our communications. To achieve this, the following features are available:

- Blacklist to block user agents, IP addresses, countries, domains and users.
- Whitelist to allow user agents, IP addresses, countries, domains and users.
- Blacklist of destinations where the called number is not allowed.
- SQL injection attacks prevention.

When a function is called, it will be searched in the whitelist. If the value is not found, then the blacklist will be searched.

All data will be loaded into memory when the module is started. There is an RPC reload command to update all the data from database. It is also possible to add new data to the blacklist or whitelist using other RPC commands.

### Dependencies
The following modules must be loaded before this module:
* database -- Any db_* database module


### Database setup
Before running Kamailio with the secfilter module, it is necessary to setup the database table where the module will read the blacklist data from. In order to do that, if the table was not created by the installation script or you choose to install everything by yourself you can use the secfilter-create.sql SQL script in the database directories in the kamailio/scripts folder as a template. Database and table name can be set with module parameters so they can be changed, but the name of the columns must match the ones in the SQL script. You can also find the complete database documentation on the project webpage, https://www.kamailio.org/docs/db-tables/kamailio-db-devel.html.

Example 1.25. Example database content - secfilter table
```
		...
		+----+-----------+-----------+------------------+
		| id | action    | type      | data             |
		+----+-----------+-----------+------------------+
		|  1 | 0         | 2         | 1.1.1.1          |
		|  2 | 0         | 0         | friendly-scanner |
		|  3 | 0         | 0         | pplsip           |
		|  4 | 0         | 0         | sipcli           |
		|  5 | 0         | 4         | sipvicious       |
		|  6 | 0         | 1         | ps               |
		|  7 | 0         | 3         | 5.56.57.58       |
		|  8 | 1         | 0         | asterisk pbx     |
		|  9 | 1         | 2         | sip.mydomain.com |
		| 10 | 2         | 0         | 555123123        |
		| 11 | 2         | 0         | 555998776        |
		+----+-----------+-----------+------------------+
		...
```

Action values are:
* 0 (blacklist)
* 1 (whitelist)
* 2 (destination)

Type values are:
* 0 (user-agent)
* 1 (country)
* 2 (domain)
* 3 (IP address)
* 4 (user)

### Parameters
#### db_url (string)
Database URL.
Default value is ""
```
...
modparam("secfilter", "db_url", "mysql://user:pass@localhost/kamailio")
```

### Functions
#### secf_check_ip ()
It checks if the source IP address is blacklisted. The search is approximate and data stored in the database will be compared as a prefix. For example, if we have blacklisted IP address 192.168.1. all messages from IPs like 192.168.1.% will be rejected.

Return values are:

* 2 = the value is whitelisted
* 1 = the value is not found
* -2 = the value is blacklisted

Example 1.9. secf_check_ip usage
```
        ...
secf_check_ip();
if ($? == -2) {
        xlog("L_ALERT", "$rm from $si blocked because IP address is blacklisted");
        exit;
}
        ...
```

#### secf_check_ua ()
It checks if the user-agent is blacklisted. The search is approximate and the comparison will be made using the values of the database as a prefix. If we add to the user-agent blacklist the word sipcli, every message whose user-agent is named, for example, sipcli/1.6 or sipcli/1.8 will be blocked. It is very useful to block different versions of the same program.

Return values are:

2 = the value is whitelisted
1 = the value is not found
-1 = error
-2 = the value is blacklisted
Example 1.10. secf_check_ua usage
```
        ...
secf_check_ua();
if ($? == -2) {
        xlog("L_ALERT", "$rm from $si blocked because UserAgent '$ua' is blacklisted");
        exit;
}
        ...
```

#### secf_check_country (string)
Similar to secf_check_ua. It checks if the country (IP address) is blacklisted. Geoip module must be loaded to get the country code.

Return values are:

2 = the value is whitelisted
1 = the value is not found
-1 = error
-2 = the value is blacklisted
Example 1.11. secf_check_country usage
```
        ...
if (geoip2_match("$si", "src")) {
        secf_check_country($gip2(src=>cc));
        if ($avp(secfilter) == -2) {
                xlog("L_ALERT", "$rm from $si blocked because Country '$gip2(src=>cc)' is blacklisted");
                exit;
        }
}
        ...
```

#### secf_check_from_hdr ()
It checks if any value of from header is blacklisted. It checks if from name or from user are in the users blacklist or whitelist. It also checks if the from domain is in the domains blacklist or whitelist. The blacklisted value will be used as a prefix and if we block, for example, the user sipvicious, all users whose name starts with this word will be considered as blacklisted.

Return values are:

4 = from name is whitelisted
3 = from domain is whitelisted
2 = from user is whitelisted
1 = from header not found
-1 = error
-2 = from user is blacklisted
-3 = from domain is blacklisted
-4 = from name is blacklisted
Example 1.12. secf_check_from_hdr usage
```
        ...
secf_check_from_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because From user '$fU' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because From domain '$fd' is blacklisted");
                exit;
        case -4:
                xlog("L_ALERT", "$rm to $si blocked because From name '$fn' is blacklisted");
                exit;
};
        ...
```

#### secf_check_to_hdr ()
Do the same as secf_check_from_hdr function but with the to header.

Return values are:
4 = to name is whitelisted
3 = to domain is whitelisted
2 = to user is whitelisted
1 = to header not found
-1 = error
-2 = to user is blacklisted
-3 = to domain is blacklisted
-4 = to name is blacklisted

Example 1.13. secf_check_to_hdr usage
```
        ...
secf_check_to_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because To user '$tU' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because To domain '$td' is blacklisted");
                exit;
        case -4:
                xlog("L_ALERT", "$rm to $si blocked because To name '$tn' is blacklisted");
                exit;
};
        ...
```

#### secf_check_contact_hdr ()
Do the same as secf_check_from_hdr function but with the contact header.

Return values are:
3 = contact domain is whitelisted
2 = contact user is whitelisted
1 = contact header not found
-1 = error
-2 = contact user is blacklisted
-3 = contact domain is blacklisted

Example 1.14. secf_check_contact_hdr usage
```
        ...
secf_check_contact_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because Contact user '$ct' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because Contact domain '$ct' is blacklisted");
                exit;
};
        ...
```

#### secf_check_dst (string)
It checks if the destination number is blacklisted. It must be user for INVITE messages. If the value of dst_exact_match is 1, the call will appear as blacklisted if the destination is exactly the same. If the value is 0, every destination whose number begins with a number appearing on the destination blacklist will be rejected.

Return values are:
2 (if the value is whitelisted)
1 (if the value not found)
-2 (if the value is blacklisted)

Example 1.15. secf_check_dst usage
```
...
if (is_method("INVITE")) {
        secf_check_dst($rU);
        if ($? == -2) {
                xlog("L_ALERT", "$rm from $si blocked because destination $rU is blacklisted");
                send_reply("403", "Forbidden");
                exit;
        }
}
...
```

## Dispatcher Module
### Links
* [kamailio.org](https://www.kamailio.org/docs/modules/devel/modules/dispatcher.html)
* [nickvsnetworking.com](https://nickvsnetworking.com/kamailio-dispatcher/)

### Params
#### ds_ping_interval (int)
With this parameter you can define the interval for sending a request to a gateway marked as inactive upon a failed request routing to it. This parameter is only used, when the TM-Module is loaded. If set to “0”, the pinging of inactive gateway is disabled.

Default value is “0”.

Example 1.22. Set the “ds_ping_interval” parameter
```
...
modparam("dispatcher", "ds_ping_interval", 30)
...
```

#### ds_ping_method (string)
With this method you can define, with which method you want to probe the gateways. Pinging gateways feature depends on ds_ping_interval parameter.

Default value is “OPTIONS”.

Example 1.20. Set the “ds_ping_method” parameter

...
modparam("dispatcher", "ds_ping_method", "INFO")
...

##### SIP requests
There are fourteen SIP Request methods of which the first six are the most basic request / method types:

* INVITE = Establishes a session
* ACK = Confirms an INVITE request
* BYE = Ends a session
* CANCEL = Cancels establishing of a session
* REGISTER = Communicates user location (host name, IP)
* OPTIONS = Communicates information about the capabilities of the calling and receiving SIP phones
* PRACK = Provisional Acknowledgement
* SUBSCRIBE = Subscribes for Notification from the notifier
* NOTIFY = Notifies the subscriber of a new event
* PUBLISH = Publishes an event to the Server
* INFO = Sends mid session information
* REFER = Asks the recipient to issue call transfer
* MESSAGE = Transports Instant Messages
* UPDATE = Modifies the state of a session

##### SIP responses
SIP Requests are answered with SIP responses, of which there are six classes:

* 1xx = Informational responses, such as 180 (ringing)
* 2xx = Success responses
* 3xx = Redirection responses
* 4XX = Request failures
* 5xx = Server errors
* 6xx = Global failures

#### ds_ping_from (string)
With this Method you can define the "From:"-Line for the request, sent to the failed gateways. This method is only available, if compiled with the probing of failed gateways enabled.

Default value is “sip:dispatcher@localhost”.

Example 1.21. Set the “ds_ping_from” parameter

...
modparam("dispatcher", "ds_ping_from", "sip:proxy@sip.somehost.com")
...

#### ds_mark_dst([state])
Mark the last used address from destination set as inactive ("i"/"I"), active ("a"/"A"), disabled ("d"/"D") or trying ("t"/"T"). Apart of disabled state, a destination can be set in probing mode by adding ("p"/"P") flag. With this function, an automatic detection of failed gateways can be implemented. When an address is marked as inactive or disabled, it will be ignored by 'ds_select_dst' and 'ds_select_domain'.

The parameter state is optional, when it is missing, then the destination will be marked inactive (i.e., same as 'i').

Possible values for state parameter:

* "a" or "A" - the last destination should be set to active and the error-counter should set to "0".
* "i" or "I" - the last destination should be set to inactive and will be ignored in future requests.
* "t" or "T" - the last destination should be set to temporary trying state and failure counter is incremented. When the failure counter reaches the threshold, the destination will be set inactive.
* "p" and "P" - this has to be used in addition to one of the previous flags - the last destination will be set to probing. This mean the destination will be pinged with SIP OPTIONS requests from time to time to detect if it is up or down.

This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.

Example 1.53. ds_mark_dst usage
```
...
failure_route[tryagain] {
...
   if(t_check_status("500"))
      ds_mark_dst("ip"); # set to inactive and probing
...
}
...
```

#### ds_probing_threshold (int)
If you want to set a gateway into inactive mode, there can be a specific number of failed requests until it will change from "active" to "inactive". It is using the state "trying", that allows selection of gateway but indicates there was a failure previously with the gateway. The number of attempts can be set with this parameter. This parameter can be modified via ser config framework.

Default value is “1” (set inactive with first failure).

Example 1.23. Set the “ds_probing_threshold” parameter
```
...
modparam("dispatcher", "ds_probing_threshold", 10)
...
```

#### ds_inactive_threshold (int)
If you want to set a gateway into active mode (after being inactive), there can be a specific number of successful requests until it will change from "inactive" to "active". The number of attempts can be set with this parameter. This parameter can be modified via ser config framework.

Default value is “1” (set active with first success).

Example 1.24. Set the “ds_inactive_threshold” parameter

...
modparam("dispatcher", "ds_inactive_threshold", 10)
...


#### ds_ping_latency_stats (int)
Enable latency measurement when pinging nodes The estimator can be initialized at startup and reload using the attribute latency.

* If set to 0, disable latency measurement.
* If set to 1, enable latency measurement.

Default value is “0”.

Example 1.27. accessing the metrics
```
# using the command :
kamcmd dispatcher.list
...
DEST: {
	URI: sip:1.2.3.4
	FLAGS: AX
	PRIORITY: 9
	ATTRS: {
		BODY: latency=24
	}
	LATENCY: {
		AVG: 24.250000 # weighted moving average for the last few weeks
		STD: 1.035000  # standard deviation of AVG
		EST: 25.000000 # short term estimate, see parameter: ds_latency_estimator_alpha
		MAX: 26        # maximum value seen
		TIMEOUT: 0     # count of ping timeouts
	}
}
...
```

Example 1.28. Set the “ds_ping_latency_stats” parameter
```
...
modparam("dispatcher", "ds_ping_latency_stats", 1)
...
```

#### ds_probing_mode (int)
Controls what gateways are tested to see if they are reachable.

* Value 0: If set to 0, only the gateways with state PROBING are tested. After a gateway is probed, the PROBING state is cleared in this mode. This means that no probing will be executed at all only if flag in config file is set to 8/PROBING (please check destination list file syntaxis for more details), it will probe only one time at startup or after dispatcher reload.

* Value 1: If set to 1, all gateways are tested. If set to 1 and there is a failure of keepalive to an active gateway, then it is set to TRYING state. This means that probing will be executed all the time, but you can skip some servers with flag 4 in destination list file, for example.

* Value 2: if set to 2, only gateways in INACTIVE state with PROBING mode set are tested.

* Value 3: If set to 3, any gateway with state PROBING is continually probed without modifying/removing the PROBING state. This allows selected gateways to be probed continually, regardless of state changes.

Default value is “0”.

Example 1.26. Set the “ds_probing_mode” parameter
```
...
modparam("dispatcher", "ds_probing_mode", 1)
...
```

#### ds_retain_latency_stats (int)
Retain latency stats for existing destinations when reloading from file or database.

If set to 0, stats for all destinations will be reset on reload.

If set to 1, stats for existing destinations will persist across reloads.

Default value is “0”.

Example 1.29. Set the “ds_retain_latency_stats” parameter
```
...
modparam("dispatcher", "ds_retain_latency_stats", 1)
...
```

#### use_default (int)
If the parameter is set to 1, the last address in destination set is used as a final option to send the request to. For example, it is useful when wanting to send the call to an announcement server saying: "the gateways are full, try later".

Default value is “0”.

Example 1.11. Set the “use_default” parameter
```
...
modparam("dispatcher", "use_default", 1)
...
```     

#### xavp_dst (str)
The name of the XAVP which will hold the list with addresses and associated properties, in the order they have been selected by the chosen algorithm. If use_default is 1, the values of last XAVP correspond to the last address in destination set. In case of using dispatcher.list file, you have to set the priority field for each destination to ensure a particular order there. The first XAVP is the current selected destination. All the other addresses from the destination set will be added in the XAVP list to be able to implement serial forking.

Note
You must set this parameter if you want to do load balancing fail over.

Default value is “_dsdst_”.

Example 1.12. Set the “xavp_dst” parameter
```
...
modparam("dispatcher", "xavp_dst", "_dsdst_")
...
```

#### $avp(id) - AVPs
$avp(id) - the value of the AVP identified by 'id'.
$(avp(id)[N]) - represents the value of N-th AVP identified by 'id'.

The 'id' can be:

“[(s|i):]name” - name is the id of an AVP; 's' and 'i' specifies if the id is string or integer. If missing, it is considered to be string.
“name” - the name is an AVP alias, or if the alias is not found, it is a string name
pseudo variable - if value of pv is integer, id is integer, if string, id is string
$(avp(id)[0]) can be written in shorter form as $avp(id) and $avp(s:name) as $avp(name).

AVPs are special variables that are attached to SIP transactions. It is a list of pairs (name,value). Before the transaction is created, the AVP list is attached to SIP request. Note that the AVP list works like a stack, last added value is retrieved first, and there can be many values for same AVP name, an assignment to the same AVP name does not overwrite old value, it will add the new value in the list.

To delete the first AVP with name 'id' you have to assign to it '$null':

```
$avp(id) = $null;
```

To delete all the AVP with name 'id' you have to assign $null to the index '*':

```
$(avp(id)[*]) = $null;
```

To overwrite the value of the AVP with name 'id' you have to assign the new value to the index '*':

```
$(avp(id)[*]) = newvalue;
```

The value of an AVP can be integer or string. To assign a value as string, it has to be enclosed in double quotes. To assign the value as integer, it has to be a valid number given without quotes.

Example of usage:
```
$avp(x) = 1;  # assign of integer value
$avp(x) = 2;
$avp(y) = "abc"; # assign of string value
if($(avp(x)[1])==1) {
  ...
}
$(avp(x)[1]) = $null;
It is R/W variable (you can assign values to it directly in configuration file).
```

#### $xavp(id) - XAVPs
xavp - eXtended AVPs - are variables that can store multiple values, which can also be grouped in a structure-like fashion. Their value can be a string, an integer number or a list of named values (child values).

They work like a stack, similar to AVPs, and are attached to SIP transactions and automatically destroyed when the transaction is finished.

Each xavp has a string name and can contain a string, and integer or a list of named values. The structure name (or root list name) and the value name (or field name, or child value name) are separated by => like $xavp(root=>field) where “root” is the name of the structure and “field” is the name of the (child) value.

To assign a single value use:

```
$xavp(root)="string value";
$xavp(root)=intnumber;
```

To assign a named value use:
```
$xavp(root=>field)="string value";
$xavp(root=>field)=intnumber;
```

Like avps, xavp act like a stack. To refer to an existing value, use an index. The newest xavp has index zero [0].
```
$xavp(root[0]=>field)=12;
```

If you assign a value without an index, a new xavp is allocated and the old one is pushed up the stack, becoming index [1]. Old index [1] becomes [2] etc.
```
# new item (person => [(lastname = "Smith")])
$xavp(person=>lastname)="Smith";
 
# add new item (person => [(lastname = "Doe")])
$xavp(person=>lastname)="Doe";
 
# add another named value to the last example item
#   (person => [(firstname="John"), (lastname = "Doe")])
$xavp(person[0]=>firstname)="John";
 
# add another named value to first example item
#   (person => [(firstname="Alice"), (lastname = "Smith")])
xavp(person[1]=>firstname)="Alice";
```

Another example:
```
# create new (the first) root xavp with a named value of string type
$xavp(sf=>uri)="sip:10.10.10.10";
 
# add named values (child values)
$xavp(sf[0]=>fr_timer)=10;
$xavp(sf[0]=>fr_inv_timer)=15;
$xavp(sf[0]=>headers)="X-CustomerID: 1234\r\n";
 
# create new (the second) root xavp with a named value of string type, moving previous one to sf[1]
$xavp(sf=>uri)="sip:10.10.10.11";
# add named values (child values)
$xavp(sf[0]=>fr_timer)=20;
$xavp(sf[0]=>fr_inv_timer)=35;
 
# create new (the third) xavp with a named value of string type, moving previous one to sf[1] and the other one to sf[2]
$xavp(sf=>uri)="sip:10.10.10.12";
# add named values (child values)
$xavp(sf[0]=>fr_timer)=10;
$xavp(sf[0]=>fr_inv_timer)=15;
$xavp(sf[0]=>headers)="X-CustomerID: pw45\r\n";
```

### Functions
#### ds_select(set, alg [, limit])
The method selects a destination from addresses set and adds it in the XAVP specified for this module. It is not updating R-URI nor the destination URI. The parameters have same meaning as for ds_select_dst().

If the bit 2 in 'flags' is set, the rest of the addresses from the destination set are stored in XAVP list (limited with an optional 'limit' parameter). You can execute 'ds_next_domain()' or 'ds_next_dst()' to use next address to achieve serial forking to all possible destinations.

This function can be used from ANY_ROUTE.

Example 1.51. ds_select usage
```
...
$var(a) = 4;
if(ds_select("1", "$var(a)")) {
    ds_next_domain();
    t_relay();
    exit;
}
...
```

#### ds_next_dst()
Takes the next destination address from the corresponding XAVPs and sets the dst_uri (outbound proxy address).

This function can be used from REQUEST_ROUTE, FAILURE_ROUTE


### RPC Command
#### dispatcher.set_state
Sets the state for a destination address (can be use to mark the destination as active or inactive).

Name: dispatcher.set_state

Parameters:

_state_ : state of the destination address
* “a”: active
* “i”: inactive
* “t”: trying
* “d”: disabled
The states “a”, “i” or “t” can be followed by “p” to set probing mode (e.g. 'ap', 'ip' or 'tp').

_group_: destination group id

_address_: address of the destination in the _group_ or 'all' to update all destinations in the group

Example:
```
...
# prototype: kamcmd dispatcher.set_state _state_ _group_ _address_
kamcmd dispatcher.set_state ip 2 sip:127.0.0.1:5080
kamcmd dispatcher.set_state ip 3 all
...
```

#### dispatcher.set_duid_state
Sets the state for a destination by matching on 'duid' attribute. The first two parameters 'state' and 'group' are the same like for RPC command 'dispatcher.set_state'. The third parameter 'duid' is the value to be matched against the 'duid' attribute of dispatcher destinations.

Example:
```
...
# prototype: kamcmd dispatcher.set_duid_state _state_ _group_ _duid_
kamcmd dispatcher.set_duid_state ip 2 xyz
...
```

#### dispatcher.list
Lists the routing groups with destination addresses and corresponding attributes.

Name: dispatcher.list

Parameters:

_rmode_ - (optional) response mode - can be: 'short' to get a shorter version of groups and destinations; 'full' to get more attributes per destination

Example:
```
kamcmd dispatcher.list
...
DEST: {
        URI: sip:192.168.0.1:5060
        FLAGS: AP
        PRIORITY: 12
}
...
```

FLAGS consist out of 2 letters. First letter describe status of destination: A-active, (I) inactive, (T) trying, (D) disabled. Second letter might be P or X. P is for probing, so AP means destination is active and it is tested by SIP options continuously. X means that there are no probing or sip pinging. So AX means that destination is assumed as active and it is not tested by SIP options. DX respectively is disabled destination that is not tested, etc.

#### dispatcher.reload
Reloads the groups and included destinations. The command is disabled for call load based dispatching (algorithm 10) since removal of destinations may leave the list of active calls with broken references.

Name: dispatcher.reload

Parameters: none

Example
```
kamcmd dispatcher.reload
```

#### dispatcher.ping_active
Sets the global state for sending keepalive requests to destinations.

Name: dispatcher.ping_active

Parameters:

_state_ : state of sending keepalives

* “0”: inactive (don't send)
* “1”: active (send)

If the state parameter is missing, the current state is returned. When state is changed, new and old values of the state are returned. Default value for state is 1.

Example:
```
...
# prototype: kamcmd dispatcher.ping_active _state_
kamcmd dispatcher.ping_active 0
...
```

#### dispatcher.add
Add a destination address to the in-memory dispatcher list. Reloading the dispatcher will remove any destinations that are only added to the in-memory dispatcher list.

Name: dispatcher.add

Parameters:

_group_: destination group id

_address_: address of the destination in the _group_

_flags_ (optional): as described in the list file format, default 0

_priority_ (optional): as described in the list file format, default 0

_attrs_ (optional): as described in the list file format, default ""

Example:
```
...
# prototype: kamcmd dispatcher.add _group_ _address_ _flags_ _priority_ _attrs_
kamcmd dispatcher.add 2 sip:127.0.0.1:5080
kamcmd dispatcher.add 3 sip:127.0.0.1:5075 8
kamcmd dispatcher.add 3 sip:127.0.0.1:5075 0 0 duid=abc;socket=udp:127.0.0.1:5060
...
```

#### dispatcher.remove
Remove a destination address from the in-memory dispatcher list. Reloading the dispatcher from file or database will re-add destinations that are removed using this command.

This command will remove all entries that match the group and address.

Name: dispatcher.remove

Parameters:

_group_: destination group id

_address_: address of the destination in the _group_

Example:
```
...
# prototype: kamcmd dispatcher.remove _group_ _address_
kamcmd dispatcher.remove 2 sip:127.0.0.1:5080
kamcmd dispatcher.remove 3 sip:127.0.0.1:5075;transport=udp
...
```

### Configuration
### Parameters
You’ll need to load the dispatcher module, by adding the below line with the rest of your loadmodules:
```
loadmodule "dispatcher.so"
```
Next we’ll need to set the module specific config using modparam for dispatcher:
```
modparam("dispatcher", "db_url", DBURL)                 #Use DBURL variable for database parameters
modparam("dispatcher", "ds_ping_interval", 10)          #How often to ping destinations to check status
modparam("dispatcher", "ds_ping_method", "OPTIONS")     #Send SIP Options ping
modparam("dispatcher", "ds_probing_threshold", 10)      #How many failed pings in a row do we need before we consider it down
modparam("dispatcher", "ds_inactive_threshold", 10)     #How many sucessful pings in a row do we need before considering it up
modparam("dispatcher", "ds_ping_latency_stats", 1)      #Enables stats on latency
modparam("dispatcher", "ds_probing_mode", 1)            #Keeps pinging gateways when state is known (to detect change in state)
```

Most of these are pretty self explanatory but you’ll probably need to tweak these to match your environment.

### Destination Setup
Like the permissions module, dispatcher module has groups of destinations.

For this example we’ll be using dispatch group 1, which will be a group containing our Media Gateways, and the SIP URIs are sip:mg1:5060 and sip:mg2:5060

From the shell we’ll use kamctl to add a new dispatcher entry.
```
kamctl dispatcher add 1 sip:mg1:5060 0 0 '' 'Media Gateway 1'
kamctl dispatcher add 1 sip:mg2:5060 0 0 '' 'Media Gateway 2' 
```

Alternately you could do this in the database itself:

```
INSERT INTO `dispatcher` (`id`, `setid`, `destination`, `flags`, `priority`, `attrs`, `description`) VALUES (NULL, '1', 'sip:mg3:5060', '0', '0', '', 'Media Gateway 3'); 
Or you could use Siremis GUI to add the entries.
```

You can use kamctl to show you the database entries:

```
kamctl dispatcher show
```

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/dispatcher-kamctl.png)

### Destination Status / Control
Checking Status
Next up we’ll check if our gateways are online, we’ll use kamcmd to show the current status of the destinations:
```
kamcmd dispatcher.list
```
![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamcmd-dispatcher.list-All-active-probing.png)

Here we can see our two media gateways, quick response times to each, and everything looks good.

Take a note of the FLAGS field, it’s currently set to AP which is good, but there’s a few states:

* AP – Active Probing – Destination is responding to pings & is up
* IP – Inactive Probing – Destination is not responding to pings and is probably unreachable
* DX – Destination is disabled (administratively down)
* AX – Looks like is up or is coming up, but has yet to satisfy minimum thresholds to be considered up (ds_inactive_threshold)
* TX – Looks like or is, down. Has stopped responding to pings but has not yet satisfied down state failed ping count (ds_probing_threshold)

### Adding Additional Destinations without Restarting
If we add an extra destination now, we can add it without having to restart Kamailio, by using kamcmd:
```
kamcmd dispatcher.reload
```
There’s some sanity checks built into this, if the OS can’t resolve a domain name in dispatcher you’ll get back an error:

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamcmd-failing-to-add-dispatcher.png)

### Administratively Disable Destinations
You may want to do some work on one of the Media Gateways and want to nicely take it offline, for this we use kamcmd again:

```
kamcmd dispatcher.set_state dx 1 sip:mg1:5060
```

Now if we check status we see MG1’s status is DX:

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamailio-dispatcher-destination-down.png)

Once we’re done with the maintenance we could force it into the up state by replacing dx with ap.

It’s worth noting that if you restart Kamailio, or reload dispatcher, the state of each destination is reset, and starts again from AX and progresses to AP (Up) or IP (Down) based on if the destination is responding.

### Routing using Dispatcher
The magic really comes down to single simple line, ds_select_dst();

The command sets the destination address to an address from the pool of up addresses in dispatcher.

You’d generally give ds_select_dst(); two parameters, the first is the destination set, in our case this is 1, because all our Media Gateway destinations are in set ID 1. The next parameter is is the algorithm used to work out which destination from the pool to use for this request.

Some common entries would be random, round robin, weight based or priority value.

In our example we’ll use a random selection between up destinations in group 1:

```
if(method=="INVITE"){
   ds_select_dst(1, 4);    #Get a random up destination from dispatcher
   route(RELAY);           #Route it
}
```

Now let’s try and make a call:

```
UA > Kamailio: SIP: INVITE sip:1111111@Kamailio SIP/2.0

Kamailio > UA: SIP: SIP/2.0 100 trying -- your call is important to us

Kamailio > MG1: SIP: INVITE sip:1111111@MG1 SIP/2.0 

MG1 > Kamailio: SIP: SIP/2.0 100 Trying
 
Kamailio > UA : SIP: SIP/2.0 100 Trying 

MG1 > Kamailio:  SIP: SIP/2.0 200 OK
 
Kamailio > UA :  SIP: SIP/2.0 200 OK 
```

And bingo, we’re connected to a Media Gateway 1.
If I try it again I’ll get MG2, then MG1, then MG2, as we’re using round robin selection.

### Destination Selection Algorithm
We talked a little about the different destination select algorithm, let’s dig a little deeper into the common ones, this is taken from the Dispatcher documentation:

* “0” – hash over callid
* “4” – round-robin (next destination).
* “6” – random destination (using rand()).
* “8” – select destination sorted by priority attribute value (serial forking ordered by priority).
* “9” – use weight based load distribution.
* “10” – use call load distribution. 
* “12” – dispatch to all destination in setid at once

For select destination sorted by priority (8) to work you need to include a priority, you can do this when adding the dispatcher entry or after the fact by editing the data. In the below example if MG1 is up, calls will always go to MG1, if MG1 is down it’ll go to the next highest priority (MG2).

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/priorities.png)

The higher the priority the more calls it will get
For use weight based load distribution (9) to work, you’ll need to set a weight as well, this is similar to priority but allows you to split load, for example you could put weight=25 on a less powerful or slower destination, and weight=75 for a faster or more powerful destination, so the better destination gets 75% of traffic and the other gets 25%. (You don’t have to do these to add to 100%, I just find it easier to think of them as percentages).

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamailio-dispatcher-weight.png)

use call load distribution (10) allows you to evenly split the number of calls to each destination. This could be useful if you’ve got say 2 SIP trunks with x channels on each trunk, but only x concurrent calls allowed on each. Like adding a weight you need to set a duid= value with the total number of calls each destination can handle.

dispatch to all destination in setid at once (12) allows you to perform parallel branching of your call to all the destinations in the address group and whichever one answers first will handle the call. This adds a lot of overhead, as for each destination you have in that set will need a new dialog to be managed, but it sure is quick for the user. The other major issue is let’s say I have three carriers configured in dispatcher, and I call a landline.

That landline will receive three calls, which will ring at the same time until the called party answers one of the calls. When they do the other two calls will stop ringing. This can get really messy.

### Managing Failure
Let’s say we try and send a call to one of our Media Gateways and it fails, we could forward that failure response to the UA, or, better yet, we could try on another Media Gateway.

Let’s set a priority of 10 to MG1 and a priority of 5 to MG2, and then set MG1 to reject the call.
![](https://nickvsnetworking.com/wp-content/uploads/2019/01/priorities-2.png)

We’ll also need to add a failure route, so let’s tweak our code:

```
if(method=="INVITE"){
        ds_select_dst(1, 12);
        t_on_failure("DISPATCH_FAILURE");
        route(RELAY);
}
```

And the failure route:
```
route[DISPATCH_FAILURE]{
        xlog("Trying next destination");
        ds_next_dst();
        route(RELAY);
}
```

ds_next_dst() gets the next available destination from dispatcher. Let’s see how this looks in practice:

``` 
UA > Kamailio: SIP: INVITE sip:1111111@Kamailio SIP/2.0

Kamailio > UA: SIP: SIP/2.0 100 trying -- your call is important to us

Kamailio > MG1: SIP: INVITE sip:1111111@MG1 SIP/2.0 

MG1 > Kamailio: SIP: SIP/2.0 100 Trying

MG1 > Kamailio:  SIP: SIP/2.0 404 Not Found
 
Kamailio > MG1 :  SIP: SIP/2.0 ACK

Kamailio > MG2: SIP: INVITE sip:1111111@MG2 SIP/2.0  

MG2 > Kamailio: SIP: SIP/2.0 100 Trying

MG2 > Kamailio:  SIP: SIP/2.0 200 OK
 
Kamailio > UA :  SIP: SIP/2.0 200 OK
```

### t_on_failure(failure_route)
Sets failure routing block, to which control is passed after a transaction completed with a negative result but before sending a final reply. In the referred block, you can either start a new branch (good for services such as forward_on_no_reply) or send a final reply on your own (good for example for message silo, which received a negative reply from upstream and wants to tell upstream "202 I will take care of it"). Note that the set of commands which are usable within failure_routes is strictly limited to rewriting URI, initiating new branches, logging, and sending stateful replies (t_reply). Any other commands may result in unpredictable behavior and possible server failure. Note that whenever failure_route is entered, uri is reset to value which it had on relaying. If it temporarily changed during a reply_route processing, subsequent reply_route will ignore the changed value and use again the original one.

Meaning of the parameters is as follows:

failure_route - Failure route block to be called.

Example 1.58. t_on_failure usage
```
...
route {
    t_on_failure("1");
    t_relay();
}

failure_route[1] {
    revert_uri();
    setuser("voicemail");
    append_branch();
}
...
```


# Ctl Module
This module implements the binrpc transport interface for Kamailio RPCs. It supports various transports over which it speaks binrpc: Unix datagram sockets, Unix stream sockets, UDP and TCP. It also supports a backward compatible FIFO interface (using the old Kamailio FIFO protocol).

By default (if no parameters are changed in the config file) it uses a Unix stream socket under /tmp: /tmp/ser_ctl. This socket is also the default for kamcmd.

In general it's used in conjunction with kamcmd. kamcmd is a Unix tool for invoking Kamailio RPC functions. It can be used both in interactive mode (supports tab-completion and history) or command line mode.

Example 1.1. kamcmd example usage
```
$ kamcmd ps
11262	attendant
11268	udp receiver child=0 sock=127.0.0.1:5060
11269	udp receiver child=1 sock=127.0.0.1:5060
11270	udp receiver child=0 sock=192.168.1.101:5060
11271	udp receiver child=1 sock=192.168.1.101:5060
11272	slow timer
11273	timer
11274	ctl handler
11275	tcp receiver child=0
11276	tcp receiver child=1
11277	tcp main process
```

## params
### binrpc (string)
Specifies the transport used for the binrpc protocol. The following transport protocol are supported: Unix datagram sockets, Unix stream sockets, UDP and TCP.

The format is: [ protocol:] address_port|path .

* For Unix sockets: [unixd|unixs|unix]:path where "unixd" means Unix datagram sockets and "unix" "unixs" mean Unix stream sockets. Examples: "unixd:/tmp/unix_dgram", "unixs:/tmp/unix_stream", "unix:/tmp/unix_stream".
* For UDP or TCP sockets: [udp|tcp]:address:port. If the address is "*" or missing, it will bind to all the local addresses (0.0.0.0). Examples: "udp:localhost:2046", "tcp:localhost:2046", "tcp:3012", "udp:*:3012".

If the protocol part is missing and the address/path part looks like a file system path it will default to a Unix stream socket and if not to an Unix UDP socket. Examples:

* "/tmp/unix_test" - equivalent to "unixs:/tmp/unix_test".
* "localhost:3000" - equivalent to "udp:localhost:3000".
Multiple transports / listen addresses can be specified, just by setting the parameter multiple times.

Default:"unix:/tmp/ser_ctl" (Unix stream socket). The default value is used only if no binrpc parameter is found in the config file.

Example 1.2. Set binrpc parameter
```
loadmodule "ctl"

# optional listen addresses, if no one is specified,
# ctl will listen on unixs:/tmp/ser_ctl

modparam("ctl", "binrpc", "unix:/tmp/ser_ctl") # default
modparam("ctl", "binrpc", "udp:localhost:2046")
modparam("ctl", "binrpc", "tcp:localhost:2046")
modparam("ctl", "binrpc", "unixd:/tmp/unix_dgram")  # unix datagram
modparam("ctl", "binrpc", "unixs:/tmp/unix_stream") # unix stream
modparam("ctl", "binrpc", "unix:/tmp/unix_default") # unix stream
modparam("ctl", "binrpc", "/tmp/unix_test")         # unix stream
modparam("ctl", "binrpc", "localhost:3000")         # udp
modparam("ctl", "binrpc", "tcp:3012")               # tcp any , port 3012
modparam("ctl", "binrpc", "udp:*:3012")             # udp any , port 3012
```

for example 
```
modparam("ctl", "binrpc", "tcp:localhost:8000")
```
```
kamcmd -s tcp:<IP>:8000 <Kamcmd_Command>
```
