# System Telephony

* [SIP](#sip)
    * [SIP Header](#what-is-a-sip-header)
        * [To](#to)
        * [Via](#via)
        * [Call-ID](#call-id)
        * [Contact](#contact)
        * [From](#from)
        * [Content-Length](#content-length)
        * [CSeq](#cseq)
        * [Max-Forwards](#max-forwards)
        * [Content-Type](#content-type)
* [PBX](#what-is-pbx-private-brand-exchange)
* [Kamailio](#kamailio)
    * [what is Kamailio?](#so-what-is-kamailio)
    * [Configuration](#configuration)
    * [Request Route](#the-request_route-block)
    * [SIP Register](#sip-registrar)
    * [Table Script](#table-sql-script)
    * [Structure](#structure)
    * [Global Parameters Section](#global-parameters-section)
    * [Modules Settings Section](#modules-settings-section)
    * [Routing Blocks Section](#routing-blocks-section)
    * [Structure](#structure)
    * [REQINIT](#reqinit)
    * [onreply_route](#onreply_route)
    * [SIP route headers](#sip-route-headers)
    * [xlog](#xlog)
    * [sl_reply](#sl_reply)
    * [lookup](#lookup)
    * [t_relay](#t_relay)
    * [exit](#exit)
    * [Kamailio Module](#kamailio-module)
        * [Mysql Module](#mysql-module)
        * [Secfilter Module](#secfilter-module)
            * [Overview](#overview-secfilter)
            * [Dependencies](#dependencies)
            * [Database setup](#database-setup)
            * [Params](#params-secfilter)
            * [Functions](#funcs-secfilter)
        * [Sipdump Module](#sipdump-module)
            * [Overview](#overview-sipdump)
            * [Params](#params-sipdump) 
        * [Dispatcher Module](#dispatcher-module)
            * [Links](#links)
            * [Params](#params-dispatcher)
            * [Functions](#funcs-dispatcher)
            * [RPC Command](#rpc-command-dispatcher)
            * [Destination Selection Algorithm](#destination-selection-algorithm)
            * [weight and rweight](#weight-and-rweight)
            * [Detection state node](#detection-state-node)
            * [Managing Failure](#managing-failure)
        * [Ctl Module](#ctl-module)
            * [Params](#params-ctl)
* [sipp](#sipp)     
* [Linux](#linux)     
* [Voice over IP](#voice-over-ip)       
        



# SIP
## What is a SIP Header?
A SIP Header is a component of a SIP message that is used to convey information about the SIP message. Including the correct SIP Header and correctly formatting these SIP Headers is critical to ensure that requests are successfully routed to the right recipients. We'll try and run through some of the most common SIP Headers in this blogpost.

## Headers for the Standard SIP Call
Usually, an  INVITE message initiates a session—essentially a phone call—on the SIP protocol. While there are many other SIP headers, the nine outlined below supply the minimum required information to initiate  a call over a SIP trunking network. A  BYE request is used to terminate calls.

## To
The To header specifies the recipient of the call.
To: Indicates the intended recipient of the SIP request or response

Format
```
To: “(name)” <sip: (user)@(domain)>
```

## Via
The  Via header identifies a call’s path with the protocol name, protocol version, transport type,  user agent client (UAC), the protocol port for the request and a branch parameter which serves as a unique identifier for each  SIP transaction . The Via header routes SIP responses to the correct device, similar to a return address on a package. If a SIP request is routed through multiple devices, each UAC adds its own VIA header to the request before sending it on.
Via: Provides information about the routing path and transport protocol used in the SIP message

Format
```
Via: SIP/(protocol version)/(transport type) (UAC):(protocol port);branch=(branch number) 
```

## Call-ID
The Call-ID SIP Header creates a globally unique identifier for the call. To ensure that each Call-ID identifier is globally unique, a random number is generated (which often looks like this: f_169eac17a017b0a4e0adfa8_I), and the sender’s IP address is appended to this number. This guarantees that the Call-ID number will be globally unique, since no two devices will have the same IP address.
Call-ID: Generated by the sender, it’s a unique identifier that allows the related SIP messages to be grouped as part of the same call

Format
```
Call-ID: (generated number)@(ip\_address) 
```

## Contact
The Contact header identifies the most direct route for sending future requests to the requesting device. The Contact header specifies a caller domain name or IP address and a transport type.

Format
```
Contact: sip:(user)@(domain);transport=(transport type) 
```

## From
The From header specifies who the call is coming from.
From: Specifies the sender of the SIP request or response

Format
```
From: “(name)” <sip: (user)@(domain)> 
```

## Content-Length
The Content-Length header specifies the size of the message content in bytes. A Content-Length of 0 indicates that there is no message body.

Format
```
Content-Length: (number of bytes in message body) 
```

## CSeq
The CSeq header specifies the number of requests of each type that have been sent. For example, CSeq: 15 INVITE means that is the 15th invite request. The number increases by one for each additional request of the same type.
CSeq: Contains a sequence number and method (such as INVITE, ACK, and BYE) to indicate the order of SIP messages in a transaction

Format
```
CSeq: (number) (request type) 
```

## Max-Forwards
The Max-Forwards header limits the number of times a request can be forwarded on its way to the recipient. The number is reduced by one each time the request is forwarded. The Max-Forwards header prevents a request from endlessly circling the SIP network if the recipient cannot be found. The default value is 70.

Format
```
Max-Forwards: (maximum number of forwards) 
```

## Content-Type
If the message has a body, the Content-Type header identifies how the body is formatted. A text message might be identified as text/HTML or an application making a call might identify the content as application/SDP.

Format
```
Content-Type: (type of content)
```

## Transactions:
A transaction consists of a Request, any non-final (1xx) Responses received, and a final Response (2xx, 3xx, 4xx, 5xx, or 6xx), as well as the acknowledgements of the Responses (ACK or PRACK), except for ACKs to 2xx Responses. For example:

SIP peer A sends an INVITE Request to SIP peer B

SIP peer B returns a Response of 100 TRYING; this is a non-final Response, so the transaction is not completed yet

SIP peer B returns 200 OK (a final response), accepting the invitation; this completes the transaction

   - A **transaction** in SIP represents a sequence of messages exchanged between a **client** (usually the initiator) and a **server** (which responds to the client's requests).
   - A transaction consists of the following components:
     - **Request**: The initial message sent by the client (e.g., an INVITE request to establish a call).
     - **Non-final Responses (1xx)**: Intermediate responses (such as 100 TRYING) that indicate the progress of the transaction.
     - **Final Response (2xx, 3xx, 4xx, 5xx, or 6xx)**: The conclusive response (e.g., 200 OK) that completes the transaction.
     - **Acknowledgments (ACK or PRACK)**: Acknowledgments for the received responses (except for ACKs to 2xx Responses).
   - Example:
     - SIP peer A sends an INVITE Request to SIP peer B.
     - SIP peer B responds with a 100 TRYING (non-final response).
     - SIP peer B then sends a 200 OK (final response), accepting the invitation, completing the transaction.

## Dialogs:
A dialog is just a series of transactions between two SIP peers. The purpose of a dialog is to setup, possibly modify, and then teardown a session. Hence the name Session Initiation Protocol. Since there could be many dialogs in progress between two SIP peers at any time (e.g. there could be many simultaneous calls in progress between two SIP servers), dialogs are identified by the From, To, and Call-ID fields in the header. So if SIP peer A gets two BYE Requests at the same time, it can look at these fields to determine which dialog they belong to.
A typical set of transactions you might see in a dialog could include:

SIP peer A invites SIP peer B to a session and suggests a certain codec, but does not include authentication and so is rejected

SIP peer A again invites SIP peer B to a session, this time supplying authentication, and the invitation is accepted

SIP peer B sends an invitation to change the codec used, and it is accepted

SIP peer A ends the session

   - A **dialog** is a series of related transactions between two SIP peers (user agents).
   - The purpose of a dialog is to set up, modify, and eventually tear down a **session**.
   - Dialogs are identified by specific fields in the SIP header, including:
     - **From**: Identifies the sender.
     - **To**: Identifies the recipient.
     - **Call-ID**: A globally unique identifier for the call.
   - Example:
     - SIP peer A invites SIP peer B to a session (e.g., a voice call) and suggests a codec.
     - If rejected, SIP peer A retries with authentication, and the invitation is accepted.
     - During the dialog, SIP peer B may propose a codec change, which is accepted.
     - Finally, SIP peer A ends the session.

## Sessions:
A session is just a media stream (e.g. audio or video) flowing between peers, usually consisting of RTP (and possibly RTCP) packets. For example, if SIP is used to make a voice call, the session is the voice data that is sent between endpoints

   - A **session** represents the actual media stream (e.g., audio or video) flowing between peers.
   - It consists of RTP (Real-time Transport Protocol) packets (and possibly RTCP for control).
   - For instance, in a voice call, the session corresponds to the voice data transmitted between endpoints.

![](http://telconotes.files.wordpress.com/2013/03/sip-transaction-vs-dialog.png)

## [Understanding ther SIP Via header](https://andrewjprokop.wordpress.com/2014/03/06/understanding-the-sip-via-header/)

When a user agent client (UAC) creates a SIP request, it must insert a Via header into that request.  The Via header identifies the protocol name (SIP), protocol version (2.0), transport type (e.g. UDP or TCP), IP address of the UAC, and the protocol port (typically 5060) used for the request.  This information allows the recipient of the request (a user agent server) to return SIP responses to the correct device.  For example, if my SIP soft-phone were to send an INVITE request, it would contain a Via similar to the following.

```
Via: SIP/2.0/UDP 10.11.228.67:5060
```

If I were operating in a point-to-point configuration, the soft-phone that received the INVITE would  inspect the Via header to determine the location of my PC.  It would then use that information to return a “100 Trying” response.  Of course, unless I am in a lab environment, I never use SIP in a point-to-point fashion.  Here at work, there are all sorts of SIP components between my soft-phone and the soft-phone I am calling.  There is a Session Manager, Communication Manager, and perhaps a Session Border Controller between us.  Thankfully, via headers are not reserved for endpoints.  Every SIP entity uses them.

The rules for processing Via headers are very simple.  Every UAC must add its own Via header before sending a SIP request.  If there is already a Via header in the message, the UAC adds the new one at the top of the list before sending it to the next hop.

Remember that INVITE I sent in my example?  When it ends up on the called party’s device, it might contain several Via headers.  When the called party is ready to send the “100 Trying,” it simply removes the top Via header and sends the response to the indicated party.  In my work configuration, that top Via would most likely identify a Session Manager.  However, if the soft client was a remote user, it would be my company’s SBC.  It doesn’t matter, though.  Whoever receives the response will remove the top Via header and send it to the next hop.  This keeps happening until the Trying message lands on my PC.

This Via stacking allows a SIP request to pass through any number of intermediaries and every recipient of that message will know exactly how to pass back any subsequent responses.

Ah, but there’s more

To keep things simple I failed to mention something important about Via headers.  Along with the protocol and IP information, every Via header contains a “branch” parameter.  Here is that Via again with a branch parameter I pulled from a Wireshark trace.

```
Via: SIP/2.0/UDP 10.11.228.67:5060; branch=z9hG4bK10_16a83292baa1de54e0b7843_I
```

The branch parameter must be unique across space and time for all requests sent by a user agent.  The exceptions to this rule are CANCEL and ACK for non-2xx responses.  A CANCEL will have the same branch parameter as the request it cancels.  An ACK for a non-2xx response will have the same branch parameter as the INVITE whose response it acknowledges.

The uniqueness of the branch header is used to facilitate its use as a transaction ID.  A SIP transaction is a message exchange between two user agents that starts with a request and ends with a final response.  For a simple call, the INVITE through final response is one transaction, the ACK is another transaction, and the Bye through the 200 OK is yet another transaction.  All these transactions combine to make a single dialog.

If you crave more knowledge about SIP message uniqueness, please see my blog, Let’s Play (SIP) Tag.

The branch parameter always begins with the same string of seven characters — “z9hG4bK.”  This requirement was added to identify that the branch was created in accordance with RFC 3261 and not the older RFC 2543 which did not require global uniqueness

## [Contact and Record-Route headers](https://kb.smartvox.co.uk/opensips/contact-and-record-route-headers-explained/)

### Some Acronyms and terminology
* UAC : User Agent Client (for example, a VoIP handset)
* UAS : User Agent Server (for example, an IP-PBX such as Asterisk)
* SIP Proxy : A server that operates as an intermediate node between the UAC and the UAS
* URI : Uniform Resource Identifier. Typical format “sip:<username>@<domain>”
* Sequential Request : A SIP request that is part of an already established dialogue. It will have a “to-tag”. Sequential requests follow after the initial request that established the dialogue

The <domain> element is often shown as <host>, possibly to show it can be a domain or an IP address. It may also have a port number appended (after a colon separator). e.g. sip:12345@192.168.20.123:5144

If you want to dig deeper into the terminology used to identify sub-components of the URI and see how it fits together with parameters in the context of a SIP header

## Contact and Record-Route headers explained
* [link](https://kb.smartvox.co.uk/opensips/contact-and-record-route-headers-explained/)

Diagnosing some problems in the world of VoIP requires close inspection of the SIP messages being exchanged, but there are many occasions where a good understanding of loose routing will be invaluable. The headers that underpin loose routing are Contact, Record-Route and Route. In this post, I explain how they work and provide some insight into the way they interact.

### Some Acronyms and terminology
UAC : User Agent Client (for example, a VoIP handset)

UAS : User Agent Server (for example, an IP-PBX such as Asterisk)

SIP Proxy : A server that operates as an intermediate node between the UAC and the UAS

URI * : Uniform Resource Identifier. Typical format “sip:<username>@<domain>”

Sequential Request : A SIP request that is part of an already established dialogue. It will have a “to-tag”. Sequential requests follow after the initial request that established the dialogue.

\* The <domain> element is often shown as <host>, possibly to show it can be a domain or an IP address. It may also have a port number appended (after a colon separator). e.g. sip:12345@192.168.20.123:5144

If you want to dig deeper into the terminology used to identify sub-components of the URI and see how it fits together with parameters in the context of a SIP header, then you may find this article interesting.

### What is the function of the Contact header?
Contact headers contain a URI which should be used by other nodes and devices communicating with it (within the same dialogue) when they want to send it a SIP request. A Contact header is normally found in all SIP requests and is often found in SIP responses too. Its role is best illustrated by looking at examples.

Beginning with the simplest possible case: Two endpoints; one initiates a dialogue by sending a SIP request (e.g. INVITE) to the other. The Contact header is inserted into the SIP request by the device initiating the dialogue (the UAC). It is received by the downstream endpoint (the UAS), which must store the Contact address URI in case it needs to use it later in the dialogue.

![](https://kb.smartvox.co.uk/wp-content/uploads/Contact-header-simple-downstream.jpg)

Remember that the routing of SIP responses – such as “180 Ringing” or “200 OK” – is determined by the Via headers. The Contact header is used by downstream endpoints when they need to send SIP requests back upstream. However, it is equally valid for an upstream endpoint to use the URI from the downstream device’s Contact header in sequential requests, once it has received it.

![](https://kb.smartvox.co.uk/wp-content/uploads/Contact-header-simple-upstream.jpg)

When might we expect to see an endpoint send a request upstream as shown above? An obvious example is a BYE request. If the called party hangs up first, a BYE request would be sent upstream to the caller’s device to tell it that call has ended. The Contact header supplied during the call setup phase tells the called device how to address the calling device in such a situation.

It is important to note that the Contact header defines a URI, not just an IP address and port. It is usual for the calling device to expect the Request-URI (R-URI) in an upstream request to use the same <username> element that it wrote in the original Contact header URI. However, many devices will be tolerant and accept a request where the domain of the URI has changed. This is important because it allows intermediate proxies to fix the Contact address when the UAC device is behind NAT (discussed in detail here). The Contact header may also include parameters and you would expect these to be copied to the R-URI on an upstream request. Here is an example of a Contact header from a device behind NAT which also includes two parameters:

```
Contact: "John Quick" <sip:1005@192.168.0.81:2048;line=n01ly175;transport=tcp>
```

### Introducing the Record-Route header
The above diagrams and example illustrate the core principles using a highly simplified case, but unfortunately it doesn’t bear much resemblance to the real world because, other than LAN-based extensions on a PBX, it is quite unusual for two endpoints to communicate directly with each other. To make it more realistic, we need to at least include a Proxy server or SBC in the communication path between the calling and the called devices.

The standard solution used by SIP Proxy servers involves adding another header, a Record-Route header, to identify itself as an intermediate node.

![](https://kb.smartvox.co.uk/wp-content/uploads/Contact-header-with-Proxy-downstream.jpg)

Record-Route headers are reborn as Route headers when a request is sent upstream. More on this later, but first I must point out a pertinent side-issue before moving on. It is that the SIP standards describe two different techniques that Record-Route headers (and their counter-part Route headers) can use:

1. strict routing
2. loose routing

Within my blog posts/wiki articles, including this one, I only discuss loose routing. If you want to know about strict routing, please find information from other online resources. I’m sure a Google search will find plenty of material on this topic. So please just accept that in all my wiki articles, loose routing is assumed. Now, let’s get back to the main topic of this post.

### How Record-Route headers are used
At this point, I am going to deliberately increase the complexity of the situation because it helps to illustrate how Record-Route headers operate in practice. What happens when there is more than one Proxy server?

![](https://kb.smartvox.co.uk/wp-content/uploads/Proxy-Chain-and-RR-headers_1.jpg)

Each Proxy in the chain adds a new Record-Route header containing its own address. It always adds it above any existing RR headers – the order is important. In the example above, when the SIP request arrives at the UAS, it contains three RR headers. The whole set of RR headers describes the path through all intermediate nodes. Combined with the Contact header, this provides a complete description of the upstream path that leads back to the calling device.

The UAS has a complete description of the path back to the UAC, but at this point the UAC doesn’t have any knowledge of the path, the intermediate nodes or even the address of the UAS. It needs to know the path too, for example when it wants to send more requests to the UAS within the current dialogue. So how can this information be exchanged? The answer is fairly simple – the UAS includes a complete copy of all the Record-Route headers in its response. It also includes its own Contact header in the response. The path that the response follows is defined by the Via headers – the RR headers are present in the response but do not influence its transmission path.

![](https://kb.smartvox.co.uk/wp-content/uploads/Proxy-Chain-and-RR-headers_2.jpg)


So now, both the UAC and the UAS have a copy of the full set of Record-Route headers. This is essential for loose routing to work and it happens at the start of the dialogue. Here is an edited example of a real-world SIP INVITE request containing two Record-Route headers:

```
INVITE sip:1009@92.153.251.246:5060 SIP/2.0
Record-Route: <sip:82.0.128.19:5060;lr>
Record-Route: <sip:89.200.14.123:5060;lr;MPXON=Y>
Via: SIP/2.0/UDP 82.0.128.19:5060;branch=z9hG4bKf01e.56789d1.0
Via: SIP/2.0/UDP 89.200.14.123:5060;branch=z9hG4bKf01e.f9f91e21.0
Via: SIP/2.0/UDP 192.168.24.12:5144;received=86.4.139.77;branch=z9hG4bK161987113;rport=4454
From: “John Quick” <sip:1001@svr2.smartvox.co.uk:5061>;tag=2014274981
To: <sip:1009@svr2.smartvox.co.uk:5060>
Call-ID: 115377082-5144-3@BJC.BGI.A.BC
CSeq: 21 INVITE
Contact: “John Quick” <sip:1001@86.4.139.77:4454>
```

Note how the Record-Route headers all include the parameter “lr”. This is very important – it shows that loose routing is to be used. One of the RR headers also has a custom parameter “MPXON=Y” which was used to show that a media proxy was active. You would expect to see exactly the same two Record-Route headers in the “200 OK” response when the call is answered.

Once the “Route Set” has been established, it is remembered by both end points. Once the dialogue is established, the proxies should not insert any more Record-Route headers after that initial transaction. Instead, all the sequential SIP requests should contain Route headers.

### Introducing Route headers
In a sequential request, the Route Set is used to create a set of Route headers. The sequence of these headers is important – the upstream server will invert the order, but a downstream server does not. The next diagram is a representation of a downstream sequential SIP request using loose routing:

![](https://kb.smartvox.co.uk/wp-content/uploads/Proxy-Chain-and-Route-headers_1.jpg)

…and this is the equivalent diagram for an upstream request:

![](https://kb.smartvox.co.uk/wp-content/uploads/Proxy-Chain-and-Route-headers_2.jpg)

A quick explanation of the loose routing mechanism
The path for the request is determined by the embedded Route headers. When they receive a loose routed request, the intermediate nodes (Proxies) should find their own address in the topmost Route header. It is their responsibility to then strip off this topmost Route header and check if there are any more. If there are more Route headers, the next one is then used to determine the address of the next node in the path. This process is repeated until the last-but-one node is reached. At this point, all Route headers have been used and the final hop uses the Request-URI for routing.

### Some variations you may encounter
#### Double RR headers
When a Proxy receives a request on one network interface and sends it onwards using a different interface (e.g. WAN to LAN), this will normally require the addition of an extra Record-Route header. i.e. the Proxy must add two RR headers where you might normally expect it to add one. The same happens when a Proxy transcodes from one transport protocol to another – for example, if it receives a WebRTC request and forwards it as TCP. In cases where it adds two Record-Route headers, it should also add a parameter “;r2=on”. Here is an example:

```
Record-Route: sip:192.168.10.11:5060;transport=tcp;lr;r2=on;did2=09c.7ab64763>
Record-Route: sip:86.4.139.77:5060;transport=tcp;lr;r2=on>

RFC 5658 is the official specification document for using double RR headers in these special situations.
```

### Topology Hiding
The TOPOLOGY_HIDING module of OpenSIPS, when used, will not use Record-Route and Route headers in the way explained here. Instead, it stores information about upstream and downstream paths in memory and inserts a unique key value into the Contact header that it uses later to recover the required information from memory.

### The “received” parameter
In some situations, you may see a “received” parameter in a Route header. It is used to specify an address that is different to the main address defined in the header. This format may sometimes be used if loose routing is being used to reach a device behind NAT where the Contact URI for the device gives one IP address but the network connection requires the use of a different address – e.g. the Contact URI uses a LAN address and the only way to reach it is through a public IP address on the external port of a NAT router.

### The “alias” parameter, connection re-use and RFC 5923
When the connection to a SIP proxy is made using TCP or TLS, it is possible that the port shown in a Route header will be ignored because the proxy prefers to re-use a pre-existing connection. This behaviour is somewhat tricky to explain in detail and I would refer you to RFC 5923 if you want to understand it. Strictly it should only happen if the “alias” parameter was present in the Via received in an earlier request, but OpenSIPS also has a core function, force_tcp_alias(), that will trigger the same behaviour even if the “alias” parameter was not present.

### Implementation in OpenSIPS
To handle loose routing in OpenSIPS, you must have the TM and RR modules loaded. The RR module provides functions for adding Record-Route headers to an initial request and another function to deal with Route headers in a received sequential request.

OpenSIPS defines a core property for SIP requests called “the destination”. In xlog statements you can print its value using $du. It is distinct from the Request-URI (printed using $ru) and, if present, it takes precedence in determining where a request is relayed when the t_relay() function is called. If no destination is set, the request will be routed according to the R-URI.

The loose-route() function detects if Route headers are present, strips off the topmost header (or the topmost two if “r2=on” is detected), then looks to see if there are any more Route headers. If it finds at least one, the network address defined in the new topmost header is assigned to “the destination” ($du). Your script must still use t_relay() to send the request onwards. The following flow chart (which is highly simplified) shows how a typical OpenSIPS script might process requests using the functions mentioned above:

![](https://kb.smartvox.co.uk/wp-content/uploads/Sequence-for-RR-LR-functions-without-NAT.jpg)



# Kamailio Introduction
Kamailio (formerly OpenSER) is an open source SIP server, but Kamailio is a bit difficult to grasp what “it is“, but once you understand it’s all very logical.

Over this series I’ll attempt to explain what Kamailio is (and isn’t), and through a series of examples, show you how to use Kamailio to build cool stuff.

I’ll try and make it accessible for people with a background / understanding of VoIP, specifically with an understanding of SIP.

There’s a lot of meticulous documentation out there on specific Kamailio modules, but not much I could find that gives an overview of how the platform works, so over this series of Tutorials, I’ll attempt to cover the basics of using Kamailio to solve problems, as together we build a basic PBX with Kamailio, touching upon some of the common modules and core concepts of Kamailio.


## So what is Kamailio ?
Kamailio is a SIP Server.

It’s a bit confusing at the start, because Kamailio isn’t like FreeSWITCH, Asterisk, YATE, an SBC, a PBX or any of other telephony platforms you may have encountered before, because out of the box, Kamailio doesn’t really do anything.

You’ve got to tell Kamailio how to do everything.

Let’s take a SIP INVITE message, used to start a call (aka session) that we might send to a PBX with the domain name biloxi.example.com and a SIP endpoint registered as ‘101’:

INVITE sip:101@biloxi.example.com SIP/2.0
If we sent this message to a generic PBX, the PBX would have the logic to know that it has an extension 101 and the PBX would ring extension 101.

Our generic PBX looks at the Request URI in the INVITE message it received and has the logic predefined to know that 101 is a device it has registered and that we want to connect to that device, so sends the call to the matching device.

If we sent the same INVITE to an Asterisk box, Asterisk would take a look at our SIP INVITE message, and see if there’s an entry in the dialplan under the current context for 101. Asterisk doesn’t assume if you have a user registered on SIP/101 and receive a SIP INVITE to 101 that you want to get to SIP/101, it’d need to be told this through the dialplan.

Kamailio takes this example even further.

If we want to dial 101 on Kamailio and have it ring the device registered on 101, you have to tell Kamailio what to do when it receives an INVITE message in the first place, lookup if that destination is in our AOR (we’ll get to that) table, and then forward the INVITE to the destination if it exists, and forward the provisional responses (1xx) and finally the final response (200 OK) from the remote end back to the originator. Plus we’ve got to think about how we handle a scenario where the destination doesn’t exist, or isn’t registered, of if the destination returns a 4xx response to the INVITE, how we handle provisional responses and CANCEL messages and finally the BYE message (if we’re record routing).

Phew. This seems like a lot to handle.

It all seems pretty daunting at first, calling from one SIP Endpoint to another seems like a pretty rudimentary thing in a telephony product, but by putting how the system thinks, routes and manipulates messages up to you, we open the doors to all the possibilities.

What if you want something to sit in front of your servers and only allow certain SIP User Agents? Or load balance between several soft-switches? Or route least-cost between connected carriers and seamlessly failover if one is lost? Rate limit dodgy traffic before it hits your environment? Manage hundreds of thousands of registrations?

Kamailio can do all of that.

Kamailio can do anything you can think of (to do with signaling).

And that’s the awesome part of Kamailio. It is, what you define it to be.


## Configuration
We’ll open kamailio.cfg – the text file that contains all our routing info, and get to work.

```
vi /etc/kamailio/kamailio.cfg
```

You’ll see the config starts by defining what modules to load, and the config for each of these modules. For us, the defaults will work for now, let’s get to the juicy bits. Keep moving down the config file until you hit this section:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
```
The request_route section is what handles the initial SIP message that comes through.

We’ll remove all the text after request_route { leaving us with a blank canvas in terms of how we handle messages. We’ll then put in a single line to log to syslog when we get a SIP message:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        xlog("I got a message");
}
```

If we were to stop here and restart Kamailio, when a SIP message comes into our SIP server, we’d just write an entry to syslog saying “I got a message” each time we get a SIP message, but Kamailio won’t respond to the received SIP message, it’ll just enter a log entry each time it gets a SIP message. So let’s respond to any SIP message we get with a 501 “Not Implemented” message.

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        xlog("I got a message");
        sl_reply("501", "Not Implemented");
}
```

So let’s break down the two functions we just used.

## xlog("");
xlog is your friend.
Put simply xlog prints whatever you put inside the parenthesis to syslog.
You can use it to check to see if your messages are getting to the part of the config you want, check what pseudovariables are doing and many other things, but I’m getting ahead of myself. For now you just need to know xlog is like NoOp() in Asterisk, print() in Python, etc.

## sl_reply();
sl_reply is stateless reply.
It takes two parameters, the SIP Response Code and the text to go with it, when called it sends the SIP response code and text back to the requester.
In this case we’re using SIP Response Code 501, which translates to Not Implemented, meaning the server does not support the functionality required to fulfill the request aka:

## What is PBX (Private Brand Exchange)?
PBX stands for Private Branch Exchange. Think of it as an internal telephone network of a business or other entity. PBX phone system users can communicate with one another over the phone via internal lines, and make and receive external calls as well. A PBX phone system usually delivers business telephony features such as call forwarding, call transfer, call queue, auto-attendant, voicemail, etc.

PBX systems operate by using either VoIP (Voice Over Internet Protocol) or via analog or digital phone lines. With a PBX phone system, the physical phone line coming into your business can be split into multiple lines, allowing you to support more telephones. Better yet, calls between users are free

![](https://getvoip.com/uploads/VoIP-vs-PBX-e1662681663590.png)

## General Rules
Some rules of thumb to get you started with writing Kamailio configs:

* All lines that do things (instructions) have to end with a semicolon
* Comments start with # if single line or /* blah */ for multi-line
* Changes to the config only take effect when you restart Kamailio
* With what we have setup restarting Kamailio causes it to forget all about your active Registrations (Even though your devices might say they’re still registered) (For now, although we can change this behaviour)

Now we’ve got that out of the way let’s continue on from our last tutorial and start routing requests!

(We’ll skip all the config above the request_route{} block that configures the modules and their setup, it’s all very important, but we’ll touch upon that in a later tutorial I promise)

As I touched upon in the Introduction post, you define what Kamailio is and does in terms of routing SIP requests, so let’s jump straight in and get started on the blocks that take care of this.

## The request_route{} Block
The request_route{} block is where all our incoming SIP requests start off. Replies / responses are handled a bit differently (more on that later), but essentially every new SIP request / message / dialog starts off here.

We can create new blocks other than request_route{} to help keep our code clean, in the same way we might define functions while programming.

```
Let’s take a look:

request_route {
        route(RESPOND_501);    #Jump to the RESPOND_501 block
}

route[RESPOND_501]{
        sl_reply("501", "Not Implemented");   #Send 501 reply
}
```

We can see in the above example, any SIP Request coming in will enter our request_route{},

In our request_route{} block we only have one instruction, which is route().

The route() command allows us to then specify another block of the config file / code to continue on from. Think of it kind of like calling a function or god forbid – a GoTo. So in this example the call comes in and then routed off to a new routing block called route[RESPOND_501],

This allows us to reuse bits of code multiple times and generally keep everything a lot cleaner.

It’s worth noting that unless you tell it to, routing to another block won’t stop Kamailio from continuing to execute it’s way through the code, it’ll do what it’s told in the other routing block and then finish what it started.

Let’s look at an example:

```
request_route {
        xlog("Hello, I am in the request_route");
        route(RESPOND_501);    #Jump to the RESPOND_501 block
        xlog("Back in request_route");
}

route[RESPOND_501]{
        xlog("Now I am in the respond 501 route");
        sl_reply("501", "Not Implemented");   #Send 501 reply
}
```

If we’re to run this code and send a SIP Request to it, we’d see each of these xlog entries in your syslog,

* As the message firsts hits the xlog(“Hello, I am in the request_route”);, then is routed off to route[RESPOND_501]
* In route[RESPOND_501] we’ll see the xlog(Now I am in the respond 501 route”); – Kamailio has now executed the route[RESPOND_501] block and resumes from where it was in request_route{}

When we get back to request_route we get the final xlog(“Back in request_route”);.
We can stop routing in a specific block using the exit; command which stops processing that request once hit. For example:

```
request_route {
        xlog("Hello, I am in the request_route");
        route(RESPOND_501);    #Jump to the RESPOND_501 block
        xlog("Back in request_route");
}

route[RESPOND_501]{
        xlog(Now I am in the respond 501 route");
        sl_reply("501", "Not Implemented");   #Send 501 reply
        exit;
}
```

Because of the exit we added in the route[RESPOND_501] Kamailio stops executing at that point, so we don’t continue passing through the config file and this time we won’t get the final xlog(“Back in request_route”); call

## Basic Message Routing
Let’s take a very basic use case, and write some code in the request_route{} block.

We’ll set it up so if we receive an INVITE request, we’re going to respond with a 480 Temporarily Unavailable message, and for everything else, we’ll respond with 501 “Not Implemented”.

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

So let’s break this down,
First we have a an if statement – If the method of the SIP message is an INVITE request, then execute the code inside the curly brackets.

Inside the curly brackets we’ll respond with 480 Temporarily Unavailable, using sl_reply() (You may remember from the last post that sl_reply sends a reply back to the sender of the message with the response code and text specified) and then exit, meaning we won’t continue executing what’s next in the config.

Finally outside of our if statement (so catching any SIP requests who’s method isn’t INVITE) we’ll respond with 501 “Not Implemented”.

Here we can see our REGISTER message got back a 501 Not Implemented response, while our INVITE got a 480 Temporarily Unavailable response.

## SIP Registrar
As we talked about in the post on SIP Registrars, SIP Registrars take the REGISTER requests from SIP endpoints and store their contact details in the form of an Address on Record (AoR). This AoR contains the URI and the endpoints’ current IP it just sent the REGISTER message from.

The primary use of this is it allow us to know how to reach people. It’s kind of like an address book for mapping current IP against a SIP URI, as IP Addresses of SIP endpoints may change often.

So our Kamailio instance is going to receive an REGISTER message, store the Contact as an address on record, and respond 200 OK. Let’s build upon the config we started with in the last tutorial:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

So let’s add an if statement to manage REGISTER messages, and save their location:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        if(method=="REGISTER"){
                save("location");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```
So we’ve added an IF statement to find if the SIP method is a REGISTER message, and if it is, we’ll call the save(“location”); function.

The save() function saves the Contact address we just received to a database (in this case one in memory) in the form of a SIP URI and current Contact location, these two bits of info combined are known as an address on record (AoR) and the save function, if successful, responds with a 200 OK automatically.

So that’s it – Our SIP endpoint is happy and by calling the save(“location”) we’ve called the built in function to store the Contact as an Address on Record and respond with 200 OK.

So how do we access this information and what can we do with it?

Kamailio comes with two tools for accessing Kamailio while it’s running. In this example we’ll use kamcmd to check what’s registered on our system. After we’ve seen a device register, from command line we’ll run:

```
kamcmd ul.dump
```

This calls kamcmd the Kamailio command line tool, and calls the ul.dump function. ul is short for userloc – The module for user location management, and dump outputs all the contents of the userloc table.

![](https://nickvsnetworking.com/wp-content/uploads/2018/12/image-12.png)

## First Call
So now we’ve got Kamailio handling REGISTER traffic, and we know what IPs endpoints are on, so let’s join this together and let’s route a call between two endpoints via our Proxy!

We’ll work on the config we were working on in the previous tutorial:

```
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
        if(method=="INVITE"){
                sl_reply("480", "Temporarily Unavailable");
                exit;
        }
        if(method=="REGISTER"){
                save("location");
                exit;
        }
        sl_reply("501", "Not Implemented");
}
```

Let’s change how we handle the INVITE messages in our if(method==”INVITE”) block so instead of responding with a 480 Unavailable response, let’s lookup the location we saved if it was a REGISTER and forward the INVITE to the IP we’ve got.
```
if(method=="INVITE"){
        lookup("location");
        t_relay();
        exit();
}
```

Let’s break down each of the new functions we’ve introduced:


### lookup(“location”);
In the last post we introduced save(“location”); which saves an Address on Record for the URI. lookup(“location”); looks up the IP address of the URI we’re after in the Address on Record table we wrote to with our save(“location”); call and automatically sets it as the destination IP of where we’re going to send the message.

When a user registered via a SIP REGISTER request, we saved their details, now we’re looking them up.

You could even replace the lookup(“location”) call with say a SQL lookup on an address book, and save the output to the IP the INVITE will be forwarded to, but lookup(“location”); does this it all in one function.

### t_relay();
t_relay is transactional relay function. By transactional it means Kamailio remembers this session next time it’s referenced, we’ll touch upon transaction aware / stateful SIP proxies later, but for now what you need to know is it forwards the INVITE we just received to the address we got from our lookup(“location”).

### exit();
Exit bails out so we won’t keep processing after that, it doesn’t just bail out of our current conditional but stops processing this request further. Without it we’d still go on and send the 501 Not Implemented reply.

## **SIP Basics**:
   - SIP is a protocol used for initiating, maintaining, modifying, and terminating real-time communication sessions over IP networks. It's widely used for voice and video calls, instant messaging, and other multimedia applications.
   - SIP operates through a series of **methods** (requests) and corresponding **responses**.

## **SIP Methods**:
   - SIP requests are sent by the **User Agent Client (UAC)** to establish and manage sessions.
   - The first six basic SIP request methods are:
     - **INVITE**: Initiates a session (e.g., when you make a call).
     - **ACK**: Confirms an INVITE request.
     - **BYE**: Ends a session (hangs up the call).
     - **CANCEL**: Cancels the establishment of a session.
     - **REGISTER**: Communicates user location (host name, IP).
     - **OPTIONS**: Provides information about the capabilities of the calling and receiving SIP devices.

## **The "Trying" Response**:
   - When you initiate a call (send an INVITE request), the **User Agent Server (UAS)** receives it.
   - The UAS responds with a **provisional response** called **"100 Trying"**.
   - This response indicates that the call setup process is underway. It doesn't confirm success or failure; it's simply an acknowledgment that the request is being processed.
   - After the "100 Trying," the UAS may send a final response (e.g., "200 OK" for a successful call setup).

## **Example Scenario**:
   - Imagine you're calling a friend. Here's how it works:
     - You (UAC) send an INVITE to your friend (UAS).
     - Your friend's device responds with "100 Trying" to let you know they're processing the call.
     - If your friend accepts the call, they'll send a final "200 OK" response, and the call is established.


Kamailio allows you to deal with all these problems yourself, writing your own routing blocks, but it also comes with a bunch of useful routing blocks in the [example config](https://github.com/kamailio/kamailio/blob/master/etc/kamailio.cfg), that we can re-use so we don’t need to specify how to manage every little thing ourselves – unless we want to.

So lets add some of these useful routing blocks,

We’ll add this at the start of our request_route{ block
```
request_route {

        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }


        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }

        # handle requests within SIP dialogs
        route(WITHINDLG);
}
```

So now our config looks like this:

```
request_route {
        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }


        if (!is_method("ACK")) {
                if(t_precheck_trans()) {
                        t_check_trans();
                        exit;
                }
                t_check_trans();
        }

        # handle requests within SIP dialogs
        route(WITHINDLG);


        if(method=="INVITE"){
            if(!lookup("location")){
                            sl_reply("404", "User not Registered");
                            exit;
            }

            lookup("location");
            t_relay();
            exit();
        }


        if(method=="REGISTER"){
                save("location");
                exit;
        }
        xlog("No idea how to respond to method $rm");
        sl_reply("501", "Not Implemented");
}
```

As you can see we’ve added an if statement to match if the method is CANCEL or ACK, and referenced some routing blocks:

* route(RELAY);
* route(WITHINDLG);

## t_check_trans()
t_check_trans() can be used to quickly check if a message belongs or is related to a transaction. It behaves differently for different types of messages:

* For a SIP Reply it returns true if the reply belongs to an existing transaction and false otherwise.
* For a CANCEL it behaves exactly as t_lookup_cancel(): returns true if a corresponding INVITE transaction exists for the CANCEL and false otherwise.
* For ACKs to negative replies or for ACKs to local transactions it will terminate the script if the ACK belongs to a transaction (it would make very little sense to process an ACK to a negative reply for an existing transaction in some other way then to simply pass it to tm) or return false if not.
* For end-to-end ACKs (ACKs to 2xx responses for forwarded INVITE transactions) it will return true if the corresponding INVITE transaction is found and still
active and false if not

## t_precheck_trans()
Check if current processed message is handled by other process. This function is useful to catch retransmissions before transaction is created. The function returns true if the request is handled by another process.

Note that ACK and CANCEL requests are not tracked by this function, the return code being false for them.

This function can be used from REQUEST_ROUTE .

Example 1.15. t_precheck_trans usage
```
...
# handle retransmissions
if(t_precheck_trans()) {
t_check_trans();
exit;
}
t_check_trans();
...
```

## Security in Theory
In this series we’ll ultimately end up with a basic PBX with the ability to make and receive calls between registered users and via trunks from a carrier.

Soon we’ll add the ability to call numbers not registered on our system (trunks) to our system, but now is a good time to talk about securing your system, as the threat of toll fraud is very real, as well as calls from random devices waking you up in the middle of the night.

VoIP security is a big topic, there’s a whole lot of wrong ways to do things, so think before you do.

## Authentication, Authorisation and Accounting
Most telephony platforms employ some form of AAA, it’s a good minimum starting point for our system to ensure we Authenticate traffic, to make sure it is who it claims to be, we Authorise traffic to make sure it’s allowed to traverse this part of the network and use theses resources, and finally we’ll Account for resources used, for example recording CDRs and cost for the services used.

## Authentication
Authentication in this example we’ll using the Challenge / Response based authentication for traffic from users (Such as REGISTER and INVITE messages), as [shown in this example](https://tools.ietf.org/html/rfc3665#section-2.1).

When we get an INVITE or a REGISTER from a user, we’ll check their username / password matches what we’ve got on record.

For this we’ll use Kamailio’s [Auth_DB](https://www.kamailio.org/docs/modules/devel/modules/auth_db.html) module.

## Authorization
We’ll use IP Address authorisation for inbound traffic from carriers (so we can make sure that we’ll only allow calls from carriers, not just any IP on the internet sending INVITES).

This means when we get an INVITE from a Carrier to send us an inbound call, we’ll make sure it’s from the Carrier’s IP address before we start our user’s phones ringing.

For this we’ll use Kamailio’s [Permissions](https://www.kamailio.org/docs/modules/devel/modules/permissions.html) module.

## Accounting
We’ll skip Accounting for now as we’re not going to be charging users at this stage.

Kamailio has the [Accounting](https://www.kamailio.org/docs/modules/devel/modules/acc.html) module you can use for this, which we’ll talk about another day.

## Traffic Validation
Now’s probably a good time to talk about validating your traffic in the wild west world that is the internet.

Let’s say we implement a database lookup in Kamailio to take the To part of the Request URI and lookup where to route it, we receive something like:

```
INVITE sip:1234567@example.com
```

So we’ve got that and we lookup 1234567 in our database and get where we need to route it to:

```
SELECT 'forward_destination' FROM 'imaginary_route_database' WHERE 'dialed_number' = '1234567';
```

Seems harmless enough right?

Now imagine someone sends an INVITE that looks like this:

```
INVITE sip:'; DROP TABLE *;@example.com
```

Now let’s look at how our SQL query would look:

```
SELECT 'forward_destination' FROM 'imaginary_route_database' WHERE 'dialed_number' = ''; 
DROP TABLE *; 
'';
```

And suddenly we find all our tables have been deleted.

So it’s important we filter everything, and make sure the traffic is valid.

SQL injection is a fun example, but more common examples could include not checking the Max Forwards header and looping packets out and back in infinitely (imagine no spanning tree and plugging a switch into itself) and not responding to known bad user agents like sipcli and sipvicious.

Luckily again the Kamailio team have covered this before, Kamailio comes with a module for handling a lot of the common threats.

With the boilerplate routes we talked about in the last tutorial all you have to do is add **route(REQINIT);** at the start of your routing block and you’ll get:

* Dodgy UA filtering (You may want to add your own)
* Basics of Flood Prevention (if you want it)
* max_forward checking (for handling routing loops)
* OPTIONS response handling
* Sanity checking

### REQINIT
for more read [link](https://telecom.altanai.com/2018/02/17/kamailio-security/)
```
route[REQINIT] {
	# no connect for sending replies
	set_reply_no_connect();
	# enforce symmetric signaling
	# - send back replies to the source address of request
	force_rport();

        #!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xalert("ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
        #!endif
	if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent|pplsip") {
		# silent drop for scanners - uncomment next line if want to reply
		# sl_send_reply("200", "OK");
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483", "Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200", "Keepalive");
		exit;
	}

	if(!sanity_check("17895", "7")) {
		xlog("Malformed SIP request from $si:$sp\n");
		exit;
	}
}

```

### set_forward_no_connect
The message will be forwarded only if there is already an existing connection to the destination. It applies only to connection oriented protocols like TCP and TLS (TODO: SCTP), for UDP it will be ignored. The behavior depends in which route block the function is called:

* normal request route: affects stateless forwards and tm. For tm it affects all the branches and the possible retransmissions (in fact there are no retransmission for TCP/TLS).

* it applies specifically to connection-oriented protocols like TCP and TLS (and potentially SCTP, although that’s still a TODO).
Here’s what it means:
  * Imagine you have a message (like a SIP request) that you want to forward to a destination (another server or client).
  * With set_forward_no_connect, the message will be forwarded only if there is already an existing connection to   that destination.
  * In other words, if there’s no active connection, the message won’t be forwarded.
  * However, for UDP, this setting is ignored because UDP is connectionless.

So, think of it like this: set_forward_no_connect ensures that the message takes the existing “road” (connection) to reach its destination

set_forward_no_connect in a straightforward way:
* What Is It?
  * Imagine you’re sending a letter (a SIP message) to a friend (a destination).
  * Now, your friend lives in a house (server or client).
  * The set_forward_no_connect setting is like saying, “Hey, if there’s already a road (connection) to your friend’s house, use it to deliver the letter.”
  * But if there’s no road (no existing connection), the letter won’t be forwarded.
  * This concept applies mainly to protocols like TCP (think of it as a reliable road) and TLS (a secure road).
  * When you forward a message using set_forward_no_connect, Kamailio checks if there’s an active connection to the destination


### set_reply_no_connect
Like set_forward_no_connect(), but for replies to the current message (local generated replies and replies forwarded by tm). The behavior depends in which route block the function is called:

* normal request route: affects all replies sent back on the transaction (either local or forwarded) and all local stateless replies (sl_reply()).

* For replies coming from local users , usually behind NAT , do not open a new TCP connection on each reply

* onreply_route: affects the current reply (so the send_flags set in the onreply_route will be used if the reply for which they were set is the winning final reply or it's a provisional reply that is forwarded)


### onreply_route
The `onreply_route` in Kamailio (formerly known as OpenSER) is a powerful feature that allows you to handle SIP replies within the context of an active transaction. Let me break it down for you:

1. **What Is `onreply_route`?**
   - The `onreply_route` is a SIP reply routing block executed by the Transaction Module (TM) in Kamailio.
   - It contains a set of actions to be taken for SIP replies.
   - The main `onreply_route` is executed for **all** replies received.
   - Certain `onreply_route` blocks can be executed by the TM module for special replies.

2. **How Does It Work?**
   - When a SIP request generates a reply, Kamailio checks if there's an `onreply_route` associated with that request.
   - If armed for the specific SIP request, the `onreply_route` processes the reply.
   - You can use `t_on_reply("onreply_route_index")` to arm the `onreply_route` for specific requests.

3. **Example Usage:**
   - Suppose you want to handle replies from a specific IP address (e.g., 192.168.1.110) back to the originator.
   - You can add an `onreply_route` block to handle these replies.
   - Here's a simplified example:
     ```kamailio
     onreply_route {
         # Your custom logic here to handle the reply
         # For instance, logging or modifying the reply
     }
     ```

4. **Additional Notes:**
   - The `onreply_route` is a powerful tool for customizing how Kamailio processes SIP replies.
   - You can use it to implement features like logging, modifying headers, or triggering specific actions based on reply content.

For more detailed information, you can refer to the official Kamailio documentation on the [Core Cookbook](https://www.kamailio.org/dokuwiki/doku.php/core-cookbook:3.0.x) or explore other resources like [Kamailio Bytes](https://nickvsnetworking.com/kamailio-bytes-onreply-route/).


### force_rport
Force_rport() adds the rport parameter to the first Via header of the received message. Thus, Kamailio will add the received port to the top most Via header in the SIP message, even if the client does not indicate support for rport. This enables subsequent SIP messages to return to the proper port later on in a SIP transaction.

This is useful for NAT traversal, to enforce symmetric response signaling.

The rport parameter is defined in RFC 3581.

Note: there is also a force_rport parameter which changes the gobal behavior of the SIP proxy.

Example of usage:
```
force_rport();
```

### add_rport
Alias for force_rport();

----------------------

#### Record-Route
The Record-Route header is inserted into requests by proxies that wanted to be in the path of subsequent requests for the same call-id. It is then used by the user agent to route subsequent requests.

#### Via
Via headers are inserted by servers into requests to detect loops and to help responses to find their way back to the client. This is helpful for only responses to reach their destination.

## SIP Route Headers
The Record-Route and Via headers are fundamental components of the Session Initiation Protocol (SIP), which is a signalling protocol used for initiating, managing, and terminating real-time sessions that involve video, voice, messaging, and other communications applications across IP networks. Both headers play critical roles in SIP's operation, ensuring proper routing of requests and responses between SIP entities. Their development and use are closely tied to the history and evolution of SIP itself.


### Via Header
The Via header is used to track the path of request messages as they traverse through the network of SIP servers to reach the intended recipient. It also provides a route for the responses to follow back to the originator. Each SIP proxy or server that forwards a request adds its address to the top of the Via header list. When the response is generated, it travels back through the list of Via headers, ensuring it follows the same path back to the originator.

 
The Via header has been part of SIP since its inception. SIP was developed by the Internet Engineering Task Force (IETF) and first standardised in RFC 2543 in 1999. The Via header was designed to solve the problem of response routing in IP networks, where requests could traverse multiple nodes, and responses needed a way to navigate back through the same nodes.

### Record-Route Header
The Record-Route header is used by SIP proxies to ensure that the signalling for subsequent SIP messages (such as mid-dialog requests) follows the same path as the initial request. When a SIP proxy wants to stay in the path of future requests in a dialog, it adds a Record-Route header to the initial INVITE request. This ensures that all subsequent messages within the same dialog traverse through the recorded route, enabling features like billing, call recording, or session management to be applied consistently.

Like the Via header, the Record-Route header has been a part of SIP since its early days. It was introduced to address the need for maintaining the signalling path for the duration of a SIP session, especially in complex scenarios involving multiple proxies and network elements. The concept of recording the route was crucial for deploying SIP in real-world networks, where the control over media and signalling paths needed to be maintained for the functionality and security of communication sessions.

Both headers reflect SIP's flexibility and its ability to navigate the complexities of IP network architectures. Over the years, SIP has evolved through various RFCs (Request for Comments), with significant updates including RFC 3261 in 2002, which solidified many of the protocol's core operations, including the behaviours of the Via and Record-Route headers. These headers ensure that SIP can operate effectively over the diverse and distributed nature of the Internet, supporting the reliable delivery and routing of communication sessions across multiple hops and domains.

### Introduction
When managing SIP (Session Initiation Protocol) communications, ensuring seamless call setup and media flow is crucial for both service providers and their customers. A common issue encountered during SIP transactions is the failure of ACK messages to reach the end device, confirming the final response to the initial SIP INVITE. This can prevent the establishment of media sessions, leading to call setup failures and, ultimately, calls being dropped with a SIP BYE message and the reason as "media_timeout." In this article, we'll delve into the intricacies of the Route headers in inbound calls and explain why omitting these headers in a 200 OK response can cause such problems.

### The Role of Route Headers in SIP Communications
SIP utilises various headers to facilitate communication sessions between endpoints. Among these, Route headers play a pivotal role in defining the path that SIP messages should follow through the network. When an INVITE request is made to initiate a call, it traverses through proxies and other network elements before reaching the intended recipient. The Route headers ensure that subsequent messages, including the critical ACK response, follow the same path back to the originator, navigating through the network's topology correctly.

 
### The Consequence of Omitting Route Headers in 200 OK Responses
When a callee sends a 200 OK response to accept an INVITE request, this response should include Route headers that mirror the path taken by the initial INVITE. This inclusion ensures that the ACK message, which confirms receipt of the 200 OK, is routed back through the same network elements, reaching the callee and signalling that the session can proceed with media exchange.

If the 200 OK omits these Route headers, the network may not have the necessary information to route the ACK back to the callee correctly. As a result, even though the call appears to be established from the perspective of the initiating party (such as Telnyx), the lack of ACK receipt at the callee's end means the session cannot transition to media exchange. Consequently, without media flow, the call is eventually terminated with a "media_timeout" hang-up cause after a predefined period, typically 5 minutes.

 
### SIP Record Route Example
To provide a clear understanding, let's illustrate two examples based on the provided SIP INVITE and 200 OK messages. These examples aim to showcase the issue arising from the omission of Record-Route headers in the 200 OK response and how their inclusion ensures successful SIP call establishment.

 
### Example 1: Problematic Scenario Without Record-Route Headers

#### Telnyx SIP INVITE to Customer
```
INVITE sip:+12345678901@sip.example.com:5060 SIP/2.0 
Record-Route: <sip:192.76.120.10;r2=on;lr;ftag=BUXDty7v06tXH> 
Record-Route: <sip:10.255.0.1;r2=on;lr;ftag=BUXDty7v06tXH> 
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0 
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp
Max-Forwards: 60 
From: "+19876543210" <sip:+19876543210@sip.telnyx.com>;tag=BUXDty7v06tXH To: <sip:+12345678901@sip.example.com:5060> 
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE 
Content-Type: application/sdp 
...
```

#### Customer's 200 OK Response (Without Record-Route Headers)
```
SIP/2.0 200 OK 
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0 
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp 
To: sip:+12345678901@sip.example.com:5060;tag=8b240ac5236e0c71 
From: sip:+19876543210@sip.telnyx.com;tag=BUXDty7v06tXH 
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE 
Contact: <sip:+12345678901@another.example.com:5060> 
Content-Type: application/sdp 
...
```

Without the Record-Route headers in the 200 OK response, the ACK message sent by Telnyx might not follow the intended path, potentially failing to reach the customer's system. This misrouting can prevent the call from being fully established, leading to issues such as calls not connecting or being dropped unexpectedly.

 
### Example 2: Successful Scenario With Record-Route Headers

#### Telnyx SIP INVITE to Customer (Same as Example 1)
```
INVITE sip:+12345678901@sip.example.com:5060 SIP/2.0 
Record-Route: <sip:192.76.120.10;r2=on;lr;ftag=BUXDty7v06tXH> 
Record-Route: <sip:10.255.0.1;r2=on;lr;ftag=BUXDty7v06tXH> 
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0 
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp
Max-Forwards: 60 
From: "+19876543210" <sip:+19876543210@sip.telnyx.com>;tag=BUXDty7v06tXH To: <sip:+12345678901@sip.example.com:5060> 
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE 
Content-Type: application/sdp 
...
```

#### Customer's 200 OK Response (With Record-Route Headers)
```
SIP/2.0 200 OK
Via: SIP/2.0/UDP 192.76.120.10;branch=z9hG4bK2d69.8e8f5f5fb057db25a37e7b57b6da8e73.0
Via: SIP/2.0/UDP 10.13.177.4:6000;received=10.13.177.4;rport=6000;branch=z9hG4bKr588213p7Z0Sp
Record-Route: <sip:192.76.120.10;r2=on;lr;ftag=BUXDty7v06tXH>
Record-Route: <sip:10.255.0.1;r2=on;lr;ftag=BUXDty7v06tXH>
To: sip:+12345678901@sip.example.com:5060;tag=8b240ac5236e0c71
From: sip:+19876543210@sip.telnyx.com;tag=BUXDty7v06tXH
Call-ID: 684d7abc-1234-4567-891a-444dd7a7b77d 
CSeq: 12123802 INVITE
Contact: <sip:+12345678901@another.example.com:5060> 
Content-Type: application/sdp 
...
```

By including the Record-Route headers in the 200 OK response, the customer ensures that the ACK message sent by Telnyx correctly follows the predefined path through any intermediate

* Forward Path (INVITE): For the initial INVITE request, Record-Route headers are added in the order the request passes through each proxy. The first proxy the request encounters adds its Record-Route header first, and so on. This order determines the path that the initial request takes through the network.

* Backward Path (Responses): For responses, such as the 200 OK, SIP messages traverse the proxies in reverse order, following the "Via" headers back to the originator. However, for subsequent requests within the dialog (like ACK and BYE), the order of the Record-Route headers dictates the path. 

The UAC constructs the "Route" header field for these messages based on the Record-Route headers it received in the first final response (e.g., 200 OK). It reverses the order of the Record-Route headers to ensure that subsequent messages follow the path back through the proxies in the correct sequence.

### The rport parameter
When you have a SIP Via: header like
```
Via: SIP/2.0/UDP 95.117.121.206:18050;rport;branch=z9hG4bKabc123
```

the rport parameter means respond to the port from which the request was received

When a server compliant to this specification (which can be a proxy or UAS) receives a
request, it examines the topmost Via header field value.  If this Via header field value
contains an "rport" parameter with no value, it MUST set the value of the parameter to
the source port of the request. This is analogous to the way in which a server will insert
the "received" parameter into the topmost Via header field value. In fact, the server
MUST insert a "received" parameter containing the source IP address that the request
came from, even if it is identical to the value of the "sent-by" component.


#### Consider an example.
A client sends an INVITE which looks like:

```
INVITE sip:user@domain SIP/2.0 Via: SIP/2.0/UDP 10.1.1.1:4540;rport
```

This INVITE is sent with a source port of 4540 and source IP of 10.1.1.1. The request is natted, so that the source IP appears as 68.44.20.1 and the source port as 9988. This is received at a proxy.The proxy forwards the request, but not before appending a value to the rport parameter in the proxied request:

```
INVITE sip:user@domain2 SIP/2.0 Via: SIP/2.0/UDP proxy.domain.com Via: SIP/2.0/UDP 10.1.1.1:4540;received=68.44.20.1;rport=9988
```

This request generates a response, which arrives at the proxy:

```
SIP/2.0 200 OK Via: SIP/2.0/UDP proxy.domain.com Via: SIP/2.0/UDP 10.1.1.1:4540;received=68.44.20.1;rport=9988
```

The proxy strips its top Via, and then examines the next one. It con- tains both a received param, and an rport. The result is that the follow response is sent to IP address 68.44.20.1, port 9988:

```
SIP/2.0 200 OK Via: SIP/2.0/UDP 10.1.1.1:4540;received=68.44.20.1;rport=9988
```

The NAT rewrites the destination address of this packet back to IP 10.1.1.1, port 4540, and is received by the client.

### AntiFlood
```
#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
		if (!pike_check_req()) {
			xalert("ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
			$sht(ipban=>$si) = 1;
			exit;
		}
	}
#!endif
```

#### src_ip
Reference to source IP address of the SIP message.

Example of usage:
```
if(src_ip==127.0.0.1)
{
        log("the message was sent from localhost!\n");
};
```

### myself
This is a reference to the list of local IP addresses, hostnames and aliases that has been set in the Kamailio configuration file. This lists contain the domains served by Kamailio.

The variable can be used to test if the host part of an URI is in the list. The usefulness of this test is to select the messages that has to be processed locally or has to be forwarded to another server.

See “alias” to add hostnames,IP addresses and aliases to the list.

Example of usage:
```
if(uri==myself) {
        log("the request is for local processing\n");
};
```

### alias
Parameter to set alias hostnames for the server. It can be set many times, each value being added in a list to match the hostname when 'myself' is checked.

It is necessary to include the port (the port value used in the “port=” or “listen=” defintions) in the alias definition otherwise the loose_route() function will not work as expected for local forwards. Even if you do not use 'myself' explicitly (for example if you use the domain module), it is often necessary to set the alias as these aliases are used by the loose_routing function and might be needed to handle requests with pre-loaded route set correctly.

Example of usage:
```
    alias=other.domain.com:5060
    alias=another.domain.com:5060
```

### $si - Source IP address
$si - reference to IP source address of the message

### $sht(htable=>key)
Access hash table entries.

It is R/W variable, you can assign values to it directly in configuration file. Hash table entry can be deleted by assigning value $null to it.

The “htname” must be a hash table name defined via “htable” parameter.

The “key” can be:

* static string - set of characters without pseudo-variables
* dynamic string - set of characters that include pseudo-variables. The pseudo-variables will be evaluated at runtime.
```
...
modparam("htable", "htable", "a=>size=4;")
...
$sht(a=>$au) = 1;
$sht(a=>$ru) = $fu;
...
```

### pike_check_req()
Process the source IP of the current request and return false if the IP was exceeding the blocking limit.

Return codes:
* 1 (true) - IP is not to be blocked or internal error occurred.

Warning
IMPORTANT: in case of internal error, the function returns true to avoid reporting the current processed IP as blocked.
* -1 (false) - IP is source of flooding, previously detected
* -2 (false) - IP is detected as a new source of flooding - first time detection

This function can be used from REQUEST_ROUTE|ONREPLY_ROUTE.

Example 1.5. pike_check_req usage
```
...
if (!pike_check_req()) { exit; };
...
```

### sampling_time_unit (integer)
Time period in seconds used for sampling (or the sampling accuracy). The smaller the better, but slower. If you want to detect peeks, use a small one. To limit the access (like total number of requests on a long period of time) to a proxy resource (a gateway for example), use a bigger value of this parameter.

IMPORTANT: a too small value may lead to performance penalties due to timer process overloading.

Default value is “2”.

Example 1.1. Set sampling_time_unit parameter
```
...
modparam("pike", "sampling_time_unit", 10)
...
```

### reqs_density_per_unit (integer)
How many requests should be allowed per sampling_time_unit before blocking all the incoming request from that IP. Practically, the blocking limit is between ( let's have x=reqs_density_per_unit) x and 3*x for IPv4 addresses and between x and 8*x for IPv6 addresses.

Default value is 30.

Example 1.2. Set reqs_density_per_unit parameter
```
...
modparam("pike", "reqs_density_per_unit", 30)
...
```

### remove_latency (integer)
Specifies for how long the IP address will be kept in memory after the last request from that IP address. It's a sort of timeout value, in seconds. Note that it is not the duration to keep the IP in state 'blocked'. An IP is unblocked next occurrence of 'sampling_time_unit' that does not exceed 'reqs_density_per_unit'. Keeping an IP in memory results in faster reaching of blocked state -- see the notes about the limits of getting to state 'blocked'.

Default value is 120.

Example 1.3. Set remove_latency parameter
```
...
modparam("pike", "remove_latency", 130)
...
```

### Scanner
```
if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent|pplsip") {
        # silent drop for scanners - uncomment next line if want to reply
        # sl_send_reply("200", "OK");
        exit;
}
```

### $ua - User agent header
$ua - reference to user agent header field

### Operators
The logical operators that can be used in 'expr':
```
  ==      equal
  !=      not equal
  =~      regular expression matching: Note: Posix regular expressions will be used, e.g. use [[:digit:]]{3} instead of \d\d\d
  !~      regular expression not-matching (NOT PORTED from Kamailio 1.x, use '!(x =~ y)')
  >       greater
  >=      greater or equal
  <       less
  <=      less or equal
  &&      logical AND
  ||      logical OR
  !       logical NOT
  [ ... ] test operator - inside can be any arithmetic expression
```

### sl_send_reply(code, reason)
For the current request, a reply is sent back having the given code and text reason. The reply is sent stateless, totally independent of the Transaction module and with no retransmission for the INVITE's replies. 'code' and 'reason' can contain pseudo-variables that are replaced at runtime.

Meaning of the parameters is as follows:

* code - Return code.
* reason - Reason phrase.

This function can be used from REQUEST_ROUTE, ERROR_ROUTE.

Example 1.2. sl_send_reply usage
```
...
sl_send_reply("404", "Not found");
...
sl_send_reply("$err.rcode", "$err.rreason");
...
```

### Max Forward
```
if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
}
```

### mf_process_maxfwd_header(max_value)
Same as maxfwd_process(max_value).


### maxfwd_process(max_value)
If no Max-Forward header is present in the received request, a header will be added having the original value equal with “max_value”. If a Max-Forward header is already present, its value will be decremented (if not 0). The parameter can be a variable.

Return codes:

* 2 (true) - header was not found and a new header was successfully added.
* 1 (true) - header was found and its value was successfully decremented (had a non-0 value).
* -1 (false) - the header was found and its value is 0 (cannot be decremented).
* -2 (false) - error during processing.

The return code may be extensively tested via script variable “retcode” (or “$?”).

Meaning of the parameters is as follows:
* max_value - Value to be added if there is no Max-Forwards header field in the message.

This function can be used from REQUEST_ROUTE.

Example maxfwd_process usage
```
...
# initial sanity checks -- messages with
# max_forwards==0, or excessively long requests
if (!maxfwd_process("10") && $retcode==-1) {
	sl_send_reply("483","Too Many Hops");
	exit;
};
...
```

### max_limit (integer)
Set an upper limit for the max-forward value in the outgoing requests. If the header is present, the decremented value is not allowed to exceed this max_limits - if it does, the header value will by decreased to “max_limit”.

Note: This check is done when calling the maxfwd_process() function.

The range of values stretches from 1 to 256, which is the maximum MAX-FORWARDS value allowed by RFC 3261. The value can be changed at runtime.

Default value is “70”.

Example Set max_limit parameter
```
...
modparam("maxfwd", "max_limit", 32)
...
```

**Max-Forward** header in the context of **Kamailio** and how it affects SIP requests:

1. **Purpose of Max-Forward Header**:
   - The Max-Forward header is used to prevent loops in a SIP (Session Initiation Protocol) network. 
   - Each server that processes and forwards a SIP request decrements the Max-Forward value by one.
   - When the value reaches zero, the request is not forwarded further, and an error response is sent back to the User Agent Client (UAC).

2. **Kamailio's Implementation**:
   - Kamailio provides a module called **maxfwd** that handles operations related to the Max-Forward header.
   - If no Max-Forward header is present in the received request, the module adds a header with an original value (specified as "max_value").
   - If a Max-Forward header is already present, the module decrements its value.
   - If the decremented value is positive and nonzero, an OK code is returned.
   - If the decremented value becomes zero, an error code is returned.
   - The module also allows setting an upper limit for the Max-Forward value in outgoing requests. The default maximum value is 256, as defined by RFC 3261¹³.


Remember that the Max-Forward header plays a crucial role in ensuring proper routing and preventing infinite loops in SIP networks


### Option Request
```
if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
}
```

### $ru - Request URI
$ru - reference to request's URI (address in the first line of a SIP request)

It is R/W variable (you can assign values to it directly in configuration file)

### $rU - Username in R-URI
$rU - reference to username in request's URI or to the Namespace Identifier of a URN (see RFC 2141)

### Snaity
```
if(!sanity_check("17895", "7")) {
        xlog("Malformed SIP request from $si:$sp\n");
        exit;
}
```

### Snaity Overview
This module aims to implement several sanity checks on incoming requests which are suggested or even required by a RFC, but are not available yet in the core of Kamailio.

These checks are not required by Kamailio itself for its functionality. But on the other side it does not make much sense if a broken request traverses through a SIP network if it is rejected sooner or later by a SIP device any way. As every sanity check cost extra performance because of additional parsing and evaluation it is with this module now up to the Kamailio administrator what checks should be done on which request.

The following checks are available:

* ruri sip version - (1) - checks if the SIP version in the request URI is supported, currently only 2.0.
* ruri scheme - (2) - checks if the URI scheme of the request URI is supported (sip[s]|tel[s]) by Kamailio
* required headers - (4) -checks if the minimum set of required headers To, From, CSeq, Call-ID and Via is present in the request.
* via sip version - (8) - disabled.
* via protocol - (16) - disabled.
* Cseq method - (32) - checks if the method from the CSeq header is equal to the request method.
* Cseq value - (64) - checks if the number in the CSeq header is a valid unsigned integer.
* content length - (128) - checks if the size of the body matches with the value from the Content-Length header.
* expires value - (256) - checks if the value of the Expires header is a valid unsigned integer.
* proxy require - (512) - checks if all items of the Proxy-Require header are present in the list of the extensions from the module parameter proxy_require.
* parse uri's - (1024) - checks if the specified URIs are present and parseable by the Kamailio parsers
* digest credentials (2048) - Check all instances of digest credentials in a message. The test checks whether there are all required digest parameters and that they have meaningful values. NOTE: the message will be considered invalid if the authorization scheme differs from "digest",
* duplicated To/From tags (4096) - checks for the presence of duplicated tags in To/From headers.
* Authorization header (8192) - checks if the Authorization header is valid if the scheme is "digest" (see "digest credentials" above), always returns success for other schemes.
* first via header (16384) - checks if the first Via header is available, can be parsed and has an address value.

### default_checks (integer)
This parameter determines which of the checks from the sanity module are executed if no parameter was given to the sanity_check function call. By default all implemented checks are included in the execution of the sanity_check function. The integer value is the sum of the check numbers which should be executed by default.

Default value is “3047”. This resolves to the following list of checks: ruri_sip_version (1), ruri_scheme (2), required_headers (4), cseq_method (32), cseq_value (64), content_length (128), expires_value (256), proxy_require (512), digest credentials (2048).

Example 1.1. Set default_checks parameter
```
...
modparam("sanity", "default_checks", 1)
...
```

### uri_checks (integer)
This parameter determines which URIs are going to be checked if the 'parse uri' will be executed.

Default value is 7. This resolves to the following list of parsed URIs: Request URI (1), From URI (2) and To URI (4). Additionally the Contact URI can be also checked (8).

Example 1.2. Set uri_checks parameter
```
...
modparam("sanity", "uri_checks", 3)
...
```

### autodrop (integer)
This parameter controls whether the module drops the SIP message automatically if the sanity checks fail. Default value is 1 (auto drop). If set to 0, sanity_check() function will return -1 (false) to configuration file, allowing to write log messages for example - be sure you “exit” execution of config without sending a SIP reply because it is sent by module itself.

Example 1.4. Set autodrop parameter
```
...
modparam("sanity", "autodrop", 1)
...
```

### sanity_check([msg_checks [, uri_checks]])
This function makes a row of sanity checks over the given SIP request. The behavior of the function is also controlled by autodrop parameter. If autodrop=0, the function returns false (-1) if one of the checks failed. When autodrop=1, the function stops the execution of configuration file. In both cases, if one of the checks fails the module sends a precise error reply via SL send_reply(). Thus there is no need to reply with a generic error message.

The parameters can be static integers or variables holding integer values.

Example 1.6. sanity_check usage
```
...
if (!sanity_check()) {
	exit;
}
...
```

Optionally the function takes an integer argument which overwrites the global module parameter default_checks. This makes it possible to run certain tests from script regions. The integer value is again the sum of the checks (like for the module parameter) which should be executed at this function call.

Example 1.7. sanity_check usage with parameter
```
...
if (method=="REGISTER" && !sanity_check("256")) {
	/* the register contains an invalid expires value and is replied with a 400 */
	exit;
}
...
```

Optionally the function takes a second integer argument which overwrites the global module parameter uri_checks and thus determines which URIs will be checked if the parse uri test will be executed.

Example 1.8. sanity_check usage with two parameters
```
...
if (method=="INVITE" && !sanity_check("1024", "6")) {
	/* the INVITE contains an invalid From or To header and is replied with a 400 */
	exit;
}
...
```

## Table Sql Script
[sql script](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql)

## Structure
The structure of the kamailio.cfg can be seen as three parts:

* global parameters
* modules settings
* routing blocks

### Global Parameters Section
This is the first part of the configuration file, containing the parameters for the core of kamailio and custom global parameters.

Typically this is formed by directives of the form:

```
name=value
```

The name corresponds to a core parameter as listed in one of the next sections of this document. If a name is not matching a core parameter, then Kamailio will not start, rising an error during startup.

The value is typically an integer, boolean or a string

### Modules Settings Section
This is the second section of the configuration file, containing the directives to load modules and set their parameters.

It contains the directives loadmodule and modparam. In the default configuration file starts with the line setting the path to modules (the assignment to mpath core parameter).

Example of content:
```
loadmodule "debugger.so"
...
modparam("debugger", "cfgtrace", 1)

```

### Routing Blocks Section
This is the last section of the configuration file, typically the biggest one, containing the routing blocks with the routing logic for SIP traffic handled by Kamailio.

The only mandatory routing block is request_route, which contains the actions for deciding the routing for SIP requests.

See the chapter Routing Blocks in this document for more details about what types of routing blocks can be used in the configuration file and their role in routing SIP traffic and Kamailio behaviour.

Example of content:
```
request_route {

    # per request initial checks
    route(REQINIT);

    ...
}

branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}
```

# Kamailio Module
## Mysql Module
This is a module which provides MySQL connectivity for Kamailio. It implements the DB API defined in Kamailio.

### Install 
1. install mysql 
2. setup kamailio
in kamailio.config

    Pre-Processor
    ```
    #!define WITH_MYSQL
    ```

## SecFilter Module
### Overview Secfilter
This module has been designed to offer an additional layer of security over our communications. To achieve this, the following features are available:

- Blacklist to block user agents, IP addresses, countries, domains and users.
- Whitelist to allow user agents, IP addresses, countries, domains and users.
- Blacklist of destinations where the called number is not allowed.
- SQL injection attacks prevention.

When a function is called, it will be searched in the whitelist. If the value is not found, then the blacklist will be searched.

All data will be loaded into memory when the module is started. There is an RPC reload command to update all the data from database. It is also possible to add new data to the blacklist or whitelist using other RPC commands.

### Dependencies
The following modules must be loaded before this module:
* database -- Any db_* database module


### Database setup
Before running Kamailio with the secfilter module, it is necessary to setup the database table where the module will read the blacklist data from. In order to do that, if the table was not created by the installation script or you choose to install everything by yourself you can use the secfilter-create.sql SQL script in the database directories in the kamailio/scripts folder as a template. Database and table name can be set with module parameters so they can be changed, but the name of the columns must match the ones in the SQL script. You can also find the complete database documentation on the project webpage, https://www.kamailio.org/docs/db-tables/kamailio-db-devel.html.

Example 1.25. Example database content - secfilter table
```
		...
		+----+-----------+-----------+------------------+
		| id | action    | type      | data             |
		+----+-----------+-----------+------------------+
		|  1 | 0         | 2         | 1.1.1.1          |
		|  2 | 0         | 0         | friendly-scanner |
		|  3 | 0         | 0         | pplsip           |
		|  4 | 0         | 0         | sipcli           |
		|  5 | 0         | 4         | sipvicious       |
		|  6 | 0         | 1         | ps               |
		|  7 | 0         | 3         | 5.56.57.58       |
		|  8 | 1         | 0         | asterisk pbx     |
		|  9 | 1         | 2         | sip.mydomain.com |
		| 10 | 2         | 0         | 555123123        |
		| 11 | 2         | 0         | 555998776        |
		+----+-----------+-----------+------------------+
		...
```

Action values are:
* 0 (blacklist)
* 1 (whitelist)
* 2 (destination)

Type values are:
* 0 (user-agent)
* 1 (country)
* 2 (domain)
* 3 (IP address)
* 4 (user)

### Params secfilter
#### db_url (string)
Database URL.
Default value is ""
```
...
modparam("secfilter", "db_url", "mysql://user:pass@localhost/kamailio")
```

### Funcs secfilter
#### secf_check_ip ()
It checks if the source IP address is blacklisted. The search is approximate and data stored in the database will be compared as a prefix. For example, if we have blacklisted IP address 192.168.1. all messages from IPs like 192.168.1.% will be rejected.

Return values are:

* 2 = the value is whitelisted
* 1 = the value is not found
* -2 = the value is blacklisted

Example 1.9. secf_check_ip usage
```
        ...
secf_check_ip();
if ($? == -2) {
        xlog("L_ALERT", "$rm from $si blocked because IP address is blacklisted");
        exit;
}
        ...
```

#### secf_check_ua ()
It checks if the user-agent is blacklisted. The search is approximate and the comparison will be made using the values of the database as a prefix. If we add to the user-agent blacklist the word sipcli, every message whose user-agent is named, for example, sipcli/1.6 or sipcli/1.8 will be blocked. It is very useful to block different versions of the same program.

Return values are:

2 = the value is whitelisted
1 = the value is not found
-1 = error
-2 = the value is blacklisted
Example 1.10. secf_check_ua usage
```
        ...
secf_check_ua();
if ($? == -2) {
        xlog("L_ALERT", "$rm from $si blocked because UserAgent '$ua' is blacklisted");
        exit;
}
        ...
```

#### secf_check_country (string)
Similar to secf_check_ua. It checks if the country (IP address) is blacklisted. Geoip module must be loaded to get the country code.

Return values are:

2 = the value is whitelisted
1 = the value is not found
-1 = error
-2 = the value is blacklisted
Example 1.11. secf_check_country usage
```
        ...
if (geoip2_match("$si", "src")) {
        secf_check_country($gip2(src=>cc));
        if ($avp(secfilter) == -2) {
                xlog("L_ALERT", "$rm from $si blocked because Country '$gip2(src=>cc)' is blacklisted");
                exit;
        }
}
        ...
```

#### secf_check_from_hdr ()
It checks if any value of from header is blacklisted. It checks if from name or from user are in the users blacklist or whitelist. It also checks if the from domain is in the domains blacklist or whitelist. The blacklisted value will be used as a prefix and if we block, for example, the user sipvicious, all users whose name starts with this word will be considered as blacklisted.

Return values are:

4 = from name is whitelisted
3 = from domain is whitelisted
2 = from user is whitelisted
1 = from header not found
-1 = error
-2 = from user is blacklisted
-3 = from domain is blacklisted
-4 = from name is blacklisted
Example 1.12. secf_check_from_hdr usage
```
        ...
secf_check_from_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because From user '$fU' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because From domain '$fd' is blacklisted");
                exit;
        case -4:
                xlog("L_ALERT", "$rm to $si blocked because From name '$fn' is blacklisted");
                exit;
};
        ...
```

#### secf_check_to_hdr ()
Do the same as secf_check_from_hdr function but with the to header.

Return values are:
4 = to name is whitelisted
3 = to domain is whitelisted
2 = to user is whitelisted
1 = to header not found
-1 = error
-2 = to user is blacklisted
-3 = to domain is blacklisted
-4 = to name is blacklisted

Example 1.13. secf_check_to_hdr usage
```
        ...
secf_check_to_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because To user '$tU' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because To domain '$td' is blacklisted");
                exit;
        case -4:
                xlog("L_ALERT", "$rm to $si blocked because To name '$tn' is blacklisted");
                exit;
};
        ...
```

#### secf_check_contact_hdr ()
Do the same as secf_check_from_hdr function but with the contact header.

Return values are:
3 = contact domain is whitelisted
2 = contact user is whitelisted
1 = contact header not found
-1 = error
-2 = contact user is blacklisted
-3 = contact domain is blacklisted

Example 1.14. secf_check_contact_hdr usage
```
        ...
secf_check_contact_hdr();
switch ($?) {
        case -2:
                xlog("L_ALERT", "$rm to $si blocked because Contact user '$ct' is blacklisted");
                exit;
        case -3:
                xlog("L_ALERT", "$rm to $si blocked because Contact domain '$ct' is blacklisted");
                exit;
};
        ...
```

#### secf_check_dst (string)
It checks if the destination number is blacklisted. It must be user for INVITE messages. If the value of dst_exact_match is 1, the call will appear as blacklisted if the destination is exactly the same. If the value is 0, every destination whose number begins with a number appearing on the destination blacklist will be rejected.

Return values are:
2 (if the value is whitelisted)
1 (if the value not found)
-2 (if the value is blacklisted)

Example 1.15. secf_check_dst usage
```
...
if (is_method("INVITE")) {
        secf_check_dst($rU);
        if ($? == -2) {
                xlog("L_ALERT", "$rm from $si blocked because destination $rU is blacklisted");
                send_reply("403", "Forbidden");
                exit;
        }
}
...
```

## Sipdump Module
### Overview sipdump
This module writes SIP traffic and some associated details into local files. It intercepts automatically all the SIP traffic received or sent by Kamailio and provides a function to trigger storage from configuration file.

Received traffic has the tag 'rcv' and the one to be sent has the tag 'snd'. The tag value is provided as parameter for the config function.

Besides the SIP packets, the module aims to save details related to Kamailio runtime environment that are useful for troubleshooting, like process id, child rank, a.s.o.

The module should be useful for troubleshooting during development or testing of new deployments, especially when dealing with traffic over TLS with forward privacy, when other tools such as wireshark cannot decrypt. For production environments with a lot of SIP traffic, look at siptrace and sipcapture modules for a scalable alternative to capture all the SIP traffic and then search using Homer Sipcapture web toolkit.


### Params sipdump
#### enable (int)
Enable sipdump activity.

Default value is 0 (0 - off; 1 - on).

Example 1.1. Set enable parameter
```
...
modparam("sipdump", "enable", 1)
...
```

#### enable (int)
Enable sipdump activity.

Default value is 0 (0 - off; 1 - on).

Example 1.1. Set enable parameter
```
...
modparam("sipdump", "enable", 1)
...
```

#### folder (str)
Path to the folder where to save the files.

Default value is "/tmp".

Example 1.5. Set folder parameter
```
...
modparam("sipdump", "folder", "/run/kamailio")
...
```

#### fprefix (str)
File name prefix. The date is appended to this prefix in the format yyyy-mm-dd--hh-mm-ss. The extension of the text file is ".data", of the meta file is ".meta" and of the pcap file is ".pcap".

Default value is "kamailio-sipdump-".

Example 1.6. Set fprefix parameter
```
...
modparam("sipdump", "fprefix", "ksipdump-")
...
```

## Dispatcher Module
### Links
* [kamailio.org](https://www.kamailio.org/docs/modules/devel/modules/dispatcher.html)
* [nickvsnetworking.com](https://nickvsnetworking.com/kamailio-dispatcher/)

### Tables
[standard](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql/standard-create.sql)
```
CREATE TABLE `version` (
    `id` INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,
    `table_name` VARCHAR(32) NOT NULL,
    `table_version` INT UNSIGNED DEFAULT 0 NOT NULL,
    CONSTRAINT table_name_idx UNIQUE (`table_name`)
);

INSERT INTO version (table_name, table_version) values ('version','1');
```

[Dispatcher](https://github.com/kamailio/kamailio/blob/master/utils/kamctl/mysql/dispatcher-create.sql)
```
CREATE TABLE `dispatcher` (
    `id` INT(10) UNSIGNED AUTO_INCREMENT PRIMARY KEY NOT NULL,
    `setid` INT DEFAULT 0 NOT NULL,
    `destination` VARCHAR(192) DEFAULT '' NOT NULL,
    `flags` INT DEFAULT 0 NOT NULL,
    `priority` INT DEFAULT 0 NOT NULL,
    `attrs` VARCHAR(128) DEFAULT '' NOT NULL,
    `description` VARCHAR(64) DEFAULT '' NOT NULL
);

INSERT INTO version (table_name, table_version) values ('dispatcher','4');
```


![](https://nickvsnetworking.com/wp-content/uploads/2019/01/dispatcher-kamctl.png)

[dispatcher table schema](https://kamailio.org/docs/db-tables/kamailio-db-4.3.x.html#idp15170408)


#### Fields
Each destination point must be on one line. First token is the **set id** (an integer value, also referenced by group id), followed by **destination address** (string value in full SIP URI format).

Optionally, these fields can be followed by:

**flags** - control the mode of using the destination address and sending keepalives. It is a bitwise value that can be built using the following flags:
* 1 (bit at index 0 - 1 <<0) - inactive destination
* 2 (bit at index 1 - 1 <<1) - temporary trying destination (in the way to become inactive if it does not reply to keepalives - there is a module parameter to set the threshold of failures)
* 4 (bit at index 2 - 1 <<2) - admin disabled destination
* 8 (bit at index 3 - 1 <<3) - probing destination (sending keep alives);
* 16 (bit at index 4 - 1 <<4) - skip DNS A/AAAA resolve at startup, useful when the hostname of the destination address is a NAPTR or SRV record only. Such addresses cannot be matched anymore with ds_is_from_list(...).

**priority**: sets the priority in destination list (based on it is done the initial ordering inside the set)

**attributes**: extra fields in form of name1=value1;...;nameN=valueN.

#### Special Attributes
There are some predefined names:
* 'duid' - used for call load dispatching. It must be an unique value to identify a destination (gateway address). Practically the load within the group is associated with this value.>
* 'maxload' - used for call load dispatching. It must be a positive integer, defining the upper limit of active calls per destination. When the limit is reached, then the gateway is no longer selected for new calls until an exiting call via that gateway is terminated. If set to 0, then no active call limit is used.>
* 'weight' - used for weight based load distribution. It must be set to a positive integer value between 1 and 100 (inclusive the limits), otherwise the destination address is ignored (its weight set to 0). The value represents the percent of calls to be sent to that gateways. The sum must not exceed 100, otherwise the destinations whose weight added to the sum go over 100 are ignored. If the sum is less than 100, then the last destination is used to fill the missing percentage. See also the description of the corresponding algorithm parameter for ds_select_dst().
* 'rweight' - used for relative weight based load distribution. It must be set to a positive integer value between 1 and 100 (inclusive the limits) otherwise host will be excluded from relative weight distribution type - its rweight is set to 0. See also the description of the corresponding algorithm parameter for ds_select_dst().
* 'socket' - used to set the sending socket for the gateway. It is used for sending the SIP traffic as well as OPTIONS keepalives.
* 'sockname' - used to set by name the sending socket for the gateway. It is used for sending the SIP traffic as well as OPTIONS keepalives and has priority over 'socket' attribute.
* 'ping_from' - used to set the From URI in OPTIONS keepalives. It overwrites the general ds_ping_from parameter.
* 'obproxy' - SIP URI of outbound proxy to be used when sending pings. It overwrites the general ds_outbound_proxy parameter.
* 'latency' - latency_stats initialization in ms.

### Params dispatcher
#### ds_ping_interval (int)
With this parameter you can define the interval for sending a request to a gateway marked as inactive upon a failed request routing to it. This parameter is only used, when the TM-Module is loaded. If set to “0”, the pinging of inactive gateway is disabled.

Default value is “0”.

Example 1.22. Set the “ds_ping_interval” parameter
```
...
modparam("dispatcher", "ds_ping_interval", 30)
...
```

#### ds_ping_method (string)
With this method you can define, with which method you want to probe the gateways. Pinging gateways feature depends on ds_ping_interval parameter.

Default value is “OPTIONS”.

Example 1.20. Set the “ds_ping_method” parameter

...
modparam("dispatcher", "ds_ping_method", "INFO")
...

##### SIP requests
There are fourteen SIP Request methods of which the first six are the most basic request / method types:

* INVITE = Establishes a session
* ACK = Confirms an INVITE request
* BYE = Ends a session
* CANCEL = Cancels establishing of a session
* REGISTER = Communicates user location (host name, IP)
* OPTIONS = Communicates information about the capabilities of the calling and receiving SIP phones
* PRACK = Provisional Acknowledgement
* SUBSCRIBE = Subscribes for Notification from the notifier
* NOTIFY = Notifies the subscriber of a new event
* PUBLISH = Publishes an event to the Server
* INFO = Sends mid session information
* REFER = Asks the recipient to issue call transfer
* MESSAGE = Transports Instant Messages
* UPDATE = Modifies the state of a session

##### SIP responses
SIP Requests are answered with SIP responses, of which there are six classes:

* 1xx = Informational responses, such as 180 (ringing)
* 2xx = Success responses
* 3xx = Redirection responses
* 4XX = Request failures
* 5xx = Server errors
* 6xx = Global failures

#### ds_ping_from (string)
With this Method you can define the "From:"-Line for the request, sent to the failed gateways. This method is only available, if compiled with the probing of failed gateways enabled.

Default value is “sip:dispatcher@localhost”.

Example 1.21. Set the “ds_ping_from” parameter

...
modparam("dispatcher", "ds_ping_from", "sip:proxy@sip.somehost.com")
...

#### ds_mark_dst([state])
Mark the last used address from destination set as inactive ("i"/"I"), active ("a"/"A"), disabled ("d"/"D") or trying ("t"/"T"). Apart of disabled state, a destination can be set in probing mode by adding ("p"/"P") flag. With this function, an automatic detection of failed gateways can be implemented. When an address is marked as inactive or disabled, it will be ignored by 'ds_select_dst' and 'ds_select_domain'.

The parameter state is optional, when it is missing, then the destination will be marked inactive (i.e., same as 'i').

Possible values for state parameter:

* "a" or "A" - the last destination should be set to active and the error-counter should set to "0".
* "i" or "I" - the last destination should be set to inactive and will be ignored in future requests.
* "t" or "T" - the last destination should be set to temporary trying state and failure counter is incremented. When the failure counter reaches the threshold, the destination will be set inactive.
* "p" and "P" - this has to be used in addition to one of the previous flags - the last destination will be set to probing. This mean the destination will be pinged with SIP OPTIONS requests from time to time to detect if it is up or down.

This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.

Example 1.53. ds_mark_dst usage
```
...
failure_route[tryagain] {
...
   if(t_check_status("500"))
      ds_mark_dst("ip"); # set to inactive and probing
...
}
...
```

#### ds_probing_threshold (int)
If you want to set a gateway into inactive mode, there can be a specific number of failed requests until it will change from "active" to "inactive". It is using the state "trying", that allows selection of gateway but indicates there was a failure previously with the gateway. The number of attempts can be set with this parameter. This parameter can be modified via ser config framework.

Default value is “1” (set inactive with first failure).

Example 1.23. Set the “ds_probing_threshold” parameter
```
...
modparam("dispatcher", "ds_probing_threshold", 10)
...
```

#### ds_inactive_threshold (int)
If you want to set a gateway into active mode (after being inactive), there can be a specific number of successful requests until it will change from "inactive" to "active". The number of attempts can be set with this parameter. This parameter can be modified via ser config framework.

Default value is “1” (set active with first success).

Example 1.24. Set the “ds_inactive_threshold” parameter

...
modparam("dispatcher", "ds_inactive_threshold", 10)
...


#### ds_ping_latency_stats (int)
Enable latency measurement when pinging nodes The estimator can be initialized at startup and reload using the attribute latency.

* If set to 0, disable latency measurement.
* If set to 1, enable latency measurement.

Default value is “0”.

Example 1.27. accessing the metrics
```
# using the command :
kamcmd dispatcher.list
...
DEST: {
	URI: sip:1.2.3.4
	FLAGS: AX
	PRIORITY: 9
	ATTRS: {
		BODY: latency=24
	}
	LATENCY: {
		AVG: 24.250000 # weighted moving average for the last few weeks
		STD: 1.035000  # standard deviation of AVG
		EST: 25.000000 # short term estimate, see parameter: ds_latency_estimator_alpha
		MAX: 26        # maximum value seen
		TIMEOUT: 0     # count of ping timeouts
	}
}
...
```

Example 1.28. Set the “ds_ping_latency_stats” parameter
```
...
modparam("dispatcher", "ds_ping_latency_stats", 1)
...
```

#### ds_probing_mode (int)
Controls what gateways are tested to see if they are reachable.

* Value 0: If set to 0, only the gateways with state PROBING are tested. After a gateway is probed, the PROBING state is cleared in this mode. This means that no probing will be executed at all only if flag in config file is set to 8/PROBING (please check destination list file syntaxis for more details), it will probe only one time at startup or after dispatcher reload.

* Value 1: If set to 1, all gateways are tested. If set to 1 and there is a failure of keepalive to an active gateway, then it is set to TRYING state. This means that probing will be executed all the time, but you can skip some servers with flag 4 in destination list file, for example.

* Value 2: if set to 2, only gateways in INACTIVE state with PROBING mode set are tested.

* Value 3: If set to 3, any gateway with state PROBING is continually probed without modifying/removing the PROBING state. This allows selected gateways to be probed continually, regardless of state changes.

Default value is “0”.

Example 1.26. Set the “ds_probing_mode” parameter
```
...
modparam("dispatcher", "ds_probing_mode", 1)
...
```

#### flags (int)
Various flags that affect dispatcher's behaviour. The flags are defined as a bitmask on an integer value. If flag 1 is set only the username part of the URI will be used when computing an URI based hash. If no flags are set the username, hostname and port will be used. The port is used only if different from 5060 (normal sip URI) or 5061 (in the sips: case).

If flag 2 is set, then failover support is enabled. The functions exported by the module will store the rest of addresses from the destination set in XAPVs, and use these XAVPs to try next address if the current-tried destination fails.

Default value is “0”.

Example 1.10. Set the “flags” parameter
```
...
modparam("dispatcher", "flags", 3)
...
```

#### ds_retain_latency_stats (int)
Retain latency stats for existing destinations when reloading from file or database.

If set to 0, stats for all destinations will be reset on reload.

If set to 1, stats for existing destinations will persist across reloads.

Default value is “0”.

Example 1.29. Set the “ds_retain_latency_stats” parameter
```
...
modparam("dispatcher", "ds_retain_latency_stats", 1)
...
```

#### use_default (int)
If the parameter is set to 1, the last address in destination set is used as a final option to send the request to. For example, it is useful when wanting to send the call to an announcement server saying: "the gateways are full, try later".

Default value is “0”.

Example 1.11. Set the “use_default” parameter
```
...
modparam("dispatcher", "use_default", 1)
...
```     

#### xavp_dst (str)
The name of the XAVP which will hold the list with addresses and associated properties, in the order they have been selected by the chosen algorithm. If use_default is 1, the values of last XAVP correspond to the last address in destination set. In case of using dispatcher.list file, you have to set the priority field for each destination to ensure a particular order there. The first XAVP is the current selected destination. All the other addresses from the destination set will be added in the XAVP list to be able to implement serial forking.

Note
You must set this parameter if you want to do load balancing fail over.

Default value is “_dsdst_”.

Example 1.12. Set the “xavp_dst” parameter
```
...
modparam("dispatcher", "xavp_dst", "_dsdst_")
...
```

#### $avp(id) - AVPs
$avp(id) - the value of the AVP identified by 'id'.
$(avp(id)[N]) - represents the value of N-th AVP identified by 'id'.

The 'id' can be:

“[(s|i):]name” - name is the id of an AVP; 's' and 'i' specifies if the id is string or integer. If missing, it is considered to be string.
“name” - the name is an AVP alias, or if the alias is not found, it is a string name
pseudo variable - if value of pv is integer, id is integer, if string, id is string
$(avp(id)[0]) can be written in shorter form as $avp(id) and $avp(s:name) as $avp(name).

AVPs are special variables that are attached to SIP transactions. It is a list of pairs (name,value). Before the transaction is created, the AVP list is attached to SIP request. Note that the AVP list works like a stack, last added value is retrieved first, and there can be many values for same AVP name, an assignment to the same AVP name does not overwrite old value, it will add the new value in the list.

To delete the first AVP with name 'id' you have to assign to it '$null':

```
$avp(id) = $null;
```

To delete all the AVP with name 'id' you have to assign $null to the index '*':

```
$(avp(id)[*]) = $null;
```

To overwrite the value of the AVP with name 'id' you have to assign the new value to the index '*':

```
$(avp(id)[*]) = newvalue;
```

The value of an AVP can be integer or string. To assign a value as string, it has to be enclosed in double quotes. To assign the value as integer, it has to be a valid number given without quotes.

Example of usage:
```
$avp(x) = 1;  # assign of integer value
$avp(x) = 2;
$avp(y) = "abc"; # assign of string value
if($(avp(x)[1])==1) {
  ...
}
$(avp(x)[1]) = $null;
It is R/W variable (you can assign values to it directly in configuration file).
```

#### $xavp(id) - XAVPs
xavp - eXtended AVPs - are variables that can store multiple values, which can also be grouped in a structure-like fashion. Their value can be a string, an integer number or a list of named values (child values).

They work like a stack, similar to AVPs, and are attached to SIP transactions and automatically destroyed when the transaction is finished.

Each xavp has a string name and can contain a string, and integer or a list of named values. The structure name (or root list name) and the value name (or field name, or child value name) are separated by => like $xavp(root=>field) where “root” is the name of the structure and “field” is the name of the (child) value.

To assign a single value use:

```
$xavp(root)="string value";
$xavp(root)=intnumber;
```

To assign a named value use:
```
$xavp(root=>field)="string value";
$xavp(root=>field)=intnumber;
```

Like avps, xavp act like a stack. To refer to an existing value, use an index. The newest xavp has index zero [0].
```
$xavp(root[0]=>field)=12;
```

If you assign a value without an index, a new xavp is allocated and the old one is pushed up the stack, becoming index [1]. Old index [1] becomes [2] etc.
```
# new item (person => [(lastname = "Smith")])
$xavp(person=>lastname)="Smith";
 
# add new item (person => [(lastname = "Doe")])
$xavp(person=>lastname)="Doe";
 
# add another named value to the last example item
#   (person => [(firstname="John"), (lastname = "Doe")])
$xavp(person[0]=>firstname)="John";
 
# add another named value to first example item
#   (person => [(firstname="Alice"), (lastname = "Smith")])
xavp(person[1]=>firstname)="Alice";
```

Another example:
```
# create new (the first) root xavp with a named value of string type
$xavp(sf=>uri)="sip:10.10.10.10";
 
# add named values (child values)
$xavp(sf[0]=>fr_timer)=10;
$xavp(sf[0]=>fr_inv_timer)=15;
$xavp(sf[0]=>headers)="X-CustomerID: 1234\r\n";
 
# create new (the second) root xavp with a named value of string type, moving previous one to sf[1]
$xavp(sf=>uri)="sip:10.10.10.11";
# add named values (child values)
$xavp(sf[0]=>fr_timer)=20;
$xavp(sf[0]=>fr_inv_timer)=35;
 
# create new (the third) xavp with a named value of string type, moving previous one to sf[1] and the other one to sf[2]
$xavp(sf=>uri)="sip:10.10.10.12";
# add named values (child values)
$xavp(sf[0]=>fr_timer)=10;
$xavp(sf[0]=>fr_inv_timer)=15;
$xavp(sf[0]=>headers)="X-CustomerID: pw45\r\n";
```

### Funcs dispatcher
#### ds_select(set, alg [, limit])
The method selects a destination from addresses set and adds it in the XAVP specified for this module. It is not updating R-URI nor the destination URI. The parameters have same meaning as for ds_select_dst().

If the bit 2 in 'flags' is set, the rest of the addresses from the destination set are stored in XAVP list (limited with an optional 'limit' parameter). You can execute 'ds_next_domain()' or 'ds_next_dst()' to use next address to achieve serial forking to all possible destinations.

This function can be used from ANY_ROUTE.

Example 1.51. ds_select usage
```
...
$var(a) = 4;
if(ds_select("1", "$var(a)")) {
    ds_next_domain();
    t_relay();
    exit;
}
...
```

#### ds_next_dst()
Takes the next destination address from the corresponding XAVPs and sets the dst_uri (outbound proxy address).

This function can be used from REQUEST_ROUTE, FAILURE_ROUTE


### RPC command dispatcher
#### dispatcher.set_state
Sets the state for a destination address (can be use to mark the destination as active or inactive).

Name: dispatcher.set_state

Parameters:

_state_ : state of the destination address
* “a”: active
* “i”: inactive
* “t”: trying
* “d”: disabled
The states “a”, “i” or “t” can be followed by “p” to set probing mode (e.g. 'ap', 'ip' or 'tp').

_group_: destination group id

_address_: address of the destination in the _group_ or 'all' to update all destinations in the group

Example:
```
...
# prototype: kamcmd dispatcher.set_state _state_ _group_ _address_
kamcmd dispatcher.set_state ip 2 sip:127.0.0.1:5080
kamcmd dispatcher.set_state ip 3 all
...
```

#### dispatcher.set_duid_state
Sets the state for a destination by matching on 'duid' attribute. The first two parameters 'state' and 'group' are the same like for RPC command 'dispatcher.set_state'. The third parameter 'duid' is the value to be matched against the 'duid' attribute of dispatcher destinations.

Example:
```
...
# prototype: kamcmd dispatcher.set_duid_state _state_ _group_ _duid_
kamcmd dispatcher.set_duid_state ip 2 xyz
...
```

#### dispatcher.list
Lists the routing groups with destination addresses and corresponding attributes.

Name: dispatcher.list

Parameters:

_rmode_ - (optional) response mode - can be: 'short' to get a shorter version of groups and destinations; 'full' to get more attributes per destination

Example:
```
kamcmd dispatcher.list
...
DEST: {
        URI: sip:192.168.0.1:5060
        FLAGS: AP
        PRIORITY: 12
}
...
```

FLAGS consist out of 2 letters. First letter describe status of destination: A-active, (I) inactive, (T) trying, (D) disabled. Second letter might be P or X. P is for probing, so AP means destination is active and it is tested by SIP options continuously. X means that there are no probing or sip pinging. So AX means that destination is assumed as active and it is not tested by SIP options. DX respectively is disabled destination that is not tested, etc.

#### dispatcher.reload
Reloads the groups and included destinations. The command is disabled for call load based dispatching (algorithm 10) since removal of destinations may leave the list of active calls with broken references.

Name: dispatcher.reload

Parameters: none

Example
```
kamcmd dispatcher.reload
```

#### dispatcher.ping_active
Sets the global state for sending keepalive requests to destinations.

Name: dispatcher.ping_active

Parameters:

_state_ : state of sending keepalives

* “0”: inactive (don't send)
* “1”: active (send)

If the state parameter is missing, the current state is returned. When state is changed, new and old values of the state are returned. Default value for state is 1.

Example:
```
...
# prototype: kamcmd dispatcher.ping_active _state_
kamcmd dispatcher.ping_active 0
...
```

#### dispatcher.add
Add a destination address to the in-memory dispatcher list. Reloading the dispatcher will remove any destinations that are only added to the in-memory dispatcher list.

Name: dispatcher.add

Parameters:

_group_: destination group id

_address_: address of the destination in the _group_

_flags_ (optional): as described in the list file format, default 0

_priority_ (optional): as described in the list file format, default 0

_attrs_ (optional): as described in the list file format, default ""

Example:
```
...
# prototype: kamcmd dispatcher.add _group_ _address_ _flags_ _priority_ _attrs_
kamcmd dispatcher.add 2 sip:127.0.0.1:5080
kamcmd dispatcher.add 3 sip:127.0.0.1:5075 8
kamcmd dispatcher.add 3 sip:127.0.0.1:5075 0 0 duid=abc;socket=udp:127.0.0.1:5060
...
```

#### dispatcher.remove
Remove a destination address from the in-memory dispatcher list. Reloading the dispatcher from file or database will re-add destinations that are removed using this command.

This command will remove all entries that match the group and address.

Name: dispatcher.remove

Parameters:

_group_: destination group id

_address_: address of the destination in the _group_

Example:
```
...
# prototype: kamcmd dispatcher.remove _group_ _address_
kamcmd dispatcher.remove 2 sip:127.0.0.1:5080
kamcmd dispatcher.remove 3 sip:127.0.0.1:5075;transport=udp
...
```

### Configuration
### Parameters
You’ll need to load the dispatcher module, by adding the below line with the rest of your loadmodules:
```
loadmodule "dispatcher.so"
```
Next we’ll need to set the module specific config using modparam for dispatcher:
```
modparam("dispatcher", "db_url", DBURL)                 #Use DBURL variable for database parameters
modparam("dispatcher", "ds_ping_interval", 10)          #How often to ping destinations to check status
modparam("dispatcher", "ds_ping_method", "OPTIONS")     #Send SIP Options ping
modparam("dispatcher", "ds_probing_threshold", 10)      #How many failed pings in a row do we need before we consider it down
modparam("dispatcher", "ds_inactive_threshold", 10)     #How many sucessful pings in a row do we need before considering it up
modparam("dispatcher", "ds_ping_latency_stats", 1)      #Enables stats on latency
modparam("dispatcher", "ds_probing_mode", 1)            #Keeps pinging gateways when state is known (to detect change in state)
```

Most of these are pretty self explanatory but you’ll probably need to tweak these to match your environment.

### Destination Setup
Like the permissions module, dispatcher module has groups of destinations.

For this example we’ll be using dispatch group 1, which will be a group containing our Media Gateways, and the SIP URIs are sip:mg1:5060 and sip:mg2:5060

From the shell we’ll use kamctl to add a new dispatcher entry.
```
kamctl dispatcher add 1 sip:mg1:5060 0 0 '' 'Media Gateway 1'
kamctl dispatcher add 1 sip:mg2:5060 0 0 '' 'Media Gateway 2' 
```

Alternately you could do this in the database itself:

```
INSERT INTO `dispatcher` (`id`, `setid`, `destination`, `flags`, `priority`, `attrs`, `description`) VALUES (NULL, '1', 'sip:mg3:5060', '0', '0', '', 'Media Gateway 3'); 
Or you could use Siremis GUI to add the entries.
```

You can use kamctl to show you the database entries:

```
kamctl dispatcher show
```

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/dispatcher-kamctl.png)

### Destination Status / Control
Checking Status
Next up we’ll check if our gateways are online, we’ll use kamcmd to show the current status of the destinations:
```
kamcmd dispatcher.list
```
![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamcmd-dispatcher.list-All-active-probing.png)

Here we can see our two media gateways, quick response times to each, and everything looks good.

Take a note of the FLAGS field, it’s currently set to AP which is good, but there’s a few states:

* AP – Active Probing – Destination is responding to pings & is up
* IP – Inactive Probing – Destination is not responding to pings and is probably unreachable
* DX – Destination is disabled (administratively down)
* AX – Looks like is up or is coming up, but has yet to satisfy minimum thresholds to be considered up (ds_inactive_threshold)
* TX – Looks like or is, down. Has stopped responding to pings but has not yet satisfied down state failed ping count (ds_probing_threshold)

### Adding Additional Destinations without Restarting
If we add an extra destination now, we can add it without having to restart Kamailio, by using kamcmd:
```
kamcmd dispatcher.reload
```
There’s some sanity checks built into this, if the OS can’t resolve a domain name in dispatcher you’ll get back an error:

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamcmd-failing-to-add-dispatcher.png)

### Administratively Disable Destinations
You may want to do some work on one of the Media Gateways and want to nicely take it offline, for this we use kamcmd again:

```
kamcmd dispatcher.set_state dx 1 sip:mg1:5060
```

Now if we check status we see MG1’s status is DX:

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamailio-dispatcher-destination-down.png)

Once we’re done with the maintenance we could force it into the up state by replacing dx with ap.

It’s worth noting that if you restart Kamailio, or reload dispatcher, the state of each destination is reset, and starts again from AX and progresses to AP (Up) or IP (Down) based on if the destination is responding.

### Routing using Dispatcher
The magic really comes down to single simple line, ds_select_dst();

The command sets the destination address to an address from the pool of up addresses in dispatcher.

You’d generally give ds_select_dst(); two parameters, the first is the destination set, in our case this is 1, because all our Media Gateway destinations are in set ID 1. The next parameter is is the algorithm used to work out which destination from the pool to use for this request.

Some common entries would be random, round robin, weight based or priority value.

In our example we’ll use a random selection between up destinations in group 1:

```
if(method=="INVITE"){
   ds_select_dst(1, 4);    #Get a random up destination from dispatcher
   route(RELAY);           #Route it
}
```

Now let’s try and make a call:

```
UA > Kamailio: SIP: INVITE sip:1111111@Kamailio SIP/2.0

Kamailio > UA: SIP: SIP/2.0 100 trying -- your call is important to us

Kamailio > MG1: SIP: INVITE sip:1111111@MG1 SIP/2.0 

MG1 > Kamailio: SIP: SIP/2.0 100 Trying
 
Kamailio > UA : SIP: SIP/2.0 100 Trying 

MG1 > Kamailio:  SIP: SIP/2.0 200 OK
 
Kamailio > UA :  SIP: SIP/2.0 200 OK 
```

And bingo, we’re connected to a Media Gateway 1.
If I try it again I’ll get MG2, then MG1, then MG2, as we’re using round robin selection.

### Destination Selection Algorithm
We talked a little about the different destination select algorithm, let’s dig a little deeper into the common ones, this is taken from the Dispatcher documentation:

* “0” – hash over callid
* “4” – round-robin (next destination).
* “6” – random destination (using rand()).
* “8” – select destination sorted by priority attribute value (serial forking ordered by priority).
* “9” – use weight based load distribution.
* “10” – use call load distribution. 
* “12” – dispatch to all destination in setid at once

For select destination sorted by priority (8) to work you need to include a priority, you can do this when adding the dispatcher entry or after the fact by editing the data. In the below example if MG1 is up, calls will always go to MG1, if MG1 is down it’ll go to the next highest priority (MG2).

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/priorities.png)

The higher the priority the more calls it will get
For use weight based load distribution (9) to work, you’ll need to set a weight as well, this is similar to priority but allows you to split load, for example you could put weight=25 on a less powerful or slower destination, and weight=75 for a faster or more powerful destination, so the better destination gets 75% of traffic and the other gets 25%. (You don’t have to do these to add to 100%, I just find it easier to think of them as percentages).

![](https://nickvsnetworking.com/wp-content/uploads/2019/01/kamailio-dispatcher-weight.png)

use call load distribution (10) allows you to evenly split the number of calls to each destination. This could be useful if you’ve got say 2 SIP trunks with x channels on each trunk, but only x concurrent calls allowed on each. Like adding a weight you need to set a duid= value with the total number of calls each destination can handle.

dispatch to all destination in setid at once (12) allows you to perform parallel branching of your call to all the destinations in the address group and whichever one answers first will handle the call. This adds a lot of overhead, as for each destination you have in that set will need a new dialog to be managed, but it sure is quick for the user. The other major issue is let’s say I have three carriers configured in dispatcher, and I call a landline.

That landline will receive three calls, which will ring at the same time until the called party answers one of the calls. When they do the other two calls will stop ringing. This can get really messy.

### weight and rweight 
weight: use weight based load distribution. You have to set the attribute 'weight' for each address (gateway) in destination set. See also the description of the 'weight' attribute in the 'Special Attributes' section

rweight: use relative weight based load distribution. You have to set the attribute 'rweight' per each address in destination set. Active host usage probability is rweight/(SUM of all active host rweights in destination group).

The major difference from the weight distribution is the probability recalculation according to rweight value in case of destinations being active or inactive.

For example, 100 calls in 3-destinations group with rweight params 1/2/1 will be distributed as 25/50/25. If the third destination becomes inactive, the distribution is changed to 33/67/0. If the computation of percentage per destination is not an exact integer number, the value is trucated and the last destination is used to fill the remaining percentage till 100

### weight
|   id  |  setid  |  destination         | flags | priority |     attrs      | description |
| :---: | :-----: |    :------------:    | :---: | :------: |     :---:      | :--------:  | 
|   1   |     1   |  192.168.21.80:5060  |       |          |   weight=25    | node1       |
|   2   |     1   |  192.168.21.81:5060  |       |          |   weight=50    | node2       |
|   3   |     1   |  192.168.21.82:5060  |       |          |   weight=25    | node3       |

#### Example 1
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node1 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   0      |    75   |    25   | 


#### Example 2
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node2 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    25    |    0    |    75   | 

#### Example 3
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node3 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    50    |    50   |    0    | 


### rweight
|   id  |  setid  |  destination         | flags | priority |     attrs      | description |
| :---: | :-----: |    :------------:    | :---: | :------: |     :---:      | :--------:  | 
|   1   |     1   |  192.168.21.80:5060  |       |          |   rweight=25    | node1       |
|   2   |     1   |  192.168.21.81:5060  |       |          |   rweight=50    | node2       |
|   3   |     1   |  192.168.21.82:5060  |       |          |   rweight=25    | node3       |

#### Example 1
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node1 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   0      |    66   |    34   | 


#### Example 2
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node2 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    50    |    0    |    50   | 

#### Example 3
100 Calls
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|   25     |   50    |    25   | 


100 Calls when node3 is inactive
|   node1  |  node2  |  node3  |
| :---:    | :-----: |  :----: | 
|    34    |    66   |    0    | 


### Detection state node
#### fr_timer (integer)
Timer which hits if no final reply for a request or ACK for a negative INVITE reply arrives (in milliseconds).

Default value is 30000 ms (30 seconds).

Example 1.1. Set fr_timer parameter
```
...
modparam("tm", "fr_timer", 10000)
...
```

state node
```
A(active) ---> T(trying)[active] ---> I(inactive) ---> A(active)
```
```
AX -> AP -> TP -> IP -> AP
```

params
```
modparam("tm", "fr_timer", 30000)                      # default retransmission timeout: 30sec

modparam("dispatcher", "ds_ping_interval", 10)         # How often to ping destinations to check status: 10sec
modparam("dispatcher", "ds_ping_method", "OPTIONS")    # Send SIP Options ping
modparam("dispatcher", "ds_probing_threshold", 5)      # How many failed pings in a row do we need before we consider it down (active -> inactive)
modparam("dispatcher", "ds_inactive_threshold", 2)     # How many sucessful pings in a row do we need before consider it up (inactive -> active)
```

```
AX --(10sec)--> AP --(30sec)--> TP --(50sec)--> IP --(20sec)--> AP
```


------------

for state AX to AP: 
```
AX -> AP = 1 * ping_interval
```

example:
```
AX -> AP = 1 * 10sec = 10sec
```

------------

for state AP to TP: 
```
AP -> TP = fr_timer
```

example:
```
AP -> TP = 30sec
```

------------

for state TP to IP: 
```
TP -> IP = probing_threshold * ping_interval
```

example:
```
TP -> IP = 5 * 10sec = 50sec 
```

------------


for state AP to IP:
```
AP -> IP = fr_timer + (probing_threshold * ping_interval)
```

example:
```
AP -> IP = 30sec + (5 * 10sec) = 80sec 
```

------------

for state IP to AP:
```
IP -> AP = inactive_threshold * ping_interval
```

example:
```
IP -> AP = 2 * 10sec = 20sec 
```

------------


### Managing Failure
Let’s say we try and send a call to one of our Media Gateways and it fails, we could forward that failure response to the UA, or, better yet, we could try on another Media Gateway.

Let’s set a priority of 10 to MG1 and a priority of 5 to MG2, and then set MG1 to reject the call.
![](https://nickvsnetworking.com/wp-content/uploads/2019/01/priorities-2.png)

We’ll also need to add a failure route, so let’s tweak our code:

```
if(method=="INVITE"){
        ds_select_dst(1, 12);
        t_on_failure("DISPATCH_FAILURE");
        route(RELAY);
}
```

And the failure route:
```
failure_route[DISPATCH_FAILURE]{
        ds_mark_dst("ip");
        xlog("Trying next destination");
        ds_next_dst();
        route(RELAY);
}
```

flag 2 is set, then failover support is enabled
...
modparam("dispatcher", "flags", 2)
...


ds_next_dst() gets the next available destination from dispatcher. Let’s see how this looks in practice:

``` 
UA > Kamailio: SIP: INVITE sip:1111111@Kamailio SIP/2.0

Kamailio > UA: SIP: SIP/2.0 100 trying -- your call is important to us

Kamailio > MG1: SIP: INVITE sip:1111111@MG1 SIP/2.0 

MG1 > Kamailio: SIP: SIP/2.0 100 Trying

MG1 > Kamailio:  SIP: SIP/2.0 404 Not Found
 
Kamailio > MG1 :  SIP: SIP/2.0 ACK

Kamailio > MG2: SIP: INVITE sip:1111111@MG2 SIP/2.0  

MG2 > Kamailio: SIP: SIP/2.0 100 Trying

MG2 > Kamailio:  SIP: SIP/2.0 200 OK
 
Kamailio > UA :  SIP: SIP/2.0 200 OK
```

### t_on_failure(failure_route)
Sets failure routing block, to which control is passed after a transaction completed with a negative result but before sending a final reply. In the referred block, you can either start a new branch (good for services such as forward_on_no_reply) or send a final reply on your own (good for example for message silo, which received a negative reply from upstream and wants to tell upstream "202 I will take care of it"). Note that the set of commands which are usable within failure_routes is strictly limited to rewriting URI, initiating new branches, logging, and sending stateful replies (t_reply). Any other commands may result in unpredictable behavior and possible server failure. Note that whenever failure_route is entered, uri is reset to value which it had on relaying. If it temporarily changed during a reply_route processing, subsequent reply_route will ignore the changed value and use again the original one.

Meaning of the parameters is as follows:

failure_route - Failure route block to be called.

Example 1.58. t_on_failure usage
```
...
route {
    t_on_failure("1");
    t_relay();
}

failure_route[1] {
    revert_uri();
    setuser("voicemail");
    append_branch();
}
...
```

[dispatcher explain 10 algorithm](https://www.kwancro.com/post/kamailio-dispatcher-module-hidden-gem/)

## Routing based on call load distribution
Imagine having to route calls to 30 media gateways but also ensuring that the number of calls across all of them is evenly maintained. Some have come up with solutions where a frequent query for call volume is sent to the media gateways and the results are stored and used to make routing decisions. Smart, but there are too many moving parts. Also, the routing decision based on call volume is as close to real time as the frequency of the gateway queries.

With call load distribution set as the algorithm in the dispatcher module, Kamailio can keep track of the calls (by call-ID) routed to the gateways. The gateway call volume will then be maintained through the configuration file by tracking each INVITE, BYE, CANCEL, positive and negative response code received. The beauty of this is that it does not have to be aware of call dialogs so is really lightweight.

## Setup
1. Set unique gateway IDs (duid)
Each gateway in the dispatcher table must have its own unique id called duid. This id is populated in the attribute (attrs) column of the dispatcher table. An example table of 3 gateways with druids of 1015, 1016 and 1017 would look like this:

```
+-----+--------+------------------+-------+----------+-----------+---------------+
| id  | setid  | destination      | flags | priority | attrs     | description   |
+-----+--------+------------------+-------+----------+-----------+---------------+
|  10 |  100   | sip:192.68.10.15 |     0 |       50 | duid=1015 |  gateway-01   |
|  11 |  100   | sip:192.68.10.16 |     0 |       50 | duid=1016 |  gateway-02   |
|  12 |  100   | sip:192.68.10.17 |     0 |       50 | duid=1017 |  gateway-03   |
+-----+--------+------------------+-------+----------+-----------+---------------+
```

2. Enable dispatcher to route calls to media gateways
In your configuration logic you can route calls to the gateways like this:

```
if(!ds_select_dst("100", "10")) {
    send_reply("404", "No destination");
    Exit;
}
```

3. Track calls
After sending the call to the gateway, in our configuration file we now have to make sure we keep track of the call and update the call load status of the gateway. The idea of how to go about tracking the calls can be split in 2 steps. Tracking a successful call attempt and tracking a failed call attempt.

ds_load_update() is the function used to track successful call attempts. We will call it when:
* we get a positive response (200 - 299) for the INVITE we sent to a gateway, update internal tracking as call confirmed
* we receive a BYE or CANCEL , update gateway load tracker

ds_load_unset() is the function for tracking failed call attempts. We will call it when:
* we receive a negative response code (300 - 799) then clear that call attempt from the gateway tracker.
Using th functions in the config file it would look something like this:

In the main route:
```
route {
    ...
	if(is_method("BYE|CANCEL"))
        ds_load_update();
    ...
}
In the onreply_route:

onreply_route {
    ...
    if(is_method("INVITE")
	{
        if(status=~"2[0-9][0-9]")
            ds_load_update();
        else if(status=~"[3-7][0-9][0-9]")
            ds_load_unset();
    }
    ...
}
```

And that is it. With this in place, the load on the gateways will always be evenly spread.

The latest dispatcher module documentation is quite detailed with options and example code and would definitely recommend reading it.

# Ctl Module
This module implements the binrpc transport interface for Kamailio RPCs. It supports various transports over which it speaks binrpc: Unix datagram sockets, Unix stream sockets, UDP and TCP. It also supports a backward compatible FIFO interface (using the old Kamailio FIFO protocol).

By default (if no parameters are changed in the config file) it uses a Unix stream socket under /tmp: /tmp/ser_ctl. This socket is also the default for kamcmd.

In general it's used in conjunction with kamcmd. kamcmd is a Unix tool for invoking Kamailio RPC functions. It can be used both in interactive mode (supports tab-completion and history) or command line mode.

Example 1.1. kamcmd example usage
```
$ kamcmd ps
11262	attendant
11268	udp receiver child=0 sock=127.0.0.1:5060
11269	udp receiver child=1 sock=127.0.0.1:5060
11270	udp receiver child=0 sock=192.168.1.101:5060
11271	udp receiver child=1 sock=192.168.1.101:5060
11272	slow timer
11273	timer
11274	ctl handler
11275	tcp receiver child=0
11276	tcp receiver child=1
11277	tcp main process
```

## params ctl
### binrpc (string)
Specifies the transport used for the binrpc protocol. The following transport protocol are supported: Unix datagram sockets, Unix stream sockets, UDP and TCP.

The format is: [ protocol:] address_port|path .

* For Unix sockets: [unixd|unixs|unix]:path where "unixd" means Unix datagram sockets and "unix" "unixs" mean Unix stream sockets. Examples: "unixd:/tmp/unix_dgram", "unixs:/tmp/unix_stream", "unix:/tmp/unix_stream".
* For UDP or TCP sockets: [udp|tcp]:address:port. If the address is "*" or missing, it will bind to all the local addresses (0.0.0.0). Examples: "udp:localhost:2046", "tcp:localhost:2046", "tcp:3012", "udp:*:3012".

If the protocol part is missing and the address/path part looks like a file system path it will default to a Unix stream socket and if not to an Unix UDP socket. Examples:

* "/tmp/unix_test" - equivalent to "unixs:/tmp/unix_test".
* "localhost:3000" - equivalent to "udp:localhost:3000".
Multiple transports / listen addresses can be specified, just by setting the parameter multiple times.

Default:"unix:/tmp/ser_ctl" (Unix stream socket). The default value is used only if no binrpc parameter is found in the config file.

Example 1.2. Set binrpc parameter
```
loadmodule "ctl"

# optional listen addresses, if no one is specified,
# ctl will listen on unixs:/tmp/ser_ctl

modparam("ctl", "binrpc", "unix:/tmp/ser_ctl") # default
modparam("ctl", "binrpc", "udp:localhost:2046")
modparam("ctl", "binrpc", "tcp:localhost:2046")
modparam("ctl", "binrpc", "unixd:/tmp/unix_dgram")  # unix datagram
modparam("ctl", "binrpc", "unixs:/tmp/unix_stream") # unix stream
modparam("ctl", "binrpc", "unix:/tmp/unix_default") # unix stream
modparam("ctl", "binrpc", "/tmp/unix_test")         # unix stream
modparam("ctl", "binrpc", "localhost:3000")         # udp
modparam("ctl", "binrpc", "tcp:3012")               # tcp any , port 3012
modparam("ctl", "binrpc", "udp:*:3012")             # udp any , port 3012
```

for example 
```
modparam("ctl", "binrpc", "tcp:localhost:8000")
```
```
kamcmd -s tcp:<IP>:8000 <Kamcmd_Command>
```

# sipp
## Main features
SIPp allows to generate one or many SIP calls to one remote system. The tool is started from the command line. In this example, two SIPp are started in front of each other to demonstrate SIPp capabilities.

Run sipp with embedded server (uas) scenario:

```
# ./sipp -sn uas
```

* must set remote_ip and remote_port in SIPp server 

On the same host, run sipp with embedded client (uac) scenario:
```
# ./sipp -sn uac 127.0.0.1
```

## Integrated scenarios
Integrated scenarios? Yes, there are scenarios that are embedded in SIPp executable. While you can create your own custom SIP scenarios (see how to create your own XML scenarios), a few basic (yet useful) scenarios are available in SIPp executable.

### UAC
Scenario file: uac.xml
```
SIPp UAC            Remote
    |(1) INVITE         |
    |------------------>|
    |(2) 100 (optional) |
    |<------------------|
    |(3) 180 (optional) |
    |<------------------|
    |(4) 200            |
    |<------------------|
    |(5) ACK            |
    |------------------>|
    |                   |
    |(6) PAUSE          |
    |                   |
    |(7) BYE            |
    |------------------>|
    |(8) 200            |
    |<------------------|
```

### UAC with media
Scenario file: uac_pcap.xml
```
SIPp UAC            Remote
    |(1) INVITE         |
    |------------------>|
    |(2) 100 (optional) |
    |<------------------|
    |(3) 180 (optional) |
    |<------------------|
    |(4) 200            |
    |<------------------|
    |(5) ACK            |
    |------------------>|
    |                   |
    |(6) RTP send (8s)  |
    |==================>|
    |                   |
    |(7) RFC2833 DIGIT 1|
    |==================>|
    |                   |
    |(8) BYE            |
    |------------------>|
    |(9) 200            |
    |<------------------|
```

### UAS
Scenario file: uas.xml
```
Remote              SIPp UAS
    |(1) INVITE         |
    |------------------>|
    |(2) 180            |
    |<------------------|
    |(3) 200            |
    |<------------------|
    |(4) ACK            |
    |------------------>|
    |                   |
    |(5) PAUSE          |
    |                   |
    |(6) BYE            |
    |------------------>|
    |(7) 200            |
    |<------------------|
```

## Create your own XML scenarios
Of course embedded scenarios will not be enough. So it’s time to create your own scenarios. A SIPp scenario is written in XML (a DTD that may help you write SIPp scenarios does exist and has been tested with jEdit - this is described in a later section). A scenario will always start with:

```
<?xml version="1.0" encoding="ISO-8859-1" ?>
<scenario name="Basic Sipstone UAC">
```

And end with:

```
</scenario>
```

Easy, huh? Ok, now let’s see what can be put inside. You are not obliged to read the whole table now! Just go in the next section for an example.

There are many common attributes used for flow control and statistics, that can be used for all of the message commands (i.e., <send> , <recv> , <nop> , <pause> , <sendCmd> and <recvCmd> ).

## Keyword list
### [service]
* Default:	(service)
* Description:	Service field, as passed in the -s service_name

### [remote_ip]
Description:	Remote IP address, as passed on the command line.

### [remote_port]
* Default:	5060
* Description:	Remote IP port, as passed on the command line. You can add a computed offset   remote_port+3 to this value.

## Options
* -sf : Loads an alternate XML scenario file.  To learn more about XML scenario
        syntax, use the -sd option to dump embedded scenarios. They contain all the

* -sn : Use a default scenario (embedded in the SIPp executable). If this option is
        omitted, the Standard SipStone UAC scenario is loaded.
        Available values in this version:

        * 'uac'      : Standard SipStone UAC (default).                                                                           
        * 'uas'      : Simple UAS responder.
        * 'regexp'   : Standard SipStone UAC - with regexp and variables.
        * 'branchc'  : Branching and conditional branching in scenarios - client.
        * 'branchs'  : Branching and conditional branching in scenarios - server.

* -inf : Inject values from an external CSV file during calls into the scenarios.
        First line of this file say whether the data is to be read in sequence
        (SEQUENTIAL), random (RANDOM), or user (USER) order.
        Each line corresponds to one call and has one or more ';' delimited data
        fields. Those fields can be referred as [field0], [field1], ... in the xml
        scenario file.  Several CSV files can be used simultaneously (syntax: -inf
        f1.csv -inf f2.csv ...)

* -r  : Set the call rate (in calls per seconds).  This value can bechanged during
        test by pressing '+', '_', '*' or '/'. Default is 10.
        pressing '+' key to increase call rate by 1 * rate_scale,
        pressing '-' key to decrease call rate by 1 * rate_scale,
        pressing '*' key to increase call rate by 10 * rate_scale,
        pressing '/' key to decrease call rate by 10 * rate_scale.


* -rp : Specify the rate period for the call rate.  Default is 1 second and default
        unit is milliseconds.  This allows you to have n calls every m milliseconds
        (by using -r n -rp m).
        Example: -r 7 -rp 2000 ==> 7 calls every 2 seconds.
        -r 10 -rp 5s => 10 calls every 5 seconds.

```
# -r 5 -rp 1s
0 ---1s--- 5 ---1s--- 10 ---1s--- 15 ---1s--- 20 ...
```


* -rate_scale : Control the units for the '+', '-', '*', and '/' keys.

* -rate_increase : Specify the rate increase every -rate_interval units (default is seconds).
                This allows you to increase the load for each independent logging period.
                Example: -rate_increase 10 -rate_interval 10s
                ==> increase calls by 10 every 10 seconds.

* -rate_max  : If -rate_increase is set, then quit after the rate reaches this value.
                Example: -rate_increase 10 -rate_max 100
                ==> increase calls by 10 until 100 cps is hit.

* -rate_interval : Set the interval by which the call rate is increased. Defaults to the value
                of -fd.

```
# -rate_increase 10 -rate_interval 1s 
1s -> 0+10=10
2s -> +10+10=20
3s -> +20+10=30
4s -> +30+10=40
5s -> +40+10=50

0 ---1s--- 10 ---1s--- 30 ---1s--- 60 ---1s--- 100 ---1s--- 150
```


* -no_rate_quit : If -rate_increase is set, do not quit after the rate reaches -rate_max.

* -l    : Set the maximum number of simultaneous calls. Once this limit is reached,
        traffic is decreased until the number of open calls goes down. Default:
        (3 * call_duration (s) * rate).

* -m  : Stop the test and exit when 'calls' calls are processed

* -users : Instead of starting calls at a fixed rate, begin 'users' calls at startup,
        and keep the number of calls constant.

* -p  : Set the local port number.  Default is a random free port chosen by the
        system.

* -s  : Set the username part of the resquest URI. Default is 'service'.

* -rsa : Set the remote sending address to host:port for sending the messages.

Example : 

server
```
# Server:  192.168.10.20:5060
sipp -sn uas 
```

client 
```
sipp -sn usc -rsa 192.168.10.20:5060 
```

Example : 

client 
```
# FreeSwitch:  192.168.10.20:5060
# Dialplan : 1010

sipp -sn usc -rsa 192.168.10.30:5060 -s 1010 
```

* -d : Controls the length of calls. More precisely, this controls the duration of
        'pause' instructions in the scenario, if they do not have a 'milliseconds'
        section. Default value is 0 and default unit is milliseconds.


Example :

when use -d not use miliseconds in pause

command
```
./sipp -sn uac 
```

scenario
```
<pause milliseconds="8000"/>
```

that config equal with :

command
```
./sipp -sn uac -d 8s
```

scenario
```
<pause/>
```


## Remote control
SIPp can be “remote-controlled” through a UDP socket. This allows for example

* To automate a series of actions, like increasing the call rate smoothly, wait for 10 seconds, increase more, wait for 1 minute and loop
* Have a feedback loop so that an application under test can remote control SIPp to lower the load, pause the traffic, …
Each SIPp instance is listening to a UDP socket. It starts to listen to port 8888 and each following SIPp instance (up to 60) will listen to base_port + 1 (8889, 8890, …).

It is then possible to control SIPp like this:

```
echo p >/dev/udp/x.y.z.t/8888 -> put SIPp in pause state (p key)
echo q >/dev/udp/x.y.z.t/8888 -> quit SIPp (q key)
```

## SIPp command line options:
Following a list of the most common command line options. You can obtain the full list executing the command sipp -h.

Scenario options
* -sn <scenario>: use a builtin scenario (uas, uac, regexp, ...)
* -sd <scenario>: dump the XML implementing the builtin scenario
* -sf <scenario-file>: load a custom scenario file
* -set <var> <val>: set the variable var with val value, the variable can then used into the scenario file as [$var]

SIP IP address and port
* -i <local_ip>: set the local IP address for the Contact, Via and From headers, can be referenced with [local_ip] keyword into a scenario file. Applies to the SIP protocol only.
* -p <local_port>: set the local port for the SIP protocol. Can be referenced using the [local_port]keyword.

Media and RTP options
* -mi <media_ip>: set the local media IP address, this value can also be referred using the [media_ip] keyword into the scenario file
* -mp <media_port>: set the local media port, this value can also be referred using the [media_port] keyword into the scenario file
* -rtp_echo: Enable RTP echo. RTP/UDP packets received on port defined by -mp are echoed to their sender.

Call rate options
* -l <max_calls>: set the maximum number of simultaneous calls
* -m <calls>: Stop the test and exit when calls calls are processed

Tracing and logging options
* -trace_msg: dump sent and received SIP messages in <scenario_file_name>_<pid>_messages.log
* -message_file: Set the name of the message log file
* -trace_err: trace all unexpected messages in <scenario_file_name>_<pid>_errors.log
* -error_file: set the name of the error log file
* -trace_logs: allow tracing of actions in <scenario_file_name>_<pid>_logs.log
* -log_file: set the name of the log actions log file

## SIPp scenario file syntax
root XML tag is named scenario and must have the name attribute:
```
<?xml version="1.0" encoding="utf-8" ?>
<scenario name="Basic UAC custom scenario">
  <!-- here your scenario -->
</scenario>
```

### Scenario commands
Here is a lost of the most important scenario commands:

* <send>: send a SIP message or a response. Important attributes are:
   * retrans: set the T1 timer for this message in milliseconds
   * lost: emulate packet lost, value in percentage
<recv>: wait for a SIP message or response. Important attributes are:

* response: indicates what SIP message code is expected
* request: indicates what SIP message request is expected
* optional: Indicates if the message to receive is optional. If optional is set to "global", SIPp will look every previous steps of the scenario
* lost: emulate packet lost, value in percentage
* timeout: specify a timeout while waiting for a message. If the message is not received, the call is aborted
* ontimeout: specify a label to jump to if the timeout popped regexp_match: boolean. Indicates if 'request' ('response' is not available) is given as a regular expression.
The recv command can also include the action tag defining the action to execute upon the message reception

* pause: pause the scenario execution. Important attributes are:
   * milliseconds: time to pause in milliseconds
   * variable: scenario variable defining the pause time

* nop: the nop action doesn’t do nothing at SIP signalling level, is just a tag containing the action subtag

* sendCmd: content to be sent to the twin 3PCC (3rd Party Call Control) SIPp instance. The Call-ID must be included

* recvCmd: specify an action when receiving the command

* label: a label is used when you want to branch to specific parts in your scenarios

## Common command attributes
Here is a list of attributes common to all the scenario commands:

* crlf: Displays an empty line after the arrow for the message in main SIPp screen
* next: You can put a "next" in any command element to go to another part of the script when you are done with sending the message. For optional receives, the next is only taken if that message was received
* test: You can put a "test" next to a "next" attribute to indicate that you only want to branch to the label specified with "next" if the variable specified in "test" is set
* display: Display a text into the SIPp screen

## Scenario keywords
Inside the send command, you have to enclose your SIP message between the <![CDATA and the ]]> tags.

Everything between those tags is going to be sent toward the remote system. Into the SIP message you can include some keywords (Eg. [service], [remote_ip], etc..).

Those keywords will get replaced at runtime by SIPp.

* [service]: service field, as passed in the -s <service_name> command line option (default: service)
* [remote_ip] and [remote_port]: remote IP address and port
* [transport]: the transport mode (depending on the -t CLI parameter) (default: UDP)
* [local_ip], [local_ip_type], [local_port]: depending on the -l and -p CLI params. Type can be 4 or 6
* [len]: computed length of the SIP body. To be used in Content-Length header
* [cseq]: generates automatically the CSeq number
* [call_id]: a call_id identifies a call and is generated by SIPp for each new call. In client mode, it is mandatory to use the value generated by SIPp in the Call-ID header
* [media_ip], [media_ip_type], [media_port]: depending on the value of -mi and -mp params.
* [last_*]: is replaced automatically by the specified header if it was present in the last message received (Eg. [last_From])
The ‘[last_*]’ keyword is replaced automatically by the specified header if it was present in the last message received (except if it was a retransmission). If the header was not present or if no message has been received, the ‘[last_*]’ keyword is discarded, and all bytes until the end of the line are also discarded. If the specified header was present several times in the message, all occurences are concatenated (CRLF separated) to be used in place of the ‘[last_*]’ keyword.
* [routes]: If the “rrs” attribute in a recv command is set to “true”, then the “Record-Route:” header of the message received is stored and can be recalled using the [routes] keyword.
* [next_url]: If the “rrs” attribute in a recv command is set to “true”, then the [next_url] contains the contents of the Contact header (i.e within the ‘<’ and ‘>’ of Contact)


## SIPp Scenarios for two way media call
for statefull scenario 

### Client
[client.xml](SIPp/client.xml)

1. Add rrs to receive response(200 ok)
```
  <recv response="200" rtd="true" rrs="true">
  </recv>
```

2. Add next_url and routes in ACK method
```
  <send>
    <![CDATA[

      ACK [next_url] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]
      From: sipp <sip:sipp@[local_ip]:[local_port]>;tag=[pid]SIPpTag00[call_number]
      To: [service] <sip:[service]@[remote_ip]:[remote_port]>[peer_tag_param]
      [routes]
      Call-ID: [call_id]
      CSeq: 1 ACK
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Content-Length: 0

    ]]>
  </send>
```

3. Add next_url and routes in BYE method
```
  <send retrans="500" crlf="true">
    <![CDATA[

      BYE [next_url] SIP/2.0
      Via: SIP/2.0/[transport] [local_ip]:[local_port];branch=[branch]
      From: sipp <sip:sipp@[local_ip]:[local_port]>;tag=[pid]SIPpTag00[call_number]
      To: [service] <sip:[service]@[remote_ip]:[remote_port]>[peer_tag_param]
      [routes]
      Call-ID: [call_id]
      CSeq: 2 BYE
      Contact: sip:sipp@[local_ip]:[local_port]
      Max-Forwards: 70
      Subject: Performance Test
      Content-Length: 0

    ]]>
  </send>
```

### Server
[server.xml](SIPp/server.xml)

1. Add rrs to receive response INVITE method
```
  <recv request="INVITE" crlf="true" rrs="true">
  </recv>
```

2. Add last_Record-Route to send response (200 ok) 
```

  <send retrans="500">
    <![CDATA[

      SIP/2.0 200 OK
      [last_Via:]
      [last_From:]
      [last_To:];tag=[call_number]
      [last_Call-ID:]
      [last_CSeq:]
      Contact: <sip:[local_ip]:[local_port];transport=[transport]>
      [last_Record-Route:]
      Content-Type: application/sdp
      Content-Length: [len]

      v=0
      o=sipp 87308505 1 IN IP[local_ip_type] [local_ip]
      s=-
      t=0 0
      m=audio [media_port] RTP/AVP 8 101
      c=IN IP[media_ip_type] [media_ip]
      a=rtpmap:8 PCMA/8000
      a=rtpmap:101 telephone-event/8000
      a=fmtp:101 0-15
      a=ptime:20

    ]]>
  </send>

```

3. Add play pcap file 
* server pcap file and client pcap file are diffrent SSRC(Synchronization source identifier) in RTP packet(server and client) is must diffrent

* SSRC : Synchronization source identifier uniquely identifies the source of a stream. The synchronization sources within the same RTP session will be unique.
SSRC Identifies the synchronization source. The value is chosen randomly, with the intent that no two synchronization sources within the same RTP session will have the same SSRC. Although the probability of multiple sources choosing the same identifier is low, all RTP implementations must be prepared to detect and resolve collisions. If a source changes its source transport address, it must also choose a new SSRC to avoid being interpreted as a looped source

```
  <nop>
    <action>
        <exec play_pcap_audio="pcap/g711u.pcap"/>
    </action>
  </nop>
```

### Kmailio config

1. Add ewritehostport in request_route

```
if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484", "Address Incomplete");
        exit;
}

# dispatch destinations to PSTN
route(PSTN);

# add this lines
rewritehostport("1.2.3.4:5080"); # add ip and port SIPp server
route(RELAY);

# user location service
route(LOCATION);
```

## Scenario actions
In a recv, recvCmd or nop command you can execute one or more actions:

* ereg: execute a regular expression matching
* log: write a log message
* exec: execute a command on the operating system shell, or an internal SIPp command or play a pcap file
* jump: jump to an arbitrary scenario index


## Media/RTP commands
RTP streaming allows you to stream audio from a PCMA, PCMU, G722, iLBC or G729-encoded audio file (e.g. a .wav file). The “rtp_stream” action controls this.

* <exec rtp_stream=”file.wav” /> will stream the audio contained in file.wav, assuming it is a PCMA-format file.
* <exec rtp_stream=”[filename],[loopcount],[payloadtype]” /> will stream the audio contained in [filename], repeat the stream [loopcount] times (the default is 1, and -1 indicates it will repeat forever), and will treat the audio as being of [payloadtype] (where 8 is the default of PCMA, 0 indicates PCMU, 9 indicates G722, 18 indicates G729 and 98 indicates iLBC in 30ms 13.33kbps).
* <exec rtp_stream=”pause” /> will pause any currently active playback.
* <exec rtp_stream=”resume” /> will resume any currently paused playback.
PCAP play commands (specified using play_pcap_audio / play_pcap_video attributes) allow you to send a pre-recorded RTP stream using the pcap library. Choose play_pcap_audio to send the pre-recorded RTP stream using the “m=audio” SIP/SDP line port as a base for the replay.

Choose play_pcap_video to send the pre-recorded RTP stream using the “m=video” SIP/SDP line port as a base.

The play_pcap_audio/video command has the following format: play_pcap_audio=”[file_to_play]” with:

* file_to_play: the pre-recorded pcap file to play

The audio file should be the raw samples, example files are included for PCMA, G722 and iLBC (mode=30).

```
Codec	Payload id	Packet size	Packet time	FFMpeg arguments
PCMU	0	160 bytes	20 ms	-f ulaw -ar 8k -ac 1
PCMA	8	160 bytes	20 ms	-f alaw -ar 8k -ac 1
G722	9	160 bytes	20 ms	-f g722 -ar 16k -ac 1
G729	18	20 bytes	20 ms	not supported by ffmpeg
iLBC	98	50 bytes	30 ms	-f ilbc -ar 8k -ac 1 -b:a 13.33k
```


# Linux
## Interrupts
### Links

* [Understanding CPU Interrupts](https://alibaba-cloud.medium.com/understanding-cpu-interrupts-in-linux-8af22d6e548a)
* [Receive-Side Scaling (RSS)](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rss#doc-wrapper)
* [Receive Packet Steering (RPS)](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps)
* [Receive Flow Steering (RFS)](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rfs)
* [CPU affinity calculator](https://bitsum.com/tools/cpu-affinity-calculator)


### Understanding CPU Interrupts
### What Is an Interrupt?
When a hardware component (such as a disk controller or an Ethernet NIC) needs to interrupt the work of the CPU, it triggers an interrupt. The interrupt notifies the CPU that an event occurred and the CPU should suspend its current work to deal with the event. To prevent multiple devices from sending the same interrupt, Linux provides an interrupt request system so that each device in the computer system is assigned an interrupt number to ensure the uniqueness of its interrupt request.

In kernel 2.4 and later, Linux improves the capability of assigning specific interrupts to the specified processors (or processor groups). This is called the SMP IRQ affinity, which controls how the system responds to various hardware events. You can limit or redistribute the server workload so that the server can work more efficiently.

Let’s take NIC interrupts as an example. Without the SMP IRQ affinity, all NIC interrupts are associated with CPU 0. As a result, CPU 0 is overloaded and cannot efficiently process network packets, causing a bottleneck in performance.

After you configure the SMP IRQ affinity, multiple NIC interrupts are allocated to multiple CPUs to distribute the CPU workload and speed up data processing. The SMP IRQ affinity requires NICs to support multiple queues. A NIC supporting multiple queues has multiple interrupt numbers, which can be evenly allocated to different CPUs.

You can simulate a multi-queue mode for a single-queue NIC by means of receive packet steering (RPS) or receive flow steering (RFS), but the effect is poorer than that of a multi-queue NIC with RPS/RFS enabled.


### What Are RPS and RFS?
Receive packet steering (RPS) balances the load of soft interrupts among CPUs. In short, the NIC driver calculates a hash ID for each stream by using a quadruplet (SIP, SPORT, DIP, and DPORT), and the interrupt handler allocates the hash ID to the corresponding CPU, thus fully utilizing the multi-core capability. Generally, RPS simulates functions of a multi-queue NIC by using software. If a NIC supports multiple queues, RPS is ineffective. RPS is mainly intended for single-queue NICs in a multi-CPU environment. If a NIC supports multiple queues, you can directly bind hard interrupts to CPUs by configuring the SMP IRQ affinity.

![](https://miro.medium.com/v2/resize:fit:828/format:webp/0*Tjj5kzCpNcuuVvtR.png)

RPS simply distributes data packets to different CPUs. This greatly degrades the utilization of CPU caches when different CPUs are used to run applications and handle soft interrupts. In this case, RFS ensures that one CPU is used to run applications and handle soft interrupts, to fully utilize the CPU caches. RPS and RFS are usually used together to achieve the best results. They are mainly intended for single-queue NICs in a multi-CPU environment.

![](https://miro.medium.com/v2/resize:fit:828/format:webp/0*YDvx-JGgtipsUl3z.png)

The values of rps_flow_cnt and rps_sock_flow_entries are carried to the nearest power of 2. For a single-queue device, rps_flow_cnt is equal to rps_sock_flow_entries.

Receive flow steering (RFS), together with RPS, inserts data packets into the backlog queue of a specified CPU, and wakes up the CPU for execution.

IRQbalance is applicable to most scenarios. However, in scenarios requiring high network performance, you are recommended to bind interrupts manually.

IRQbalance can cause some issues during operation:

* The calculated value is sometimes inappropriate, failing to achieve load balancing among CPUs.

* When the system is idle and IRQs are in power-save mode, IRQbalance distributes all interrupts to the first CPU, to make other idle CPUs sleep and reduce energy consumption. When the load suddenly rises, performance may be degraded due to the lag in adjustment.

* The CPU specified to handle interrupts frequently changes, resulting in more context switches.

* IRQbalance is enabled but does not take effect, that is, does not specify a CPU for handling interrupts.

### Receive-Side Scaling (RSS)
Receive-Side Scaling (RSS), also known as multi-queue receive, distributes network receive processing across several hardware-based receive queues, allowing inbound network traffic to be processed by multiple CPUs. RSS can be used to relieve bottlenecks in receive interrupt processing caused by overloading a single CPU, and to reduce network latency.

To determine whether your network interface card supports RSS, check whether multiple interrupt request queues are associated with the interface in /proc/interrupts. For example, if you are interested in the p1p1 interface:

```
# egrep 'CPU|p1p1' /proc/interrupts
      CPU0    CPU1    CPU2    CPU3    CPU4    CPU5
89:   40187       0       0       0       0       0   IR-PCI-MSI-edge   p1p1-0
90:       0     790       0       0       0       0   IR-PCI-MSI-edge   p1p1-1
91:       0       0     959       0       0       0   IR-PCI-MSI-edge   p1p1-2
92:       0       0       0    3310       0       0   IR-PCI-MSI-edge   p1p1-3
93:       0       0       0       0     622       0   IR-PCI-MSI-edge   p1p1-4
94:       0       0       0       0       0    2475   IR-PCI-MSI-edge   p1p1-5
```

The preceding output shows that the NIC driver created 6 receive queues for the p1p1 interface (p1p1-0 through p1p1-5). It also shows how many interrupts were processed by each queue, and which CPU serviced the interrupt. In this case, there are 6 queues because by default, this particular NIC driver creates one queue per CPU, and this system has 6 CPUs. This is a fairly common pattern amongst NIC drivers.

Alternatively, you can check the output of ls -1 /sys/devices/*/*/device_pci_address/msi_irqs after the network driver is loaded. For example, if you are interested in a device with a PCI address of 0000:01:00.0, you can list the interrupt request queues of that device with the following command:

```
# ls -1 /sys/devices/*/*/0000:01:00.0/msi_irqs
101
102
103
104
105
106
107
108
109
```

RSS is enabled by default. The number of queues (or the CPUs that should process network activity) for RSS are configured in the appropriate network device driver. For the bnx2x driver, it is configured in num_queues. For the sfc driver, it is configured in the rss_cpus parameter. Regardless, it is typically configured in /sys/class/net/device/queues/rx-queue/, where device is the name of the network device (such as eth1) and rx-queue is the name of the appropriate receive queue.

When configuring RSS, Red Hat recommends limiting the number of queues to one per physical CPU core. Hyper-threads are often represented as separate cores in analysis tools, but configuring queues for all cores including logical cores such as hyper-threads has not proven beneficial to network performance.

When enabled, RSS distributes network processing equally between available CPUs based on the amount of processing each CPU has queued. However, you can use the ethtool --show-rxfh-indir and --set-rxfh-indir parameters to modify how network activity is distributed, and weight certain types of network activity as more important than others.

The irqbalance daemon can be used in conjunction with RSS to reduce the likelihood of cross-node memory transfers and cache line bouncing. This lowers the latency of processing network packets. If both irqbalance and RSS are in use, lowest latency is achieved by ensuring that irqbalance directs interrupts associated with a network device to the appropriate RSS queue.


### Receive Packet Steering (RPS)
Receive Packet Steering (RPS) is similar to RSS in that it is used to direct packets to specific CPUs for processing. However, RPS is implemented at the software level, and helps to prevent the hardware queue of a single network interface card from becoming a bottleneck in network traffic.

RPS has several advantages over hardware-based RSS:
* RPS can be used with any network interface card.
* It is easy to add software filters to RPS to deal with new protocols.
* RPS does not increase the hardware interrupt rate of the network device. However, it does introduce inter-processor interrupts.

RPS is configured per network device and receive queue, in the /sys/class/net/device/queues/rx-queue/rps_cpus file, where device is the name of the network device (such as eth0) and rx-queue is the name of the appropriate receive queue (such as rx-0).

The default value of the rps_cpus file is zero. This disables RPS, so the CPU that handles the network interrupt also processes the packet.

To enable RPS, configure the appropriate rps_cpus file with the CPUs that should process packets from the specified network device and receive queue.

The rps_cpus files use comma-delimited CPU bitmaps. Therefore, to allow a CPU to handle interrupts for the receive queue on an interface, set the value of their positions in the bitmap to 1. For example, to handle interrupts with CPUs 0, 1, 2, and 3, set the value of rps_cpus to 00001111 (1+2+4+8), or f (the hexadecimal value for 15).

For network devices with single transmit queues, best performance can be achieved by configuring RPS to use CPUs in the same memory domain. On non-NUMA systems, this means that all available CPUs can be used. If the network interrupt rate is extremely high, excluding the CPU that handles network interrupts may also improve performance.

For network devices with multiple queues, there is typically no benefit to configuring both RPS and RSS, as RSS is configured to map a CPU to each receive queue by default. However, RPS may still be beneficial if there are fewer hardware queues than CPUs, and RPS is configured to use CPUs in the same memory domain.

### Receive Flow Steering (RFS)
Receive Flow Steering (RFS) extends RPS behavior to increase the CPU cache hit rate and thereby reduce network latency. Where RPS forwards packets based solely on queue length, RFS uses the RPS backend to calculate the most appropriate CPU, then forwards packets based on the location of the application consuming the packet. This increases CPU cache efficiency.

RFS is disabled by default. To enable RFS, you must edit two files:

```
/proc/sys/net/core/rps_sock_flow_entries
```

Set the value of this file to the maximum expected number of concurrently active connections. We recommend a value of 32768 for moderate server loads. All values entered are rounded up to the nearest power of 2 in practice.

```
/sys/class/net/device/queues/rx-queue/rps_flow_cnt
```

Replace device with the name of the network device you wish to configure (for example, eth0), and rx-queue with the receive queue you wish to configure (for example, rx-0).

Set the value of this file to the value of rps_sock_flow_entries divided by N, where N is the number of receive queues on a device. For example, if rps_flow_entries is set to 32768 and there are 16 configured receive queues, rps_flow_cnt should be set to 2048. For single-queue devices, the value of rps_flow_cnt is the same as the value of rps_sock_flow_entries.

Data received from a single sender is not sent to more than one CPU. If the amount of data received from a single sender is greater than a single CPU can handle, configure a larger frame size to reduce the number of interrupts and therefore the amount of processing work for the CPU. 

Alternatively, consider NIC offload options or faster CPUs.
Consider using numactl or taskset in conjunction with RFS to pin applications to specific cores, sockets, or NUMA nodes. This can help prevent packets from being processed out of order.

### Viewing in practical
System processing interrupts are recorded in the **/proc/interrupts** file
```
# cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
  0:        141          0          0          0   IO-APIC-edge      timer
  1:         10          0          0          0   IO-APIC-edge      i8042
  4:        807          0          0          0   IO-APIC-edge      serial
  6:          3          0          0          0   IO-APIC-edge      floppy
  8:          0          0          0          0   IO-APIC-edge      rtc0
  9:          0          0          0          0   IO-APIC-fasteoi   acpi
 10:          0          0          0          0   IO-APIC-fasteoi   virtio3
 11:         22          0          0          0   IO-APIC-fasteoi   uhci_hcd:usb1
 12:         15          0          0          0   IO-APIC-edge      i8042
 14:          0          0          0          0   IO-APIC-edge      ata_piix
 15:          0          0          0          0   IO-APIC-edge      ata_piix
 24:          0          0          0          0   PCI-MSI-edge      virtio1-config
 25:       4522          0          0       4911   PCI-MSI-edge      virtio1-req.0
 26:          0          0          0          0   PCI-MSI-edge      virtio2-config
 27:       1913          0          0          0   PCI-MSI-edge      virtio2-input.0
 28:          3        834          0          0   PCI-MSI-edge      virtio2-output.0
 29:          2          0       1557          0   PCI-MSI-edge      virtio2-input.1
 30:          2          0          0        187   PCI-MSI-edge      virtio2-output.1
 31:          0          0          0          0   PCI-MSI-edge      virtio0-config
 32:       1960          0          0          0   PCI-MSI-edge      virtio2-input.2
 33:          2        798          0          0   PCI-MSI-edge      virtio2-output.2
 34:         30          0          0          0   PCI-MSI-edge      virtio0-virtqueues
 35:          3          0        272          0   PCI-MSI-edge      virtio2-input.3
 36:          2          0          0        106   PCI-MSI-edge      virtio2-output.3
input0 indicates the network interrupt handled by the first CPU (CPU 0).
If there are multiple Alibaba Cloud ECS network interrupts, input.1, input.2, and input.3 are available.
......
PIW:          0          0          0          0   Posted-interrupt 
```

**What is `/proc/irq/`?**
   - `/proc/irq/` is a virtual filesystem in Linux that provides information about interrupt requests (IRQs). IRQs are signals generated by hardware devices to notify the CPU that they need attention. Common examples include keyboard input, network card events, or disk I/O completion.
   - Each IRQ has its own directory within `/proc/irq/`, making it easy to inspect and configure specific interrupts.
   - It’s a technique in Linux that directs incoming network packets to specific CPUs for processing

**Contents of `/proc/irq/`:**
   - Inside each IRQ directory, you'll find files with useful information:
     - `smp_affinity`: Specifies which CPU cores can handle the IRQ. You can set CPU affinity using this file.
     - `smp_affinity_list`: Similar to `affinity`, but expressed as a bitmask (e.g., `0-3` for cores 0 to 3).

**Setting CPU Affinity:**
   - To improve performance, you can bind an IRQ to specific CPU cores. For example:
     ```bash
     echo 1 > /proc/irq/IRQ/smp_affinity
     ```
     This assigns the IRQ to CPU core 1. for calculate use this [link](https://bitsum.com/tools/cpu-affinity-calculator)
     
   - Use `cat /proc/irq/IRQ/smp_affinity` to check the current affinity.

**Bitmask:**
"f" is a hexadecimal value corresponding to the binary value of “1111”. (When the bits for four CPUs are set to f, all CPUs are used to handle interrupts.)

**Receive Packet Steering (RPS)** in Linux is a technique used to direct incoming network packets to specific CPUs for processing. It helps prevent the hardware queue of a single network interface card (NIC) from becoming a bottleneck in network traffic¹. Here's how you can configure RPS:

**Identify the CPUs** you want to use for packet processing. For example, if you want to use CPUs 0, 1, 2, and 3, set the value of `rps_cpus` to `00001111` (binary) or `f` (hexadecimal).

**Edit the configuration file** for your network interface. Typically, this file is located in `/sys/class/net/<interface_name>/queues/rx-<queue_number>/rps_cpus`. Replace `<interface_name>` with your actual NIC name and `<queue_number>` with the queue number you want to configure.

**Set the desired CPU mask**. For example, to use CPUs 0, 1, 2, and 3, you can run the following command (replace `<interface_name>` and `<queue_number>` accordingly):
```bash
echo f > /sys/class/net/<interface_name>/queues/rx-<queue_number>/rps_cpus
```

**Verify the configuration** by checking the contents of the `rps_cpus` file:
```bash
cat /sys/class/net/<interface_name>/queues/rx-<queue_number>/rps_cpus
```
It should display the same CPU mask you set earlier.

**Control the number of entries in the global table (rps_sock_flow_table) by using a kernel parameter:**
```
# sysctl -a |grep net.core.rps_sock_flow_entries
net.core.rps_sock_flow_entries = 0
# sysctl -w net.core.rps_sock_flow_entries=32768
net.core.rps_sock_flow_entries = 32768
```

if queue is 8 then 32768/8=4096

**Specify the number of entries in the hash table of each NIC queue:**
```
#  cat /sys/class/net/<interface_name>/queues/rx-<queue_number>/rps_flow_cnt
0
# echo 4096 > /sys/class/net/<interface_name>/queues/rx-<queue_number>/rps_flow_cnt
#  cat /sys/class/net/<interface_name>/queues/rx-<queue_number>/rps_flow_cnt
4096
```

## ethtool
ethtool is a command-line utility in Linux used for querying and controlling network device driver and hardware settings. It provides a variety of functions to modify network interface card (NIC) parameters, diagnose issues, and optimize network performance. 

### Basic Usage
The general syntax for using ethtool is:

```
ethtool [options] <interface>
```
Where <interface> is the name of the network interface you want to manage, such as eth0, eth1, etc.

The `-c` and `-C` options in `ethtool` are used to display and configure interrupt coalescing settings for a network interface, respectively.

### Interrupt Coalescing
Interrupt coalescing is a technique used to reduce the number of interrupts sent to the CPU by the network interface card (NIC). Instead of generating an interrupt for every single packet, the NIC waits until a certain condition is met, such as a specific number of packets received or a certain amount of time passed, before generating an interrupt. This can improve CPU efficiency and reduce overhead, especially in high-throughput environments.

### `-c` Option: Display Interrupt Coalescing Settings

The `-c` option is used to display the current interrupt coalescing settings for a specified network interface.

#### Syntax
```bash
ethtool -c <interface>
```

#### Example
```bash
ethtool -c eth0
```

#### Output
The output will look something like this:

```plaintext
Coalesce parameters for eth0:
Adaptive RX: off
Adaptive TX: off
stats-block-usecs: 0
pkt-rate-low: 0
pkt-rate-high: 0

RX: 
  Usecs: 64
  Frames: 0
TX: 
  Usecs: 64
  Frames: 0
```

- **Adaptive RX/TX**: Indicates whether adaptive interrupt coalescing is enabled.
- **stats-block-usecs**: Time interval (in microseconds) for updating statistics blocks.
- **pkt-rate-low/high**: Packet rate thresholds for low and high packet rates.
- **RX Usecs/Frames**: Number of microseconds or frames before an RX interrupt is generated.
- **TX Usecs/Frames**: Number of microseconds or frames before a TX interrupt is generated.

### `-C` Option: Modify Interrupt Coalescing Settings

The `-C` option is used to set the interrupt coalescing parameters for a specified network interface.

#### Syntax
```bash
ethtool -C <interface> [parameter value]
```

Where the parameters can include:

- `rx-usecs N`: Set the number of microseconds to wait before generating an RX interrupt.
- `rx-frames N`: Set the number of frames to receive before generating an RX interrupt.
- `tx-usecs N`: Set the number of microseconds to wait before generating a TX interrupt.
- `tx-frames N`: Set the number of frames to transmit before generating a TX interrupt.
- `adaptive-rx on/off`: Enable or disable adaptive RX interrupt coalescing.
- `adaptive-tx on/off`: Enable or disable adaptive TX interrupt coalescing.
- `stats-block-usecs N`: Set the statistics block interval in microseconds.
- `pkt-rate-low N`: Set the low packet rate threshold.
- `pkt-rate-high N`: Set the high packet rate threshold.

#### Example
```bash
ethtool -C eth0 rx-usecs 128 tx-usecs 128
```

This command sets the interrupt coalescing delay to 128 microseconds for both RX and TX on the network interface `eth0`.

### Practical Considerations
- **Performance Tuning**: Adjusting interrupt coalescing settings can help optimize performance. For example, increasing the RX/TX usecs can reduce CPU overhead by decreasing the number of interrupts, but it might introduce a slight delay in packet processing.
- **Adaptive Coalescing**: Enabling adaptive interrupt coalescing allows the NIC to dynamically adjust coalescing parameters based on current traffic conditions, which can be useful in environments with varying traffic loads.
- **Testing and Monitoring**: After making changes, it’s important to monitor network performance and CPU usage to ensure that the adjustments have the desired effect without introducing new issues.

### Conclusion
Using the `-c` and `-C` options in `ethtool`, you can display and configure interrupt coalescing settings for network interfaces. This allows for fine-tuning of how and when interrupts are generated by the NIC, which can lead to improved CPU efficiency and overall network performance in various environments.

### rx-usecs
The rx-usecs parameter specifies the amount of time, in microseconds, that the network interface card (NIC) will wait before generating an interrupt after receiving a packet. This setting is part of the interrupt coalescing mechanism which helps in reducing the CPU load by limiting the number of interrupts.

Usage Example:
```
ethtool -C eth0 rx-usecs 128
```
This command sets the NIC to wait for 128 microseconds after receiving a packet before generating an interrupt.

### rx-frames
The rx-frames parameter specifies the number of packets (frames) that the NIC will wait to receive before generating an interrupt. This setting, like rx-usecs, is part of the interrupt coalescing mechanism.

Usage Example:
```
ethtool -C eth0 rx-frames 32
```

This command sets the NIC to wait until 32 packets have been received before generating an interrupt.

### adaptive-rx
The adaptive-rx parameter enables or disables adaptive interrupt coalescing for receive interrupts. When adaptive interrupt coalescing is enabled, the NIC dynamically adjusts the rx-usecs and rx-frames settings based on the current traffic load and conditions. This can optimize performance by balancing latency and CPU utilization more effectively than static settings.

Usage Example:
```
ethtool -C eth0 adaptive-rx on
```
This command enables adaptive RX interrupt coalescing on the NIC, allowing it to automatically adjust the coalescing parameters as needed.


### rx-flow-hash
```
ethtool -N ens1f0np0 rx-flow-hash udp4 sd
       rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|tcp6|udp6|ah6|esp6|sctp6
       m|v|t|s|d|f|n|r...
              Configures the hash options for the specified flow
              type.

              m   Hash on the Layer 2 destination address of the rx packet.
              v   Hash on the VLAN tag of the rx packet.
              t   Hash on the Layer 3 protocol field of the rx packet.
              s   Hash on the IP source address of the rx packet.
              d   Hash on the IP destination address of the rx packet.
              f   Hash on bytes 0 and 1 of the Layer 4 header of the rx packet.
              n   Hash on bytes 2 and 3 of the Layer 4 header of the rx packet.
              r   Discard all packets of this flow type. When this option is
                  set, all other options are ignored
```

The `rx-flow-hash` option in `ethtool` is used to configure the Receive Flow Hash setting for a network interface. This setting determines how the NIC (Network Interface Card) distributes incoming packets across multiple receive queues when receive-side scaling (RSS) is enabled. RSS is a technology that allows for the distribution of network processing across multiple CPU cores to improve performance and throughput, particularly in high-speed network environments.

### Understanding RX Flow Hash

**Receive Flow Hash** is a method used to determine which receive queue an incoming packet should be placed into. This decision is based on certain fields in the packet headers, such as source and destination IP addresses, ports, and protocols. The hashing algorithm uses these fields to compute a hash value, which is then used to assign the packet to one of the available receive queues.

### Fields Used for Hashing

Common fields that might be used in the hash calculation include:
- Source IP address
- Destination IP address
- Source port
- Destination port
- Protocol type

### Configuring `rx-flow-hash` with `ethtool`

You can use `ethtool` to get and set the RX flow hash configuration. The syntax typically looks like this:

```sh
ethtool -n [interface]
ethtool -N [interface] rx-flow-hash tcp4 sdfn
```

- `ethtool -n [interface]`: Displays the current RX flow hash configuration for the specified network interface.
- `ethtool -N [interface] rx-flow-hash [parameters]`: Sets the RX flow hash configuration for the specified network interface.

### Example

Here's an example of how you might configure `rx-flow-hash`:

```sh
ethtool -N eth0 rx-flow-hash tcp4 sdfn
```

In this command:
- `eth0` is the name of the network interface.
- `tcp4` indicates that the configuration applies to IPv4 TCP traffic.
- `sdfn` is a string where each letter represents a different field to be used in the hash calculation:
  - `s` stands for source IP address.
  - `d` stands for destination IP address.
  - `f` stands for source port.
  - `n` stands for destination port.

You can use different combinations of these fields based on your specific requirements.

### Practical Usage

#### Displaying Current RX Flow Hash Settings

To see the current RX flow hash configuration, you can use:

```sh
ethtool -n eth0
```

This will display the current settings for how packets are hashed and distributed across receive queues.

#### Setting RX Flow Hash Settings

To set the RX flow hash configuration, you might use:

```sh
ethtool -N eth0 rx-flow-hash udp4 sdfn
```

In this command:
- `udp4` indicates that the configuration applies to IPv4 UDP traffic.
- `sdfn` specifies that the hash calculation will use the source IP, destination IP, source port, and destination port fields.

### Benefits of Configuring RX Flow Hash

1. **Improved Performance:** By distributing incoming packets more evenly across multiple receive queues and CPU cores, the system can handle higher network throughput and reduce the risk of a single core becoming a bottleneck.
2. **Better Load Balancing:** Properly configured RX flow hash settings ensure that network processing is evenly distributed, which can lead to more consistent performance under load.
3. **Enhanced Scalability:** For systems with multiple CPU cores and high-speed network interfaces, configuring RX flow hash helps to fully utilize the available hardware resources.

### Conclusion

Configuring `rx-flow-hash` with `ethtool` allows you to fine-tune how your network interface distributes incoming packets across multiple receive queues


### Type of rx-flow-hash
The `rx-flow-hash` parameter in `ethtool` is used to configure how a network interface card (NIC) distributes incoming packets across multiple receive queues. This distribution helps to balance the load among multiple CPU cores and improve network performance. The `rx-flow-hash` types specify which fields of the packet headers are used to compute the hash value for this distribution.

Here are the common types of `rx-flow-hash` you might encounter:

### Common Types of RX Flow Hash

1. **IPV4 (ip4)**
   - `src`: Source IP address
   - `dst`: Destination IP address

2. **TCP over IPV4 (tcp4)**
   - `src`: Source IP address
   - `dst`: Destination IP address
   - `src-port`: Source port
   - `dst-port`: Destination port

3. **UDP over IPV4 (udp4)**
   - `src`: Source IP address
   - `dst`: Destination IP address
   - `src-port`: Source port
   - `dst-port`: Destination port

4. **SCTP over IPV4 (sctp4)**
   - `src`: Source IP address
   - `dst`: Destination IP address
   - `src-port`: Source port
   - `dst-port`: Destination port

5. **IPV6 (ip6)**
   - `src`: Source IP address
   - `dst`: Destination IP address

6. **TCP over IPV6 (tcp6)**
   - `src`: Source IP address
   - `dst`: Destination IP address
   - `src-port`: Source port
   - `dst-port`: Destination port

7. **UDP over IPV6 (udp6)**
   - `src`: Source IP address
   - `dst`: Destination IP address
   - `src-port`: Source port
   - `dst-port`: Destination port

8. **SCTP over IPV6 (sctp6)**
   - `src`: Source IP address
   - `dst`: Destination IP address
   - `src-port`: Source port
   - `dst-port`: Destination port

### Example Configuration

When configuring `rx-flow-hash` using `ethtool`, you specify the protocol and the fields to be used in the hash computation. For example:

```sh
ethtool -N eth0 rx-flow-hash tcp4 sdfn
```

In this command:
- `eth0` is the network interface.
- `tcp4` specifies the protocol (TCP over IPV4).
- `sdfn` is the combination of fields to use for the hash:
  - `s`: Source IP address
  - `d`: Destination IP address
  - `f`: Source port
  - `n`: Destination port

### Detailed Explanation of Each Field

1. **Source IP Address (`s`):** The IP address of the sender. Including this in the hash helps to distinguish traffic from different sources.
2. **Destination IP Address (`d`):** The IP address of the receiver. Including this helps to distinguish traffic destined for different addresses.
3. **Source Port (`f`):** The port number on the sender's side. This is especially useful for differentiating between multiple connections from the same source IP.
4. **Destination Port (`n`):** The port number on the receiver's side. This helps to distinguish different services (e.g., HTTP, HTTPS) running on the same destination IP.

### Practical Uses and Benefits

- **Load Balancing:** By using a combination of IP addresses and port numbers, you can ensure a more even distribution of packets across receive queues and CPU cores.
- **Scalability:** Proper configuration allows the system to handle higher network loads efficiently.
- **Performance:** Reduces bottlenecks by spreading the network processing workload, leading to better utilization of hardware resources.

### Conclusion

Configuring `rx-flow-hash` correctly can significantly enhance the performance and scalability of your network by ensuring an efficient distribution of incoming packets across multiple receive queues and CPU cores. This is particularly important in high-speed networking environments where optimal resource utilization is crucial.

### field of rx-flow-hash
The `rx-flow-hash` parameter in `ethtool` specifies how incoming packets are distributed across multiple receive queues by defining the fields used to compute a hash value. These fields are extracted from packet headers and used to generate a hash that determines the receive queue to which a packet will be assigned. This distribution helps to balance the load among multiple CPU cores, improving network performance.

Here's an explanation of the fields you can use in `rx-flow-hash`:

### Common Fields of RX Flow Hash

1. **Source IP Address (`s`):**
   - The IP address of the sender.
   - Used to distinguish traffic coming from different source IPs.
   - Applicable to both IPv4 (`ip4`, `tcp4`, `udp4`, `sctp4`) and IPv6 (`ip6`, `tcp6`, `udp6`, `sctp6`) protocols.

2. **Destination IP Address (`d`):**
   - The IP address of the receiver.
   - Used to distinguish traffic going to different destination IPs.
   - Applicable to both IPv4 (`ip4`, `tcp4`, `udp4`, `sctp4`) and IPv6 (`ip6`, `tcp6`, `udp6`, `sctp6`) protocols.

3. **Source Port (`f`):**
   - The port number on the sender's side.
   - Helps differentiate between multiple connections from the same source IP.
   - Applicable to transport layer protocols like TCP (`tcp4`, `tcp6`), UDP (`udp4`, `udp6`), and SCTP (`sctp4`, `sctp6`).

4. **Destination Port (`n`):**
   - The port number on the receiver's side.
   - Helps distinguish different services (e.g., HTTP, HTTPS) running on the same destination IP.
   - Applicable to transport layer protocols like TCP (`tcp4`, `tcp6`), UDP (`udp4`, `udp6`), and SCTP (`sctp4`, `sctp6`).

5. **IP Protocol (`i`):**
   - The protocol number from the IP header.
   - Used to differentiate traffic based on the protocol type (e.g., TCP, UDP).
   - Typically used in IPv4 and IPv6 configurations.

6. **VLAN Tag (`v`):**
   - The VLAN tag associated with the packet.
   - Helps differentiate traffic belonging to different VLANs.
   - Applicable in networks using VLANs for segmentation.

7. **Flow Label (`l`):**
   - The flow label field in the IPv6 header.
   - Used to identify specific flows in IPv6 traffic.
   - Applicable only to IPv6 configurations.

### Example Configurations

When configuring `rx-flow-hash` using `ethtool`, you can specify the protocol and the fields to be used in the hash computation. Here are some examples:

#### Example 1: TCP over IPv4 with Source and Destination IP and Ports

```sh
ethtool -N eth0 rx-flow-hash tcp4 sdfn
```

- `eth0` is the network interface.
- `tcp4` specifies the protocol (TCP over IPv4).
- `sdfn` indicates that the hash should be computed using:
  - `s`: Source IP address
  - `d`: Destination IP address
  - `f`: Source port
  - `n`: Destination port

#### Example 2: IPv6 with Source and Destination IP

```sh
ethtool -N eth0 rx-flow-hash ip6 sd
```

- `eth0` is the network interface.
- `ip6` specifies the protocol (IPv6).
- `sd` indicates that the hash should be computed using:
  - `s`: Source IP address
  - `d`: Destination IP address

### Practical Considerations

- **Load Balancing:** Proper configuration ensures an even distribution of packets, preventing any single queue or CPU core from becoming a bottleneck.
- **Scalability:** Helps in scaling network performance by utilizing multiple cores efficiently.
- **Performance:** Reduces latency and increases throughput by optimizing packet processing.

### Conclusion

Understanding and configuring `rx-flow-hash` fields is crucial for optimizing network performance, especially in high-speed networking environments. By selecting appropriate fields based on your network traffic patterns and requirements, you can ensure efficient load balancing and better utilization of hardware resources.

### Ofload
### Link
* [NIC Offloads](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-nic-offloads#network-nic-offloads)

The default Ethernet maximum transfer unit (MTU) is 1500 bytes, which is the largest frame size that can usually be transmitted. This can cause system resources to be underutilized, for example, if there are 3200 bytes of data for transmission, it would mean the generation of three smaller packets. There are several options, called offloads, which allow the relevant protocol stack to transmit packets that are larger than the normal MTU. Packets as large as the maximum allowable 64KiB can be created, with options for both transmitting (Tx) and receiving (Rx). When sending or receiving large amounts of data this can mean handling one large packet as opposed to multiple smaller ones for every 64KiB of data sent or received. This means there are fewer interrupt requests generated, less processing overhead is spent on splitting or combining traffic, and more opportunities for transmission, leading to an overall increase in throughput.


### Offload Types
#### TCP Segmentation Offload (TSO)
Uses the TCP protocol to send large packets. Uses the NIC to handle segmentation, and then adds the TCP, IP and data link layer protocol headers to each segment.

#### UDP Fragmentation Offload (UFO)
Uses the UDP protocol to send large packets. Uses the NIC to handle IP fragmentation into MTU sized packets for large UDP datagrams.

#### Generic Segmentation Offload (GSO)
Uses the TCP or UDP protocol to send large packets. If the NIC cannot handle segmentation/fragmentation, GSO performs the same operations, bypassing the NIC hardware. This is achieved by delaying segmentation until as late as possible, for example, when the packet is processed by the device driver.

#### Large Receive Offload (LRO)
Uses the TCP protocol. All incoming packets are re-segmented as they are received, reducing the number of segments the system has to process. They can be merged either in the driver or using the NIC. A problem with LRO is that it tends to resegment all incoming packets, often ignoring differences in headers and other information which can cause errors. It is generally not possible to use LRO when IP forwarding is enabled. LRO in combination with IP forwarding can lead to checksum errors. Forwarding is enabled if /proc/sys/net/ipv4/ip_forward is set to 1.

#### Generic Receive Offload (GRO)
Uses either the TCP or UDP protocols. GRO is more rigorous than LRO when resegmenting packets. For example it checks the MAC headers of each packet, which must match, only a limited number of TCP or IP headers can be different, and the TCP timestamps must match. Resegmenting can be handled by either the NIC or the GSO code.

#### Using NIC Offloads
Offloads should be used on high speed systems that transmit or receive large amounts of data and favor throughput over latency. Because using offloads greatly increases the capacity of the driver queue, latency can become an issue. An example of this would be a system transferring large amounts of data using large packet sizes, but is also running lots of interactive applications. Because interactive applications send small packets at timed intervals there is a very real risk that those packets may become 'trapped' in the buffer while larger packets in front of them are processed, causing unacceptable latency.
To check current offload settings use the ethtool command. Some device settings may be listed as fixed, meaning they cannot be changed.

Command syntax:
```
ethtool -k ethernet_device_name
```

Example 8.1. Check Current Offload Settings
```
$ ethtool -k em1
Features for em1:
rx-checksumming: on
tx-checksumming: on
tx-checksum-ipv4: off [fixed]
tx-checksum-ip-generic: on
tx-checksum-ipv6: off [fixed]
tx-checksum-fcoe-crc: off [fixed]
tx-checksum-sctp: off [fixed]
scatter-gather: on
tx-scatter-gather: on
tx-scatter-gather-fraglist: off [fixed]
tcp-segmentation-offload: on
tx-tcp-segmentation: on
tx-tcp-ecn-segmentation: off [fixed]
tx-tcp6-segmentation: on
udp-fragmentation-offload: off [fixed]
generic-segmentation-offload: on
generic-receive-offload: on
large-receive-offload: off [fixed]
rx-vlan-offload: on
tx-vlan-offload: on
ntuple-filters: off [fixed]
receive-hashing: on
highdma: on [fixed]
rx-vlan-filter: off [fixed]
vlan-challenged: off [fixed]
tx-lockless: off [fixed]
netns-local: off [fixed]
tx-gso-robust: off [fixed]
tx-fcoe-segmentation: off [fixed]
tx-gre-segmentation: off [fixed]
tx-ipip-segmentation: off [fixed]
tx-sit-segmentation: off [fixed]
tx-udp_tnl-segmentation: off [fixed]
tx-mpls-segmentation: off [fixed]
fcoe-mtu: off [fixed]
tx-nocache-copy: off
loopback: off [fixed]
rx-fcs: off
rx-all: off
tx-vlan-stag-hw-insert: off [fixed]
rx-vlan-stag-hw-parse: off [fixed]
rx-vlan-stag-filter: off [fixed]
l2-fwd-offload: off [fixed]
busy-poll: off [fixed]
```

In `ethtool`, the term "offload" refers to various network offloading features supported by network interface cards (NICs). These features allow certain network processing tasks to be offloaded from the CPU to the NIC, which can improve overall system performance by freeing up CPU resources and reducing latency. 

### Common Offload Features in `ethtool`

Here are some of the most common offload features that you can manage with `ethtool`:

#### 1. TCP Segmentation Offload (TSO)
TSO allows the NIC to handle the segmentation of large TCP packets into smaller ones that fit the MTU (Maximum Transmission Unit) of the network, reducing the CPU load associated with this task.

#### 2. Generic Segmentation Offload (GSO)
GSO is similar to TSO but works with various types of traffic, not just TCP. It allows the NIC to segment large packets from the host into smaller packets.

#### 3. Generic Receive Offload (GRO)
GRO enables the NIC to merge multiple incoming packets from the same TCP stream into larger buffers before passing them up the stack, reducing CPU usage and improving performance.

#### 4. Large Receive Offload (LRO)
LRO aggregates incoming packets into larger ones, reducing the number of packets the CPU needs to process. This is mostly used in high-performance network environments.

#### 5. Receive Side Scaling (RSS)
RSS allows the NIC to distribute incoming network traffic across multiple CPU cores, improving parallelism and performance on multi-core systems.

#### 6. Checksum Offload
Checksum offload allows the NIC to handle the computation and verification of checksums for TCP/UDP packets, offloading this task from the CPU.

### Using `ethtool` to Manage Offload Features

#### Display Current Offload Settings

To display the current offload settings for a network interface, you can use the following command:

```bash
ethtool -k <interface>
```

**Example:**

```bash
ethtool -k eth0
```

This command will display the offload settings for the `eth0` interface.

#### Enable or Disable Offload Features

To enable or disable a specific offload feature, you can use the `-K` option followed by the feature name and its desired state (`on` or `off`).

**Syntax:**

```bash
ethtool -K <interface> <feature> <state>
```

**Examples:**

- To enable TSO on `eth0`:

  ```bash
  ethtool -K eth0 tso on
  ```

- To disable GRO on `eth0`:

  ```bash
  ethtool -K eth0 gro off
  ```

### Conclusion
Understanding and managing offload features with `ethtool` can help optimize network performance by leveraging the capabilities of your NIC. By offloading tasks such as packet segmentation, checksum computation, and traffic distribution to the NIC, you can reduce CPU load and improve the efficiency and speed of your network operations.

* rx - receive (RX) checksumming
* tx - transmit (TX) checksumming
* sg - scatter-gather
* tso - TCP segmentation offload
* ufo - UDP fragmentation offload
* gso - generic segmentation offload
* gro - generic receive offload
* lro - large receive offload
* rxvlan - receive (RX) VLAN acceleration
* txvlan - transmit (TX) VLAN acceleration
* ntuple - receive (RX) ntuple filters and actions
* rxhash - receive hashing offload

## Command-Line Network Monitoring Tools
### Link
* [Best Tools to Monitor Network Bandwidth on a Linux Server](https://phoenixnap.com/kb/linux-network-bandwidth-monitor-traffic)
* [How to display network traffic in the terminal?](https://askubuntu.com/questions/257263/how-to-display-network-traffic-in-the-terminal)

### bmon - Bandwidth Monitor and Rate Estimator
bmon monitors bandwidth utilization, along with keeping a running rate estimate. It provides usage for each device individually, allowing users to track bandwidth across multiple network adapters.

bmon captures network statistics and provides a human-friendly output. Another positive feature is that the output includes a graph, providing bandwidth usage at a glance.

```
sudo apt install bmon
```

![](https://i.sstatic.net/WqOh6.png)


### vnStat - Network Traffic Monitor
vnStat works by running a daemon that captures and records bandwidth data. It reads data from the kernel to stay light on resource usage. The tool can run in real-time by specifying the -l option. The key feature of vnStat are persistent records - as the daemon runs, it collects and stores bandwidth usage logs.

The vnstat command can be used to display usage statistics, and it is best suited for statistical reporting. To install vnStat, run:
```
sudo apt install vnstat
```

![](https://phoenixnap.com/kb/wp-content/uploads/2022/12/vnstat-interface.png)

## dmesg
dmesg is a command on Linux systems, including Ubuntu, used to examine and manage the kernel ring buffer. This buffer stores messages related to the system's kernel activities, such as hardware initialization, driver messages, and system events. These messages are crucial for diagnosing and troubleshooting hardware and driver-related issues.

Here's an in-depth look at dmesg, including its usage, typical outputs, and common options:

### Overview of dmesg
Purpose: To display system messages that are typically logged by the kernel. This includes boot messages, hardware initialization, driver information, and errors.
Location: dmesg reads from the kernel ring buffer, which is also accessible at /var/log/dmesg.
Basic Usage
The simplest way to use dmesg is to run it without any arguments:

This outputs the entire kernel message buffer to the terminal. Given the large amount of information, it’s often useful to use tools like less to navigate through the output:
```
dmesg | less
```

Example Output:
```
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Linux version 5.15.0-50-generic (buildd@lcy02-amd64-003) (gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #55-Ubuntu SMP Tue Sep 13 19:47:35 UTC 2022 (Ubuntu 5.15.0-50.55-generic 5.15.39)
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-50-generic root=UUID=e6f1edc2-0c7f-4e1f-9c5a-dfcf6b96f40d ro quiet splash
...
```

### Filtering Messages by Keywords
You can search for specific messages using grep:
```
dmesg | grep <keyword>
```

Example: To find all messages related to the eth0 network interface:
```
dmesg | grep eth0
```

### Summary
dmesg is a powerful tool for viewing kernel messages in Linux, providing insights into hardware, drivers, and system events.
Typical Usage: Includes filtering messages, following live logs, and decoding timestamps and log levels.
Practical Applications: Useful for diagnosing hardware issues, driver problems, network troubles, and more.
Understanding and utilizing dmesg effectively can be crucial for system administrators and anyone involved in maintaining Linux systems. It provides a wealth of information directly from the kernel, making it an invaluable tool for troubleshooting and system analysis

The `ulimit -n` command in Unix-based systems, such as Linux, is used to display or set the maximum number of open file descriptors a process can have. This limit is important for applications that open many files or network connections simultaneously, such as web servers and database servers.

### Usage

- **Display current limit:**
  ```sh
  ulimit -n
  ```
  This command will print the current limit of open file descriptors for the shell session.

- **Set a new limit:**
  ```sh
  ulimit -n <new_limit>
  ```
  For example, to set the limit to 4096:
  ```sh
  ulimit -n 4096
  ```

### Types of Limits

- **Soft limit:** The value that the kernel enforces for the corresponding resource. This limit can be increased by a non-privileged user up to the hard limit.
- **Hard limit:** The ceiling for the soft limit. This limit can only be increased by the superuser (root).

### Example

To display the current limit:
```sh
ulimit -n
```

To set the limit to 4096:
```sh
ulimit -n 4096
```

### Persistent Changes

To make the changes persistent across reboots, you need to modify configuration files such as `/etc/security/limits.conf` or other relevant system-specific files.

For example, you can add the following lines to `/etc/security/limits.conf`:
```
*               soft    nofile          4096
*               hard    nofile          8192
```

Then, apply the changes by logging out and logging back in, or by restarting the system.

Understanding and properly configuring `ulimit -n` is crucial for ensuring that applications running on your system have the necessary resources to handle the required number of open files and connections.




# Voice Over IP
## Chapter 1
## Introduction 
تصمیمی که اکثر شرکت ها با آن روبرو هستند این نیست که آیا VoIP را به کار خواهند گرفت یا نه، بلکه این است که چه زمانی. نیاز به فارغ التحصیلان برنامه های ارتباطی و متخصصان شبکه وجود دارد که درک عمیقی از توپولوژی ها و پروتکل های صوتی مبتنی بر IP داشته باشند.

این VoIP نشان دهنده یک تغییر کامل در تقریباً همه چیز در مسیر ارتباطات است. در مورد تنها چیزی که ثابت می ماند اندازه و شکل تلفن رومیزی است. اکثر افرادی که با VoIP درگیر هستند موافق هستند که این تغییرات بسیار مثبت به خصوص برای مصرف کنندگان است.

در VoIP با عباراتی مانند اینترنت تلفن، تلفن کامپیوتر و حتی تلفن ویندوز نیز شناخته می شود. تلاش برای تعریف VoIP شامل توضیح نحوه اجرای تماس های تلفنی از طریق اینترنت مانند Vonage یا Skype است.

 زمانی که ارائه‌دهندگان خدمات اینترنت (ISP) به گزینه‌های پرسرعت مانند خطوط مشترک دیجیتال و کابل منتقل شدند. اما تلفن شما همچنان توسط شرکت  local exchange carrier ارائه شده است. با ظرفیت بیشتر برای اتصالات داده، شخصی به این ایده رسید که ممکن است امکان برقراری تماس تلفنی از طریق یک شبکه مبتنی بر پروتکل اینترنت (IP) وجود داشته باشد. 

 برخی از اولین تلاش ها شامل اتصالات point-to-point یا websites بود که به عنوان سرور تماس متمرکز کار می کردند
 
تماس‌هایی از این دست با مشکلات کیفیت و فقدان کامل پشتیبانی صنعتی مواجه بودند.

اما ایده از بین رفت. و چه ایده ای بود که تماس های تلفنی رایگان از طریق اینترنت بود؟ این یک رویای طلایی برای برخی (مصرف کنندگان) و یک کابوس برای برخی دیگر بود. یعنی ارائه دهندگان

از این گذشته، شرکت های تلفن بدون رقابت زیاد، پول زیادی به دست آوردند. مدت زیادی نگذشته بود که سرویس هایی مانند Vonage، Skype ظاهر شدند.

برخی از این services طرح های تماس را با کمتر از نصف قیمت traditional carriers ارائه می دهند برخی از آنها، به ویژه اسکایپ، یکی از اهداف خود را از کار انداختن شرکت های تلفن داشتند

کیفیت درک شده می تواند کمی متفاوت باشد، اما شکی نیست که انحصار شرکت های تلفن سنتی شکسته شده است و این صنعت به دنبال کارمندانی است که دانش VoIP را در مجموعه مهارت های خود داشته باشند.

## What Is VoIP?
برای شروع، VoIP دقیقاً همان چیزی است که نام آن نشان دهنده ارسال صدا (و ویدیو) از طریق یک شبکه مبتنی بر IP است

این کاملاً متفاوت از شبکه تلفن عمومی سوئیچ مدار است (circuit-switched public telephone network) که من با آن بزرگ شدم در circuit switching منابع را به هر تماس اختصاص می دهد.

شبکه های IP به صورت بسته سوئیچ می شوند و هر بسته ارسالی نیمه مستقل است، هدر IP خود را دارد و به طور جداگانه توسط روترها ارسال می شود. فصل های 3 تا 7 ما را با جزئیات فنی در مورد عملکرد یک سیستم VoIP آشنا می کند، اما معلوم می شود که درک VoIP و انگیزه آن اغلب به درک تأثیرات VoIP است که می تواند قابل توجه باشد.

### What is PSTN? 
**PSTN is short for Public Switched Telephone Network**. PSTN refers to the traditional telephone system used for voice-oriented communications. It consists of multiple interconnected carriers to reliably connect people through standard phone numbers. Public Switched Telephone Network
This telephone network is known as analog, landlines, Plain Old Telephone Service (POTS), or fixed lines. This system has been in general use since the late 1800s. Using underground copper wires and circuit-switching, this legacy service has provided businesses and households with a reliable means to communicate with anyone worldwide for generations.

![](https://www.nextiva.com/blog/wp-content/uploads/sites/2/2023/07/telephone-lines-power-lines.jpeg)

### PSTN History & Background
The roots of PSTN can be traced back to the late 1800s when inventors like Alexander Graham Bell and Elisha Gray released the first usable telephone systems. These early phones used copper wires and could only communicate point-to-point.

Manual switchboards caught on in the late 1800s and early 1900s. These exchanges allowed operators to plug and unplug cords to connect calls manually.

A major change came in the late 20th century with automated switching, which eliminated the need for manual call handling. This is when the traditional PSTN came into play and later spread worldwide. Undersea cables and satellite communications further facilitated international voice communications

![](https://www.nextiva.com/blog/wp-content/uploads/sites/2/2023/07/telephone-system-122820_1280.jpg)

Despite all the innovations in PSTN, it remained an old, sluggish, and limited technology. The need for better communication, especially in the business environment, gave way to VoIP phones

PSTN phones are widely used and still accepted as a standard form of communication owing to their reliability and worldwide infrastructure. However, they’ve seen a steady decline over the last decade.

In fact, there are currently just 862 million fixed-line telephone subscriptions in use worldwide, the lowest this century. 

Many telecoms have gradually replaced outdated PSTN infrastructure with modern IP-based networks capable of handling both voice and data traffic.

![](https://www.nextiva.com/blog/wp-content/uploads/sites/2/2023/07/PSTN-usage-worldwide-2022-chart.png)

### How PSTN Works Today
Think of a PSTN as a combination of worldwide telephone networks, including telephone lines, fiber optic cables, switching centers, cellular networks, satellites, and cable systems. PSTN helps telephones communicate with each other.

Put simply, when you dial a phone number, your call moves through the network to reach its destination – and two phones connect. To fully understand how Plain Old Telephone Service (POTS) works, consider what happens when you dial a number from your phone.

### From telephone handset to Central Office
Your telephone set converts your call (sound waves) into electrical signals and transmits them over network cables to a nearby exchange or terminal. The terminal collects these signals and determines where your voice (converted into electrical signals) goes next.

### Central Office call routing
The call next goes to a tandem office (a regional hub that routes calls to distant central offices) or to a central office (for local calls). The central office routes the call through a fiber optic cable that converts the electrical signals into light pulses.

### From the Central Office to the terminating number 
The relevant center office picks up the light pulses, converts them into electrical signals, and sends them to the target terminal. The destination terminal forwards the call through sound waves to the appropriate telephone number.

It’s natural to be confused about how PSTN works behind the scenes. Remember that it takes a few seconds for your call to reach its destination via fiber optic cables and a global network of switches. It’s like changing buses to reach your final destination, only faster.

Nationwide calling is the norm, thanks to interconnected telephone networks. But since the lines were installed, telecom providers have since become pioneers in data networks, which operate faster and carry VoIP and other communication technologies.

### PSTN Architecture
PSTNs are all about switching, which forms the backbone of traditional telephone networks. When a call is made, switches create a wired connection between two phones, maintaining it for as long as the call lasts.

![](https://www.nextiva.com/blog/wp-content/uploads/sites/2/2023/07/How-POTS-Works.png)

Here are the four main elements that make up the PSTN architecture.

1. The local exchange: A local exchange – consisting of one or more exchanges – connects subscribers to a PSTN line. Also known as a central office or a switching exchange, a telephone exchange can have up to 10,000 lines. All phones are connected to the local exchange in a specific area. 

2. The exchange identifies the number dialed to route the call to the correct destination.

3. The tandem office: Also known as a junction network, a tandem office serves a large geographic area with multiple local exchanges while managing switches between local exchanges. Let’s say you dial the number of a client living in the same city but in another suburb. In this case, your call routes to a tandem office from your local exchange. The tandem office forwards the signal to the local exchange closest to your client’s location.

4. The toll office: Every national long-distance switching takes place here. A toll office is connected to all tandem offices. For instance, if you dial a branch of your office in another city, your call will go through a toll office.
The international gateway: International gateways manage international call switching, routing domestic calls to the appropriate countries.

### Private Branch Exchange (PBX)
Large companies with 40 or more employees typically opt for a Private Branch Exchange (PBX).

One of the types of PBX systems connects calls over the PSTN. Generally, PSTN is more used in residential applications and PBX systems in business environments. It offers call transfer, call conferencing, auto attendant, voicemail, call holding, and more business-specific features.

Since a PBX comes with hubs, switches, phone adapters, routers, and several telephone sets, it costs more. Most businesses use PBX phone systems because they’re easier to use. However, installing and managing them is expensive. Actual costs may vary depending on the number of features you want and the PBX’s complexity.

### ترجمه
می‌دانیم **PSTN مخفف عبارت Public Switched Telephone Network** است. PSTN به سیستم تلفن سنتی مورد استفاده برای ارتباطات صوتی اشاره دارد. این شامل چندین حامل متصل به هم است تا افراد را به طور قابل اعتماد از طریق شماره تلفن های استاندارد متصل کند. شبکه تلفن سوئیچ شده عمومی
این شبکه تلفنی با نام های آنالوگ، خطوط ثابت، خدمات تلفن قدیمی ساده (POTS) یا خطوط ثابت شناخته می شود. این سیستم از اواخر دهه 1800 مورد استفاده عمومی قرار گرفت. این سرویس قدیمی با استفاده از سیم‌های مسی زیرزمینی و سوئیچینگ مدار، ابزار قابل اعتمادی را برای کسب‌وکارها و خانوارها برای برقراری ارتباط با هر کسی در سراسر جهان برای نسل‌ها فراهم کرده است.

ریشه PSTN را می توان به اواخر دهه 1800 ردیابی کرد، زمانی که مخترعانی مانند الکساندر گراهام بل و الیشا گری اولین سیستم های تلفن قابل استفاده را منتشر کردند. این تلفن های اولیه از سیم های مسی استفاده می کردند و فقط می توانستند نقطه به نقطه ارتباط برقرار کنند.

تابلوهای دستی در اواخر دهه 1800 و اوایل دهه 1900 مورد استفاده قرار گرفتند. این مبادلات به اپراتورها اجازه می‌داد تا سیم‌ها را برای اتصال دستی تماس‌ها وصل و جدا کنند.

یک تغییر عمده در اواخر قرن بیستم با سوئیچینگ خودکار رخ داد که نیاز به مدیریت تماس دستی را از بین برد. این زمانی بود که PSTN سنتی وارد بازی شد و بعداً در سراسر جهان گسترش یافت. کابل های زیردریایی و ارتباطات ماهواره ای بیشتر ارتباطات صوتی بین المللی را تسهیل کردند

علیرغم تمام نوآوری ها در PSTN، این یک فناوری قدیمی، کند و محدود باقی ماند. نیاز به ارتباطات بهتر به خصوص در محیط کسب و کار جای خود را به تلفن های VoIP داد

تلفن‌های PSTN به دلیل قابلیت اطمینان و زیرساخت جهانی آن‌ها به‌طور گسترده مورد استفاده قرار می‌گیرند و همچنان به عنوان یک شکل استاندارد ارتباطی پذیرفته می‌شوند. با این حال، آنها در دهه گذشته شاهد کاهش مداوم بوده اند.

در واقع، در حال حاضر تنها 862 میلیون اشتراک تلفن ثابت در سراسر جهان در حال استفاده است که کمترین میزان در قرن حاضر است.

بسیاری از مخابرات به تدریج زیرساخت های قدیمی PSTN را با شبکه های مبتنی بر IP مدرن که قادر به مدیریت ترافیک صوتی و داده هستند، جایگزین کرده اند.

PSTN را به عنوان ترکیبی از شبکه های تلفن در سراسر جهان، از جمله خطوط تلفن، کابل های فیبر نوری، مراکز سوئیچینگ، شبکه های سلولی، ماهواره ها و سیستم های کابلی در نظر بگیرید. PSTN به تلفن ها کمک می کند تا با یکدیگر ارتباط برقرار کنند.

به زبان ساده، وقتی شماره تلفنی را شماره گیری می کنید، تماس شما از طریق شبکه حرکت می کند تا به مقصد برسد - و دو تلفن به هم متصل می شوند. برای درک کامل نحوه عملکرد سرویس تلفن قدیمی ساده (POTS)، در نظر بگیرید که وقتی شماره ای را از تلفن خود می گیرید چه اتفاقی می افتد.

مجموعه تلفن شما تماس شما (امواج صوتی) را به سیگنال های الکتریکی تبدیل می کند و آنها را از طریق کابل های شبکه به یک سانترال یا ترمینال نزدیک منتقل می کند. ترمینال این سیگنال‌ها را جمع‌آوری می‌کند و تعیین می‌کند که صدای شما (تبدیل به سیگنال‌های الکتریکی) به کجا برسد.

تماس بعدی به یک دفتر پشت سر هم (یک مرکز منطقه ای که تماس ها را به دفاتر مرکزی دوردست هدایت می کند) یا به یک دفتر مرکزی (برای تماس های محلی) می رود. دفتر مرکزی تماس را از طریق یک کابل فیبر نوری هدایت می کند که سیگنال های الکتریکی را به پالس های نور تبدیل می کند.

دفتر مرکز مربوطه پالس های نور را دریافت می کند، آنها را به سیگنال های الکتریکی تبدیل می کند و به ترمینال مورد نظر می فرستد. ترمینال مقصد تماس را از طریق امواج صوتی به شماره تلفن مناسب ارسال می کند.

طبیعی است که در مورد نحوه عملکرد PSTN در پشت صحنه سردرگم شوید. به یاد داشته باشید که چند ثانیه طول می کشد تا تماس شما از طریق کابل های فیبر نوری و شبکه جهانی سوئیچ ها به مقصد برسد. مانند تعویض اتوبوس برای رسیدن به مقصد نهایی، فقط سریعتر.

به لطف شبکه های تلفن متصل به هم، تماس در سراسر کشور عادی است. اما از زمانی که خطوط نصب شدند، ارائه دهندگان مخابراتی از آن زمان پیشگام در شبکه های داده شده اند که سریعتر کار می کنند و VoIP و سایر فناوری های ارتباطی را حمل می کنند.

PSTN ها همه در مورد سوئیچینگ هستند که ستون فقرات شبکه های تلفن سنتی را تشکیل می دهند. هنگامی که تماس برقرار می شود، سوئیچ ها یک اتصال سیمی بین دو تلفن ایجاد می کنند و آن را تا زمانی که تماس ادامه دارد حفظ می کنند.

در اینجا چهار عنصر اصلی تشکیل دهنده معماری PSTN آورده شده است.

صرافی محلی: یک صرافی محلی – متشکل از یک یا چند صرافی – مشترکین را به یک خط PSTN متصل می کند. یک مرکز تلفن که به عنوان دفتر مرکزی یا سانترال سوئیچینگ نیز شناخته می شود، می تواند تا 10000 خط داشته باشد. همه تلفن ها در یک منطقه خاص به صرافی محلی متصل هستند. صرافی شماره تماس گرفته شده را برای هدایت تماس به مقصد صحیح شناسایی می کند.

دفتر پشت سر هم: همچنین به عنوان یک شبکه اتصال شناخته می شود، یک دفتر پشت سر هم به یک منطقه جغرافیایی بزرگ با چندین صرافی محلی خدمات می دهد در حالی که سوئیچ ها را بین صرافی های محلی مدیریت می کند. فرض کنید شماره مشتری را که در همان شهر زندگی می کند اما در حومه دیگری زندگی می کند، شماره گیری می کنید. در این مورد، تماس شما از صرافی محلی شما به یک دفتر پشت سر هم می رسد. دفتر پشت سر هم سیگنال را به صرافی محلی نزدیک به محل مشتری شما ارسال می کند.

اداره عوارض: همه جابجایی مسافت های طولانی در اینجا انجام می شود. یک دفتر عوارض به تمام دفاتر پشت سر هم متصل است. به عنوان مثال، اگر با شعبه ای از دفتر خود در شهر دیگری تماس بگیرید، تماس شما از طریق دفتر عوارض انجام می شود.

دروازه بین المللی: دروازه های بین المللی سوئیچینگ تماس های بین المللی را مدیریت می کنند و تماس های داخلی را به کشورهای مناسب هدایت می کنند.

شرکت های بزرگ با 40 کارمند یا بیشتر معمولاً صرافی شعبه خصوصی (PBX) را انتخاب می کنند.

یکی از انواع سیستم های PBX تماس ها را از طریق PSTN متصل می کند. به طور کلی، PSTN بیشتر در برنامه های مسکونی و سیستم های PBX در محیط های تجاری استفاده می شود. این برنامه انتقال تماس، کنفرانس تماس، مهماندار خودکار، پست صوتی، برگزاری تماس و ویژگی‌های بیشتر کسب و کار را ارائه می‌دهد.

از آنجایی که یک PBX با هاب ها، سوئیچ ها، آداپتورهای تلفن، روترها و چندین دستگاه تلفن همراه است، هزینه بیشتری دارد. اکثر مشاغل از سیستم های تلفن PBX استفاده می کنند زیرا استفاده از آنها آسان تر است. با این حال، نصب و مدیریت آنها گران است. هزینه های واقعی ممکن است بسته به تعداد ویژگی هایی که می خواهید و پیچیدگی سانترال متفاوت باشد.


------------------------

## What Is VoIP?
سیستم های VoIP بومی بسیاری از آنچه که تلفن سنتی در نظر گرفته می شود را از بین می برند.
سیستمی مانند آنچه در شکل 1-1 نشان داده شده است شامل سیگنال های کنترلی زیادی برای انجام وظایف مختلف مورد نیاز است.
به عنوان مثال، شماره تلفن ها شماره گیری می شوند و آن شماره ها معنی دارند. صداها یا آهنگ هایی مانند مشغول و غیرفعال نیز پیام هایی هستند
جستجوی پایگاه داده برای شماره‌های 411 یا 800 به پیام‌های اضافی مانند خدماتی مانند شناسه تماس‌گیرنده، ویژگی‌های پیشرفته و مسیریابی تماس نیاز دارد. این سیگنال‌ها بین دستگاه‌هایی مانند سانترال خصوصی (PBX) قبل از هر گونه ارتباط انسانی ارسال می‌شوند.

در VoIP تمام این پیام های سیگنالینگ را می گیرد و آنها را در بسته های IP قرار می دهد. در حالی که تلفن های سنتی را می توان همراه با سیستم VoIP استفاده کرد، اغلب اینطور نیست. پس از یک پروژه آزمایشی، شرکت‌هایی که یک سیستم VoIP را پیاده‌سازی می‌کنند معمولاً مایلند مجموعه واحدی از تجهیزات را به منظور ساده‌سازی پشتیبانی و نگهداری راه‌اندازی کنند.
این نیز هزینه را کاهش می دهد. پس از این اتفاق، نقاط پایانی دیگر به عنوان تلفن نامیده نمی شوند، فقط تلفن های VoIP یا اترنت. نام PBX حفظ شده است، اگرچه در حال حاضر IP PBX نامیده می شود، که در واقع به این معنی است که سروری است که روی رایانه کار می کند.

همچنین شایان ذکر است که از آنجایی که پروتکل اینترنت می تواند تقریباً روی هر نوع معماری ارتباطی لایه پایین اجرا شود،

زبان های صحبت شده توسط دو سیستم کاملاً متفاوت است، سیستم های سنتی از سیستم سیگنالینگ 7 (SS7) و شبکه های VoIP از پروتکل کنترل انتقال/پروتکل اینترنت یا TCP/IP استفاده می کنند.

برای پایان دادن به این بخش، اجازه دهید نگاهی گذرا به مجموعه مهارت های مورد نیاز برای اجرای دو سیستم بیندازیم، مقایسه ای کنار هم از توپولوژی ها و فهرست کوتاهی از مهارت های اساسی مورد نیاز برای کار بر روی هر کدام را نشان می دهد. در نگاه اول، توپولوژی‌ها چندان متفاوت به نظر نمی‌رسند، به خصوص که ترسیم شده‌اند. اما، تجهیزات مورد استفاده در هر یک، در حالی که عملکردهای یکسانی را انجام می دهند، این عملکردها را متفاوت انجام می دهند و در واقع با استفاده از مجموعه ای کاملاً متفاوت از پروتکل ها عمل می کنند.

یک نمودار ون که مهارت‌ها را برای هر توپولوژی مقایسه می‌کند، تلاقی بسیار کمی پیدا می‌کند. با پیروی از این خط فکری نسبت به فعالیت‌های استخدام یا آموزش در یک سازمان، باید به این نتیجه برسیم که تقاضای متفاوتی برای فردی آگاه در موضوعات تلفن سنتی در مقایسه با شخصی که دارای پیشینه شبکه داده است وجود دارد. هنگامی که با نیاز به پشتیبانی از یک زیرساخت VoIP مواجه می شوید، این دو فرد باید چه چیزی یاد بگیرند؟ اگر استقرار معمولی را در سمت مصرف کننده در نظر بگیریم، شخص تلفن سنتی ممکن است اطلاعاتی در مورد برنامه های شماره گیری، مسیریابی تماس، T-1 ها و ویژگی ها داشته باشد اما عملکرد یک شبکه بی سیم سیمی مبتنی بر IP را درک نکند.

شخصی که دارای پیشینه شبکه داده (اترنت، 802.11، IP، TCP، UDP) باشد، متوجه می شود که VoIP به حوزه تخصص آنها مهاجرت کرده است. آنها دانشی در مورد عملکرد یک سیستم تلفنی ندارند. با این حال، بسیاری از مهارت های تلفنی لازم نیست. به عنوان مثال، جابجایی ها یا اضافه ها و تغییرات صرفاً مربوط به جابجایی تلفن و به دست آوردن یک آدرس IP جدید است. بحث بر سر اینکه کدام فردی برای انتقال زمان آسان تری خواهد داشت در هر دو طرف نکاتی دارد، اما شکی نیست که هر طرف چیزی را از دست داده است. این امر تا حدودی با گسترش خدمات صوتی و موقعیت مکانی مبتنی بر IP، مانند خدمات ارائه شده توسط Google، کاهش می یابد. به نظر می رسد که همه ما چه بلد باشیم چه ندانیم در حال تبدیل شدن به یک VoIP هستیم. 

## Real-time Versus Nonreal-time Data
زمانی که فایلی را دانلود می کنید، تاخیرها ناخوشایند و گاهی آزاردهنده هستند، اما به انتقال آسیب نمی رسانند یا مانع از آن نمی شوند. هنگام بازدید از یک وب سایت، اگر صفحه به کندی بارگیری می شود، مایلیم چند ثانیه قبل از حرکت به آن فرصت دهیم.
اگر برخی از تصاویر صفحه ظاهر شوند، ممکن است بیشتر منتظر بمانیم این مثال‌ها شامل انتقال داده‌های غیرهمزمان هستند از نقطه نظر پروتکل، پروتکل کنترل انتقال (TCP) برای مدیریت اتصال استفاده می‌شود و تمام بسته‌ها (یا حداقل بایت‌ها) از طریق شماره‌های دنباله مرتبط کنترل می‌شوند. داده های گم شده یا تأخیر برای اطمینان از اینکه گیرنده همه چیز را در اختیار دارد مجدداً ارسال می شود.

یک بسته TCP را با شماره های دنباله ای دایره شده به تصویر می کشد. دو نقطه پایانی در اتصال نه تنها با داده های ارسال شده (اعداد دنباله ای) ارتباط برقرار می کنند، بلکه با شماره تأیید، تکه بعدی داده مورد انتظار را نیز نشان می دهند.

![](https://packetlife.net/media/blog/attachments/429/tcp_flow.png)

حتی اگر بایت های ارسال شده از طریق شماره های دنباله ای به دقت نظارت می شوند، زمان لازم برای دریافت آنها نیست. بنابراین، بسته ها ممکن است با تاخیر یا حتی زودتر انجام شوند ایده مهم این است که کاربر و سیستم تا حدودی تاخیر را می بخشند، حداقل تا زمانی که تاخیر بسیار زیاد شود بسته گم شده در نظر گرفته می شود. با TCP، اتصال به شدت کنترل می شود و بدون مجموعه کاملی از بسته ها ادامه نمی یابد. اکثر برنامه های کاربردی مبتنی بر TCP no real time هستند. از دیدگاه کاربر، تاخیر در برنامه‌ها آزاردهنده است اما منع نمی‌کند. شکایت می کنیم اما منتظریم

داده های real-time دقیقا برعکس است. real-time به طور کلی به چیزی اشاره دارد که به زمان حساس است تاخیری که ممکن است برای داده‌های no real-time قابل قبول باشد، می‌تواند عملکرد و تجربه کاربر را تا حدی کاهش دهد که سرویس یا اتصال غیرقابل استفاده باشد. 

صدا یک مثال کامل است. یک مکالمه تلفنی را تصور کنید که در آن هر شرکت کننده باید قبل از دریافت پاسخ به اظهارات یا سوالات، یک یا دو ثانیه صبر کند. برخلاف انتقال فایل، ما نمی‌خواهیم کلمه گمشده برگردانده شود. اتصال با تأخیر بیشتر در انتظار بسته گم شده (از دست دادن بسته) یا ممکن است در مکان نامناسبی دوباره وارد مکالمه شود در نهایت، اگر بسته‌ها با نرخی متفاوت (jitter) وارد شوند، ممکن است منجر به عملکرد غیرقابل پیش‌بینی شود. بنابراین، میل این است که تأخیر، از دست دادن بسته‌ها و جیتر را در مقادیر بسیار پایین‌تری در اتصالات داده بلادرنگ حفظ کنیم.از نقطه نظر پروتکل، پروتکل دیتاگرام کاربر (UDP) معمولاً مستقر می شود زیرا ما نمی خواهیم ارسال مجدد یا بازگرداندن داده های از دست رفته را داشته باشیم. UDP مقادیر توالی یا تصدیق را پیگیری نمی کند.

نمونه ای از بسته UDP را ارائه می دهد. علاوه بر شماره پورت، هدر حاوی هیچ اطلاعاتی نیست که ممکن است برای اتصال مهم باشد در واقع، UDP گاهی اوقات به عنوان یک پروتکل آتش و فراموش در نظر گرفته می شود زیرا هنگامی که بسته از فرستنده خارج می شود، ما به هیچ چیز دیگری در مورد آن فکر نمی کنیم. اگر بسته گم شود، نیازی به پاسخگویی نیست. بسیاری از برنامه‌های بی‌درنگ مانند بازی‌ها و ویدیوها از UDP استفاده می‌کنند، زیرا توسعه‌دهندگان نمی‌خواهند خود را در مورد بسته‌های گمشده یا تأخیر نگران کنند. در صورت انجام این کار، ممکن است عملکرد برنامه آسیب ببیند. بسته در همچنین یک پیام پروتکل حمل و نقل بلادرنگ (RTP) را کپسوله می کند. RTP توسط استقرار VoIP برای انتقال داده های صوتی و تصویری استفاده می شود.

## Why Change to VoIP?
با وجود این همه اختلال، چرا باید به Voice over IP تغییر وضعیت دهیم؟ احتمالاً بزرگترین دلیل برای اتخاذ معماری مبتنی بر VoIP پول است مشتریان به جای پرداخت هزینه برای یک سری خطوط تلفن یا مدار، فقط باید برای اتصال داده پرداخت کنند. این به این دلیل است که ترافیک VoIP در بسته های IP منتقل می شود که می توانند اتصال داده را به اشتراک بگذارند علاوه بر این، بسته‌های IP می‌توانند به هر مقصدی که به اینترنت متصل است، جریان پیدا کنند و هزینه‌های عوارض بسیار کاهش می‌یابد معماری‌های VoIP می‌توانند هزینه‌های خود را در مدت زمان نسبتاً کوتاهی بپردازند و بازده سرمایه‌گذاری یا ROI خوبی را به شرکت بدهند.

چندین فرصت دیگر، کمتر آشکار، برای صرفه جویی در هزینه با راه حل VoIP مبتنی بر IP وجود دارد. شبکه‌هایی که VoIP را مستقر می‌کنند، اغلب شبکه‌های همگرا نامیده می‌شوند، زیرا آنها شبکه داده را به اشتراک می‌گذارند. پس از نصب شبکه داده، تمام دستگاه های دیگر به آن متصل می شوند. این در واقع به سیستم‌های دیگر مانند سیستم‌های گرمایش و سرمایش، امنیت و دوربین‌های ویدئویی نیز گسترش می‌یابد. تأثیر این تغییر به سختی قابل برآورد است:

این بدان معنا نیست که تغییر به VoIP اجزای تخصصی یا گران قیمت را حذف می کند. در واقع، برخی از ساختارهای قیمت گذاری یا هزینه های مجوز برای تلفن های VoIP یا PBX بسیار شبیه به همتایان سنتی خود هستند. تلفن های رومیزی VoIP ارزان نیستند و مدل های پیشرفته تر آن صدها دلار قیمت دارند. با این حال، یکی از مزیت‌ها، توانایی استقرار تلفن‌های نرم‌افزاری به جای واحدهای فیزیکی است. تلفن‌های نرم‌افزاری (نرم‌افزار تلفنی که روی لپ‌تاپ یا دستگاه دستی اجرا می‌شود) می‌تواند بسیار ارزان‌تر و مدیریت آن‌ها آسان‌تر باشد

مجموعه‌ای از مهارت‌های کارکنان ارزش یک نگاه دیگر را دارد. سیستم های VoIP روی شبکه داده اجرا می شوند اما سیستم های تلفنی هستند که به پروتکل های مبتنی بر IP تبدیل شده اند همانطور که قبلا ذکر شد، آنها ممکن است فاقد پیش زمینه در پروتکل ها و سخت افزار مرتبط با یک شبکه داده باشند. این کارمندان نیز کسانی هستند که جنبه تلفن را درک می کنند. از سوی دیگر، مدیران شبکه داده ممکن است دانش کمی از تلفن داشته باشند یا اصلاً اطلاعی نداشته باشند. بنابراین تبدیل به VoIP ممکن است به انواع مختلفی از آموزش نیاز داشته باشد: خاص فروشنده، شبکه اصلی و خاص VoIP. استفاده از هر دو گروه از کارکنان ممکن است بهترین نتیجه ممکن را برای استقرار فراهم کند.

## The Business Case
و این ما را به پرونده تجاری VoIP می رساند. توجیه VoIP اغلب بر اساس بازگشت سرمایه است. یعنی چقدر طول می کشد تا پول پول خودش را بدهد؟ چندین موقعیت وجود دارد که در آن VoIP ROI خوبی را نشان داده است. اینها شامل ارتقاء زیرساخت فعلی، جایگزینی برنامه ریزی شده تجهیزات خراب یا قدیمی، نصب جدید و بسیاری موارد دیگر است.

با این حال، مزایای غیر پولی دیگری نیز در هنگام تبدیل به VoIP وجود دارد. به عنوان مثال، از آنجا که تجهیزات VoIP بسیار شبیه به رایانه ها و تجهیزات شبکه است که قبلاً مستقر شده اند، کارکنان فنی با مسائل مربوط به اتصال به شبکه آشنا خواهند شد. بنابراین، عیب یابی ممکن است توسط کارکنان داخلی انجام شود. علاوه بر این، این تخصص محلی ممکن است میانگین زمان تعمیر (MTTR) و افزایش میانگین زمان بین خرابی ها (MTBF) را کاهش دهد.

کارمندانی که از نقاط پایانی VoIP استفاده می‌کنند، ممکن است در صورت پشتیبانی از تلفن‌های بی‌سیم، تحرک بیشتری را تجربه کنند، اما تلفن‌های نرم‌افزاری و امکان ورود به هر تلفن نیز ممکن است تحرک و بهره‌وری را افزایش دهد. کارشناسان اغلب به این مزایا و همچنین ادغام با سایر برنامه ها به عنوان دلایل غیر مالی برای تغییر به VoIP اشاره می کنند.

ارتباطات یکپارچه (UC) همچنین فرصت های فوق العاده ای برای تحقق پیشرفت ها از طریق یکپارچه سازی برنامه ها ارائه می دهد. سیستم‌های UC بر اساس یک هسته VoIP ساخته می‌شوند، اما برخلاف VoIP، مورد UC همیشه از طریق صرفه‌جویی در هزینه‌ها، بلکه از طریق افزایش بهره‌وری ایجاد نمی‌شود. توانایی همکاری، نشان دادن حضور، و استفاده از یک پلتفرم واحد برای ایمیل، پیام‌رسانی و متن می‌تواند راه درازی برای دستیابی به این مزایای نرم‌افزاری داشته باشد.

با این حال، همه موافق نیستند که تغییر به VoIP بهترین ایده است. شرکت هایی که زمان و پول زیادی را برای اطمینان از کیفیت بالای خدمات، خرابی کم و تخصص محلی در سیستم های تلفن فعلی خود سرمایه گذاری کرده اند، ممکن است تا چند سال دیگر از VoIP استفاده نکنند، زیرا سیستم دیجیتال ویژگی ها و خدمات را ارائه می دهد. آنها نیاز دارند

## VoIP and FCC Regulation
صنعت تلفن به شدت تحت نظارت است. آنچه در صورتحساب شما وجود دارد، لیست های «تماس نگیرید» و 911 همگی توسط کمیسیون ارتباطات فدرال کنترل می شوند. ساختار قیمت گذاری، قابلیت حمل اعداد و دسترسی نیز توسط این قوانین کنترل می شود. اما همه چیز در مورد اینترنت و خدماتی که روی آن اجرا می شود و قوانین نیز متفاوت است. در یکی دو سال اخیر، بحث های مستمری در مورد مقررات اینترنت وجود داشته است. از یک سو، کسانی هستند که معتقدند اینترنت باید مکانی آزاد باشد که در آن ایده‌ها و ارتباطات می‌توانند شکوفا شوند و هیچ محدودیتی برای استفاده‌کنندگان از آن اعمال نشود. برای اطلاعات بیشتر، بی طرفی شبکه را جستجو کنید. از سوی دیگر مردم نگران حمایت از مصرف کنندگان و جوانان هستند. به نظر می رسد مسائل مربوط به حریم خصوصی و تمایل وب سایت برای به اشتراک گذاری یا فروش اطلاعات شما نیاز به مقررات بیشتر و قوانین سختگیرانه تر دارد. البته کسانی هم هستند که نگران پول هستند. اگر قرار باشد همه به سمت تلفن رایگان بروند، مدل هزینه ای که توسط بسیاری از شرکت های تلفن استفاده می شود چه می شود؟ چگونه دولت می تواند همه آن درآمد مالیاتی را جایگزین کند؟

یک نگاه به قبض تلفن نشان می دهد که چقدر می تواند گیج کننده باشد. در واقع، یکی از اولین اسناد ارائه شده در وب سایت FCC، آنچه را که ممکن است در صورتحساب خود بیابید، روشن می کند. چیزی که به آن مربوط می شود این است که شما هزینه خدمات تلفن و مالیات فروش آن خدمات را پرداخت می کنید. تقریباً هر چیز دیگری که در صورتحساب است نیز مالیات یا هزینه است. در زمان نوشتن این مقاله، FCC بسیاری از بازار VoIP را تنظیم نمی کند. در واقع، تا ژوئن 2012، کمیسیونر FCC رابرت ام. مک داول اظهار داشت:

دولت‌ها باید در برابر وسوسه مقررات‌گذاری غیرضروری مقاومت کنند، از مسیر اینترنت خارج شوند و به آن اجازه دهند به گسترش رفاه و آزادی در سراسر جهان ادامه دهد. اتصال به اینترنت، به ویژه از طریق دستگاه های تلفن همراه، مانند هیچ نوآوری دیگری در تاریخ جهان، وضعیت انسان را بهبود می بخشد

## 911
تفاوت قابل توجهی بین عملکرد سرویس 911 در سیستم های تلفن سنتی و 911 در سیستم مبتنی بر IP وجود دارد. مشکل اساسی این است که وقتی یک تلفن با یک آدرس IP شناسایی می شود، موقعیت جغرافیایی بخشی از معادله نیست. در مقابل، یک تلفن سنتی به مداری متصل است که در یک مکان خاص خاتمه می یابد. در حالی که درست است که یک آدرس IP محدود به یک ISP است و یک تلفن سنتی را می توان جابجا کرد، تلفن های VoIP بیشتر از خطوط تلفن همراه در نظر گرفته می شوند. علاوه بر این مشکلاتی هستند که بخشی منظم از شبکه های داده هستند: قطع، ترجمه آدرس شبکه، جابجایی یا جایگزینی گره ها و غیره. همه این عناصر می توانند یافتن نقطه پایانی در تماس اضطراری را دشوارتر کنند. قطع برق همچنین می‌تواند مشکلاتی ایجاد کند، زیرا سرویس VoIP روی دستگاه‌های اینترنتی برق‌دار مانند دروازه‌های خانگی و مودم‌های کابلی یا خط مشترک دیجیتال اجرا می‌شود. در نهایت، یک سوال بسیار واقعی در مورد پاسخ به تماس ورودی 911 وجود دارد. سیستم های سنتی نقاط پاسخگویی ایمنی عمومی (PSAP) را برای رسیدگی به تماس و اتصال آن به نزدیکترین واحد پاسخ اضطراری ایجاد کرده اند. در حالی که ارائه دهندگان VoIP ملزم به ایجاد توانایی مکان یابی یک فرد قبل از ارائه خدمات هستند و باید 911 را به صورت غیر انصرافی ارائه کنند، چالش های مرتبط با مکان یابی یک گره پایانی یک نگرانی معتبر ایجاد می کند. بنابراین، پیدا کردن گوشی VoIP یا تلفن نرم افزاری برای برقراری تماس به یک مشکل بسیار عملی برای مدیر شبکه تبدیل می شود. وقتی بی سیم را به معادله اضافه کنیم، این کار دشوارتر می شود. بسیاری از فروشندگان شروع به ارائه قابلیت های مکان یابی کرده اند که به رفع این چالش کمک می کند.یکی دیگر از مشکلات بسیار کاربردی اضافه کردن 911 به طرح شماره گیری است. این به خصوص برای VoIP جدید نیست، اما قابل ذکر است، زیرا باید به آن پرداخته شود. هنگامی که کاربر 911 را شماره گیری می کند، انتظار پاسخ خاصی را دارد. اما اگر کاربر به خاطر بیاورد که برای خارج شدن از سایت شماره 9 را شماره گیری می کند، چه اتفاقی می افتد؟ در این صورت ممکن است در واقع "9911" را شماره گیری کنند و انتظار پاسخ اضطراری را داشته باشند

## A Note on Power
خدمات تلفن سنتی برق را از دفتر مرکزی به مشتریان ارائه می دهد. این بدان معناست که منبع تغذیه تلفن‌ها با برقی که به پریزها، چراغ‌ها و یخچال شما عرضه می‌شود، کاملاً متفاوت است. بنابراین، در قطع برق، تلفن ممکن است تنها چیزی باشد که هنوز کار می‌کند - مگر اینکه مشتری از تلفن‌های بی‌سیم استفاده کند که از پریز برق می‌گیرند. در راه حل VoIP، قطع برق نیز با خاموش کردن تجهیزات محل مشتری (CPE) سرویس VoIP را از بین می برد. به عنوان مثال، سانترال VoIP محلی احتمالاً با بقیه تجهیزات شبکه در کمد نصب می شود. تلفن های رومیزی معمولاً انرژی خود را از سوییچ های اترنت از طریق برق از طریق اترنت (PoE) دریافت می کنند، همانطور که نقاط دسترسی بی سیم نیز انجام می شود. منابع تغذیه پشتیبان ممکن است برای مدت زمان معینی برق را تامین کنند، اما این منابع برای فراهم کردن زمان کافی برای مدیریت خاموش کردن برازنده تجهیزات نصب شده اند. اما با کاهش هزینه های تلفن همراه و پاسخ آهسته شرکت های مخابراتی سنتی، بسیاری از مشتریان تلفن های همراه را انتخاب کردند. به لطف منبع تغذیه پشتیبان برای تجهیزات حامل تلفن همراه، معمولاً تلفن‌های همراه شارژ شده هنوز هم در صورت قطع برق، سرویس دارند. حتی اگر آنها یک راه حل VoIP داشته باشند، مشتریان به سادگی به تلفن همراه تغییر می کنند. بنابراین، استدلال powerloss آنقدر قوی نیست. البته، برخی از مردم هرگز از تلفن سیمی استفاده نمی کنند

## General VoIP Topologies
راه‌های متعددی برای ساختن یک راه‌حل VoIP وجود دارد. هر فروشنده دارای مجموعه‌ای از مدل‌هاست که می‌توانند راه‌حلی متناسب با نیازهای مشتری را فراهم کنند. اما به‌طور کلی، دو روش اصلی وجود دارد: سیستم را خودتان راه‌اندازی و مدیریت کنید (در محل)، یا به یک ارائه‌دهنده خارجی واگذار کنید که به عنوان یک راه‌حل میزبانی شده عمل کند. شکل 1-6 نمونه‌ای از روش اول را نشان می‌دهد.(hosted solution)

سمت چپ شکل 1-6 شبکه داخلی را نشان می‌دهد که سرورهای پشتیبانی کننده از گره‌های VoIP و خود تلفن‌های VoIP را در خود جای داده است. شرکت از طریق یک ارائه‌دهنده خدمات اینترنت (ISP) به دنیای خارج متصل است. قبل از VoIP، یک شرکت معمولاً یک شبکه صوتی جداگانه نیز داشت و این شبکه‌ها به حامل محلی (LEC) خارج از سایت متصل می‌شدند تا ارتباط با نقاط انتهایی تلفنی فراهم شود. اغلب اوقات ISP و LEC یکی هستند. نقاط انتهایی VoIP نیز باید به نقاط انتهایی تلفنی در خارج متصل شوند. ترافیک سیگنالینگ از سرور تماس داخلی و دروازه به دروازه خارجی جریان می‌یابد. باز هم ممکن است که وظایف ISP و دروازه VoIP توسط یک شرکت ارائه شوند. اما همیشه این‌طور نیست. به عنوان مثال، اگر Time Warner ارتباط خارج از سایت را از طریق کابل فراهم کند و به شما یک آدرس IP بدهد اما تلفن‌های شما توسط Vonage مدیریت شوند، ترافیک سیگنالینگ تلفنی از طریق شبکه ISP به حامل VoIP یا ارائه‌دهنده خط انتقال جریان می‌یابد.

![](./image/1-6.png)

شرکت‌هایی که تعداد کمی کارکنان یا گره‌های کوچک دارند یا به سادگی نمی‌خواهند سیستم‌های تلفن خود را مدیریت کنند، می‌توانند یک راه‌حل میزبانی شده را انتخاب کنند. در این سناریو، تجهیزات مورد نیاز در محل مشتری بسیار کم است. ممکن است فقط تلفن‌های رومیزی در داخل شرکت نصب شوند. تمامی خدمات مورد نیاز برای اجرای تلفن‌ها به صورت فیزیکی در نزد ارائه‌دهنده قرار دارند. ارائه‌دهنده ممکن است ISP باشد یا نباشد. این مورد در شکل 1-7 نشان داده شده است.

اگر تصمیم بگیرید که IP PBX خود را اجرا کنید، چندین مؤلفه پشتیبانی باید بخشی از شبکه باشند. مدل‌های استقرار به اندازه شبکه، تعداد کاربران، نیازهای کاربران و سطح مهارت محلی بستگی دارد. همچنین چندین راه‌حل برای دفاتر کوچک یا خانگی (SOHO) (several small office home office) وجود دارد که در آن یک دروازه یا PBX کوچک و کم‌هزینه ممکن است در محل مشتری مستقر شود. مشتری می‌تواند انتخاب کند که دستگاه را خود مدیریت کند یا یک قرارداد خدمات داشته باشد. برای داشتن دردسر کمتر، مشتری می‌تواند یک راه‌حل کاملاً میزبانی شده مانند شکل 1-7 را انتخاب کند، و تنها تجهیزات موجود در محل، تلفن‌ها خواهند بود.

راه‌حل‌ها از آنجا به مدل‌های کسب‌وکار کوچک و متوسط (SMB) تا استقرارهای بزرگ سازمانی با یکپارچگی گسترده، پایگاه داده‌های مشتری و برنامه‌های کاربردی گسترش می‌یابند. هر مدل استقراری که انتخاب شود، چندین مؤلفه باید حاضر باشند تا چندین کار استاندارد را مدیریت کنند. برای شروع، تمامی گره‌های VoIP باید با سرور تماس ثبت شوند. به این ترتیب، سرور تماس متوجه می‌شود که کدام گره‌ها نیاز به خدمات دارند. سرور تماس ممکن است به چندین سرور تماس دیگر یا به دنیای خارج متصل شود. خدماتی مانند فهرست راهنما یا مکان‌یابی نیز ممکن است مورد نیاز باشد. در زیر فهرستی از مؤلفه‌های استاندارد VoIP آورده شده است؛ اما همه آنها در هر استقراری لازم نیستند.

![](./image/1-7.png)
### **سرور تماس**
تلفن‌ها با سرور تماس ثبت‌نام می‌کنند. سرور تماس می‌تواند کنترل امنیت و پذیرش را هنگام اتصال تلفن‌ها مدیریت کند. داده‌های صوتی مکالمه، که معمولاً توسط پروتکل انتقال حمل می‌شود، ممکن است از طریق سرور تماس جریان داشته باشد یا نداشته باشد.

### **دروازه (Gateway)**
این دستگاه معمولاً برای اتصال یک شبکه داخلی به بقیه جهان یا حداقل یک سیستم دیگر استفاده می‌شود. سیستمی که به آن متصل می‌شوید ممکن است فناوری متفاوت یا مشابهی داشته باشد. به عنوان مثال، یک شبکه داخلی مبتنی بر VoIP ممکن است مستقیماً به PSTN متصل شود. PSTN هنوز تا حد زیادی توسط SS7 کنترل می‌شود. دروازه نقاط انتهایی در هر دو سمت را متصل می‌کند، بین دو سیستم ترجمه می‌کند یا ویژگی‌هایی فراهم می‌کند. از سوی دیگر، دروازه ممکن است به سادگی شرکت‌ها یا ارائه‌دهندگان را به هم متصل کند. در این حالت، گروه‌های متصل ممکن است از همان پروتکل سیگنالینگ استفاده کنند.

### **پروتکل‌های VoIP**
دو نوع پروتکل VoIP وجود دارد: سیگنالینگ و انتقال. پروتکل‌های سیگنالینگ تمامی عملکردهایی را که معمولاً توسط پروتکل‌های سنتی انجام می‌شوند، مانند پروتکل Q.931 در شبکه دیجیتال خدمات یکپارچه (ISDN)، مدیریت می‌کنند. پروتکل‌های سیگنالینگ استاندارد شده در ادامه این فصل توضیح داده می‌شوند و در جای دیگری از این کتاب به‌طور کامل بررسی می‌شوند. پروتکل انتقال برای کپسوله‌سازی یا حمل داده‌های صوتی واقعی استفاده می‌شود و تنها پروتکلی که به‌طور جهانی برای انتقال استفاده می‌شود، پروتکل انتقال بلادرنگ (RTP) است که در فصل 4 توضیح داده شده است. بسته‌های داده صوتی با یک کدک ایجاد می‌شوند و سپس در RTP کپسوله می‌شوند.

### **کدک‌ها (Codecs)**
کدک به معنای کدر-دیکدر است که برای تبدیل سیگنال صوتی آنالوگ به مجموعه‌ای از نمونه‌های دیجیتال در مبدا و سپس برگرداندن آن در گیرنده استفاده می‌شود. بنابراین، تلفن فرستنده داده‌های صوتی را با کدک خود کدگذاری می‌کند و گیرنده بسته صوتی را با کدک خود دیکد می‌کند. کدک‌ها در هر دو استقرار سنتی و VoIP حضور دارند. برای یک سیستم سنتی، کدک می‌تواند به صورت فیزیکی در تلفن یا در PBX باشد، بسته به نوع و مدل استقرار. تلفن‌های VoIP همیشه حاوی کدک هستند. کدک‌ها می‌توانند داده‌های صوتی را نیز فشرده کنند. در حالی که کدک‌های مختلفی وجود دارند، احتمالاً رایج‌ترین کدک‌های صوتی از سری G اتحادیه بین‌المللی مخابرات (ITU-T) هستند. سری H اتحادیه بین‌المللی مخابرات شامل کدک‌های ویدیویی محبوب است. در دسته‌های صوتی و ویدیویی، کدک‌ها به روش‌های مختلف کدگذاری و فشرده‌سازی را انجام می‌دهند، اگرچه بسیاری از آنها بر اساس اصول مشابهی هستند. فصل 5 جزئیات بیشتری درباره کدک‌ها فراهم می‌کند، اما یک فهرست کوتاه از این دو مجموعه شامل موارد زیر است:
* G.711—Pulse Code Modulation
* G.722 and G.723—Low bit-rate encoding
* G.726—Adaptive Differential Pulse Code Modulation
* G.729.1—Code Excited Linear Prediction variable bit-rate coder
* H.261—Early video codec for p x 64 Kbps
* H.263—Video coding for low bit-rate communication
* H.264—Advanced video coding for generic audiovisual services
* iSAC (Internet Speech Audio Codec)—a non-ITU-T audio codec developed
by Global IP Solutions, used by Google Talk

### **تلفن‌های رومیزی و نرم‌افزارهای تلفنی**
تلفن‌ها (که به عنوان نقاط انتهایی نیز شناخته می‌شوند) در یک توپولوژی VoIP همان خدماتی را ارائه می‌دهند که هر تلفن دیگری انجام می‌دهد، اگرچه به شکلی متفاوت. در اوایل تکامل VoIP، تلاش‌هایی برای حذف کامل تلفن به نفع برنامه‌های تلفنی نصب‌شده روی کامپیوترها وجود داشت. با این حال، مردم به طراحی سنتی تلفن عادت کرده بودند و تغییر را دوست نداشتند. برنامه‌ها نیز باید با هر چیزی که در آن زمان روی کامپیوتر اجرا می‌شد، رقابت می‌کردند. امروزه، ما ترکیبی از تلفن‌های رومیزی VoIP و برنامه‌های تلفنی یا نرم‌افزارهای تلفنی داریم.

### **اجزای غیر VoIP**
سیستم VoIP به تعداد زیادی از خدماتی که مخصوص VoIP نیستند، وابسته است. بسیاری از این خدمات، مانند پروتکل پیکربندی پویای میزبان (DHCP)، از قبل بخشی از معماری شبکه هستند و می‌توانند برای شامل کردن اجزای VoIP گسترش یابند. خدمات دیگر شامل پروتکل انتقال فایل ساده (TFTP)، سرویس نام دامنه (DNS) و پروتکل زمان شبکه (NTP) هستند. معمولاً مشاهده می‌شود که این اجزا در الزامات محصول VoIP فهرست شده‌اند، زیرا ممکن است بدون آنها اجرا نشوند. یک توپولوژی معمولی که شامل این عناصر است، ممکن است شبیه به آنچه در شکل 1-8 نشان داده شده است باشد.

![](./image/1-8.png)


### Dynamic Host Configuration Protocol (DHCP)
Dynamic Host Configuration Protocol, is a network protocol used to automate the process of assigning IP addresses and other network configuration parameters to devices (such as computers, smartphones, and printers) on a network.

#### Key Features of DHCP
* Automatic IP Address Assignment: DHCP servers assign IP addresses to devices (clients) dynamically from a predefined range or pool of addresses.

* Lease Concept: IP addresses are assigned for a specific period called a lease. After the lease expires, the IP address can be reassigned to another device.

#### How DHCP Works
* DHCP Discovery: When a device connects to the network, it sends out a broadcast message (DHCPDISCOVER) to discover DHCP servers.

* DHCP Offer: Any DHCP server that receives the discovery message responds with a DHCPOFFER, which includes an available IP address and other configuration details.

* DHCP Request: The client selects one of the offers (if multiple are received) and responds with a DHCPREQUEST to the server, indicating its acceptance of the offered address.

* DHCP Acknowledgment: The server sends a DHCPACK message to the client, confirming the lease and finalizing the configuration. The client can now use the assigned IP address and other provided settings.


### Trivial File Transfer Protocol (TFTP)
Trivial File Transfer Protocol (TFTP) is a simple, lockstep, and lightweight file transfer protocol that operates over UDP (User Datagram Protocol). Unlike more complex protocols like FTP (File Transfer Protocol), TFTP provides a minimalistic way of transferring files, primarily used for simple and quick file transfers.

#### Key Features of TFTP
* Simplicity: TFTP is designed to be simple and easy to implement, lacking many of the features and commands found in more complex file transfer protocols.

* Connectionless: TFTP uses UDP for data transmission, which means it does not establish a connection before transferring data. This makes TFTP faster but less reliable than TCP-based protocols.

* Minimal Overhead: TFTP has minimal command structure and control overhead, making it suitable for environments where simplicity and low resource usage are crucial.

#### How TFTP Works
* Read Request (RRQ): A client sends a read request to the TFTP server to retrieve a file.

* Write Request (WRQ): A client sends a write request to the TFTP server to upload a file.

* Data Transfer: Data is transferred in blocks, typically 512 bytes each. Each block of data must be acknowledged by the receiver before the next block is sent.

* Acknowledgment (ACK): The receiving side sends an acknowledgment for each data block received.
Error Handling: If an error occurs, an error message (ERROR) is sent to the client or server, terminating the transfer.

### Domain Name Service (DNS)
The Domain Name System (DNS) is a hierarchical and decentralized naming system used to translate human-readable domain names into machine-readable IP addresses. This process is essential for the functioning of the internet, as it allows users to access websites and services using easy-to-remember domain names instead of numerical IP addresses.

### Network Time Protocol (NTP)
Network Time Protocol (NTP) is a networking protocol designed to synchronize the clocks of computers and devices over a network. It is one of the oldest internet protocols still in use and ensures that systems across different locations maintain accurate time, which is critical for various applications such as logging events, security, and scheduling tasks.



## Power over Ethernet
بخش دیگری از این زیرساخت که مختص VoIP نیست، توان بر روی اترنت (Power over Ethernet یا PoE) است. دستگاه‌هایی مانند نقاط دسترسی (Access Points) و تلفن‌های VoIP می‌توانند از طریق انژکتورها (Injectors) که بین آنها و شبکه قرار می‌گیرند، تغذیه شوند. با این حال، این انژکتورها نیاز به یک پریز برق دارند، همان‌طور که در شکل 1-9 نشان داده شده است.

![](./image/1-9.png)

این موضوع باعث محدودیت در استقرار این دستگاه‌ها می‌شود، زیرا باید نزدیک یک پریز برق باشند یا پریز جدیدی نصب شود. این امر به خصوص برای نقاط دسترسی که معمولاً روی سقف نصب می‌شوند، صادق است. راه‌حل‌های PoE که به صورت رک‌مونت (Rack-mounted) هستند می‌توانند کمک کنند، البته در صورتی که محیط و فاصله‌ها مناسب باشند. مهاجرت به VoIP می‌تواند صدها تلفن که نیاز به تغذیه دارند را معرفی کند. حتی اگر تلفن‌ها در دفاتر باشند، این به معنای مدیریت تعداد زیادی پریز و توان است. سوئیچ‌های PoE این مشکل را با تامین توان مستقیم به تلفن (یا نقطه دسترسی) بدون نیاز به انژکتور حل می‌کنند. سه روش PoE که معمولاً استفاده می‌شوند، وجود دارد که دو مورد از آنها استانداردهای IEEE هستند.

### IEEE 802.3af
استاندارد **Carrier Sense Multiple Access with Collision Detection (CSMA/CD) و مشخصات لایه فیزیکی، توان تجهیزات پایانه داده (Data Terminal Equipment یا DTE) از طریق رابط وابسته به رسانه (Media Dependent Interface یا MDI) بهبود یافته** است.

### IEEE 802.3at
تکمیل‌کننده استاندارد 802.3af است که توان بیشتری را برای دستگاه‌ها فراهم می‌کند.

این دو استاندارد روش‌هایی را برای تغذیه دستگاه‌های شبکه از طریق کابل‌های شبکه معمولی تعریف می‌کنند که به کاهش نیاز به پریزهای برق متعدد و مدیریت توان کمک می‌کند.


## PoE Basic Operation
این استاندارد دو انتهای اتصال را تعریف می‌کند. توان از طریق تجهیزات منبع تغذیه (Power Sourcing Equipment یا PSE) تأمین شده و به دستگاه تغذیه‌شونده (Powered Device یا PD) ارسال می‌شود. چندین پیکربندی مختلف برای اتصالات الکتریکی وجود دارد که PSE باید پشتیبانی کند. اتصالات اترنت هشت‌سیم دارای دو جفت داده (1 و 2، 3 و 6) هستند و با PoE، توان جریان مستقیم می‌تواند بر روی پین‌های 4، 5، 7 و 8 تأمین شود. جفت مثبت بر روی هادی‌های 4 و 5 قرار می‌گیرد و هادی‌های 7 و 8 جفت منفی را تشکیل می‌دهند. ایده این است که پس از اتصال دستگاهی که نیاز به توان دارد به سوئیچ، دستگاه شناسایی می‌شود و تنها پس از آن توان اعمال می‌شود. شناسایی از طریق یک امضای شناسایی PD در زمان اتصال صورت می‌گیرد. PSE در واقع دستگاه متصل را برای ویژگی‌های الکتریکی صحیح، همان‌طور که در استاندارد تعریف شده است، مورد بررسی قرار می‌دهد. این کار به عنوان طبقه‌بندی لایه فیزیکی شناخته می‌شود. دستگاه‌ها ممکن است از طبقه‌بندی لایه پیوند داده نیز پشتیبانی کنند که از پروتکل شبکه محلی استفاده می‌کند. زمانی که این طبقه‌بندی فعال باشد، اولویت با طبقه‌بندی لایه پیوند داده است.

در PSEها، لینک و PD به عنوان سیستمی که یا نوع I یا نوع II است در نظر گرفته می‌شوند؛ هر نوع دارای ویژگی‌های الکتریکی متفاوتی است، مانند محدودیت‌های جریان مستقیم، مقاومت و نوع کابل. نوع II جریان بیشتری حمل می‌کند و نیازمندی‌های کابل‌کشی بیشتری دارد. توان خروجی دستگاه‌ها تابعی از ولتاژ تأمین و جریان کشیده شده است. PSE باید وظایفی مانند شناسایی PDها، تأمین توان، نظارت بر توان ارائه شده و حذف توان زمانی که نیاز نیست را انجام دهد. همچنین این فرض وجود دارد که PSE به دستگاه غیر PoE توان ارائه ندهد. PDهای نوع I امضاهای طبقه‌بندی رویدادی 0، 1، 2 یا 3 را زمانی که مورد پرسش قرار می‌گیرند، تبلیغ می‌کنند. پیش‌فرض کلاس 0 است. نوع II پیچیده‌تر است اما از کلاس 4 و فرآیند انتخاب دو بخشی استفاده می‌کند. برخی PDها می‌توانند شناسایی متقابل انجام دهند، زیرا ممکن است به جای PSE نوع I به PSE نوع II نیاز داشته باشند. حداکثر توان کشیده شده تابعی از محدودیت‌های کلاس و ویژگی‌های الکتریکی است 

روش سوم PoE توسط شرکت سیسکو ارائه شده است. سیسکو قابلیت PoE را قبل از تصویب استانداردهای IEEE پیاده‌سازی کرد. روش سیسکو از لحاظ مذاکره، با استفاده از پروتکل کشف سیسکو (Cisco Discovery Protocol یا CDP) و سطح توان، با استاندارد IEEE تفاوت دارد. سیسکو همچنین از پالس لینک سریع برای شناسایی دستگاه متصل PoE استفاده می‌کند. در حالی که دستگاه‌های سیسکو ممکن است با استانداردهای IEEE سازگار باشند و از PoE سیسکو پشتیبانی کنند، این دو تکنیک با هم سازگار نیستند. دستگاه‌های فعلی سیسکو از یک یا هر دو استاندارد IEEE پشتیبانی می‌کنند.

مستندات سیسکو به یک مشکل جالب اشاره می‌کند که ممکن است زمانی که یک دستگاه PoE متصل می‌شود و نوع و کلاس آن قابل تعیین نیست، رخ دهد. در این حالت، سوئیچ توان کامل را برای دستگاه ناشناخته اختصاص می‌دهد، حتی اگر ممکن است مورد نیاز نباشد. نتیجه این است که توان مورد نیاز دستگاه‌های دیگر که به سوئیچ متصل هستند نمی‌تواند تامین شود و در نتیجه منجر به کاهش بودجه توان می‌شود.

از دیدگاه عملی، آگاهی از عملکرد PoE احتمالاً در اکثر مواقع ضروری نیست. یک مدیر ممکن است به سادگی به نیازهای توان دستگاه‌های متصل نگاه کند تا اطمینان حاصل کند که سوئیچ استاندارد مناسب را ارائه می‌دهد: 802.3af یا 802.3at. این باید بخشی از تصمیم‌گیری‌های خرید نیز باشد. البته، عیب‌یابی تقریباً همیشه با داشتن کمی دانش بیشتر در این حوزه آسان‌تر می‌شود. در مثال کاهش توان، جداسازی دستگاه‌ها و درک سیگنال‌دهی یا مشکلات احتمالی می‌تواند منجر به حل سریع مشکل شود.


## VoIP Protocols
همان‌طور که قبلاً ذکر شد، پروتکل‌های VoIP خاصی وجود دارند اما تنها به دو دسته تقسیم می‌شوند: **سیگنال‌دهی** و **حمل و نقل**. پروتکل‌های سیگنال‌دهی وظایف مربوط به معماری سیستم تلفنی را مدیریت می‌کنند و پروتکل‌های حمل و نقل بسته‌های صوتی تولید شده توسط کدک را حمل می‌کنند. تلفن‌ها از پروتکل سیگنال‌دهی برای ثبت‌نام در سرور تماس، برقراری و پایان دادن به تماس‌ها استفاده می‌کنند. پروتکل‌های سیگنال‌دهی همچنین برای ویژگی‌هایی مانند خدمات دایرکتوری و نمایشگرهای صفحه استفاده می‌شوند. هنگامی که یک تماس برقرار می‌شود، بسته‌های داده صوتی معمولاً مستقیماً بین تلفن‌ها با استفاده از انکپسولاسیون RTP ارسال می‌شوند، هرچند که استثنائاتی نیز وجود دارد. مسیرهای جریان داده در شکل 1-10 نشان داده شده است.

بسته‌های RTP که داده صوتی را حمل می‌کنند ممکن است همچنین از تلفن به سرور تماس و سپس به تلفن دیگر جریان یابند.

![](./image/1-10.png)

## Signaling Protocols
با وجود اینکه معماری VoIP کاملاً با معماری مورد استفاده در تلفن سنتی متفاوت است، ما هنوز نیاز اساسی به سیگنال‌دهی داریم. به هر حال، تلفن‌ها باید زنگ بخورند، شماره‌ها باید منتقل شوند و مسیرها باید تنظیم شوند، و این وظایف توسط پروتکل سیگنال‌دهی مدیریت می‌شوند. سه نوع رایج پروتکل‌های سیگنال‌دهی عبارتند از H.323، Skinny و پروتکل آغاز جلسه یا SIP.


## Session Initiation Protocol
پروتکل آغاز جلسه (SIP) یک استاندارد غیرانحصاری از گروه مهندسی اینترنت (IETF) است. فرمت پیام‌های SIP بسیار شبیه به بسته‌های پروتکل انتقال ابرمتن (HTTP) است و بنابراین برای افراد فعال در دنیای شبکه‌های داده آشنا است. SIP شروع کندی داشت اما به طور گسترده‌ای در سراسر جهان پذیرفته شده است. با اینکه RFC اولیه محدودیت‌هایی داشت، اکنون به پروتکل سیگنال‌دهی مورد استفاده اکثر شرکت‌ها تبدیل شده است، از جمله Vonage و Skype. حتی سیسکو نیز در حال انتقال از Skinny به SIP است. پوشش عمیق‌تر SIP در فصل 3 موجود است. یک نمونه بسته SIP در شکل 1-11 دیده می‌شود.

![](./image/1-11.png)

از شکل 1-11 می‌توان دید که بسته به راحتی قابل خواندن است، هدف مشخصی دارد و طرف‌های درگیر به وضوح تعریف شده‌اند. این ویژگی‌ها و یکپارچگی با بسیاری از اشکال آدرس‌دهی، از دلایل محبوبیت این پروتکل هستند.


## H.323
این در واقع یک مجموعه استانداردهای ITU-T است که بر روی ویدئو کنفرانس تمرکز دارد. این مجموعه استانداردها پیش از رقبای خود توسعه یافته و بنابراین به عنوان استانداردی غیررسمی در بسیاری از پیاده‌سازی‌ها مورد استفاده قرار می‌گرفت. این استاندارد از بسیاری از ایده‌های سیگنال‌دهی تلفن سنتی استفاده می‌کند و برخی ممکن است بگویند که به دلیل وابستگی به این روش‌های قدیمی دچار مشکلاتی شده است. در یک جلسه H.323 چندین زیرپروتکل وجود دارد، از جمله Q.931، H.225 و H.245. جزئیات بیشتر درباره H.323 را می‌توان در فصل 6 یافت. یک نمونه بسته H.225 در شکل 1-12 دیده می‌شود.

![](./image/1-12.png)

با بررسی بسته در شکل 1-12، نیازی نیست که خیلی جلو برویم تا تعداد زیرلایه‌ها و فیلدهای درگیر را ببینیم. در داخل بسته TCP سه زیرلایه (TPKT، Q.931 و H.225) وجود دارد قبل از اینکه به اطلاعات پیام واقعی برسیم. کمی جلوتر، بخش "fastStart" قرار دارد که شامل 36 آیتم است. این پیچیدگی ممکن است یکی از دلایل کاهش محبوبیت آن باشد. با این حال، برخی از کارشناسان VoIP اشاره می‌کنند که پیچیدگی SIP می‌تواند بسته به نقاط انتهایی و قابلیت‌های آنها افزایش یابد.


## Skinny Client Control Protocol
پروتکل کنترل مشتری سبک (SCCP)، یا Skinny، یک محصول سیسکو است. این پروتکل بسیار انحصاری است و بسیاری از عملیات‌های آن به طور قابل توجهی با آنچه که ممکن است یک پیاده‌سازی VoIP معمولی در نظر گرفته شود، متفاوت است. با این حال، سیسکو با محصولات VoIP خود موفقیت زیادی کسب کرده است و تعداد قابل توجهی از شبکه‌های سیسکو از Skinny استفاده می‌کنند. فصل 7 به بررسی Skinny می‌پردازد. یک نمونه بسته Skinny در شکل 1-13 دیده می‌شود.

![](./image/1-13.png)

یکی از ویژگی‌های خوب پیام‌های Skinny این است که مانند SIP، بسیار آسان برای خواندن هستند، حداقل اگر نسخه‌های قدیمی‌تر یا جداسازهای اخیر را داشته باشید. اکثر پیام‌های Skinny کوتاه و به نکته هستند. با این حال، Skinny انحصاری است و برخی از رفتارهایی دارد که در جاهای دیگر دیده نمی‌شود، مانند استفاده محدود یا غیرموجود از پروتکل کنترل زمان واقعی (RTCP)، که پروتکل همراه RTP است.

## Transport Protocol
پروتکل انتقال زمان واقعی (RTP) بدون شک پروتکل مورد علاقه برای انتقال بسته‌های صوتی حاوی داده‌های صوتی است. در حالی که مکانیزم‌های دیگری نیز برای این کار به کار گرفته شده‌اند، RTP به طور گسترده‌ای پذیرفته شده است. RTP، که در RFC 3550 تعریف شده است، یک پروتکل ساده است که از شناسه‌های منبع برای جمع‌آوری بسته‌ها از یک منبع استفاده می‌کند و دارای یک فیلد است که نوع بار مفید (payload) را مشخص می‌کند تا گیرنده بتواند تشخیص دهد که کدام کدک برای ایجاد بسته صوتی استفاده شده است. یک بسته RTP در شکل 1-14 نشان داده شده است.

![](./image/1-14.png)

در RFC 3550 همچنین شامل پروتکل کنترل زمان واقعی (RTCP) است که اطلاعاتی درباره جریان بسته‌های RTP ارائه می‌دهد. استفاده اصلی آن ارائه بازخورد در مورد کیفیت جریان صوتی است. یک بسته RTCP در شکل 1-15 نشان داده شده است.

![](./image/1-15.png)

با مقایسه این بسته‌ها، می‌توان دید که بسته RTP نشانه‌ای از کدک استفاده شده برای ایجاد بسته صوتی، شناسه منبع و خود داده‌ها را فراهم می‌کند. بسته RTCP هیچ‌کدام از این‌ها را ندارد. در عوض، RTCP زمان‌بندی و بایت‌های ارسال شده بین نقاط انتهایی را پیگیری می‌کند. به این ترتیب، می‌توان ایده‌ای از عملکرد لینک به دست آورد. فصل 4 جزئیات بیشتری در مورد هر دو پروتکل RTP و RTCP ارائه می‌دهد.

RTP simple protocol that uses source IDs to collect packets from the same source, and it has a field that identifies the payload so that the receiver can determine which codec was used to create the voice packet. 

## VoIP Basic Operation
این کتاب شامل فصلی برای هر یک از پروتکل‌های سیگنال‌دهی است، و توپولوژی‌های استفاده‌شده برای توضیحات با استفاده از فروشندگان مختلف، از جمله Cisco، Avaya و Asterisk ساخته شده‌اند. در حین پیش‌روی، خواهیم دید که اکثر پیاده‌سازی‌های VoIP از یک قالب مشابه برای عملیات پیروی می‌کنند و تقریباً مجموعه‌ی یکسانی از اجزا را دارند. این بخش قالب عملیات را فراهم می‌کند و فصل‌ها جزئیات خاص مربوط به توپولوژی و پروتکل استفاده‌شده را ارائه می‌دهند. فعلاً، توپولوژی نشان‌داده‌شده در شکل 1-16 مبنای بحث ما خواهد بود.

![](./image/1-16.png)

فهرست بسته‌ها که در شکل 1-17 نشان داده شده است، بسته‌هایی را که هنگام روشن شدن تلفن تولید می‌شوند و سپس تماسی برقرار می‌کند، به تصویر می‌کشد. برای صرفه‌جویی در فضا، این فهرست ویرایش شده است تا مثال‌هایی نشان داده شود، نه کل سری مکالمات. این فهرست از یک اتصال غیر اختصاصی H.323 است. همانطور که مشاهده می‌شود، چندین قسمت وجود دارد که با پروتکل پیکربندی پویا میزبان (Dynamic Host Configuration Protocol یا DHCP) شروع می‌شود. بعد از DHCP، تلفن با یک سرور پروتکل انتقال فایل بی‌اهمیت (Trivial File Transfer Protocol یا TFTP) تماس می‌گیرد تا هرگونه به‌روزرسانی اخیر را دریافت کند و 

سپس به پیام‌رسانی خاص VoIP منتقل می‌شود.
برای سرگرمی، فهرست دیگری از معماری اختصاصی Cisco را نیز گنجانده‌ام تا بتوانیم ببینیم که هر دو فرمت مجموعه مشابهی از رویه‌ها را دنبال می‌کنند. بسته‌های نشان داده شده در شکل 1-18 نیز از DHCP به TFTP و سپس به پروتکل‌های خاص VoIP پیش می‌روند.

![](./image/1-17.png)
![](./image/1-18.png)

### پروتکل پیکربندی پویا میزبان (DHCP)
همان‌طور که در فهرست بسته‌های اختصاصی و غیر اختصاصی مشاهده کردیم، تقریباً تمام پیاده‌سازی‌های VoIP با DHCP شروع می‌شوند. علاوه بر آیتم‌های استانداردی مانند یک آدرس IP و دروازه پیش‌فرض، تلفن‌های VoIP به آدرس‌های سرور TFTP و سرور تماس نیاز دارند. از بین این دو آدرس، TFTP گام بعدی برای تلفن‌ها است، زیرا مکانیزم‌های مختلفی برای به‌دست آوردن آدرس سرور تماس استفاده می‌شود. به عنوان مثال، یک فایل پیکربندی می‌تواند روی سرور TFTP نصب شود. این فایل مقادیری مانند سرور تماس، زبان و ترتیب دکمه‌ها را فراهم خواهد کرد. در ادامه چند خط نمونه پیکربندی DHCP برای Cisco آمده است و چهار خط آخر روش‌های مختلفی برای ارائه آدرس TFTP یا سرور تماس را نشان می‌دهند.

```
ip dhcp pool voip
network 192.168.16.0 255.255.255.0
default-router 192.168.16.254
next-server 192.168.16.99
option 66 ip 192.168.16.99
option 150 ip 192.168.16.99
option 176 ascii "TFTPSRVR=192.168.16.99,
MCIPADD=192.168.16.1"
```

### پروتکل انتقال فایل بی‌اهمیت (TFTP)
همان‌طور که از نام آن پیداست، انتقال‌های TFTP بسیار ساده هستند؛ هیچ نام کاربری، رمز عبور، یا انواع انتقال پیچیده‌ای وجود ندارد. از یک سرور TFTP برای به‌روزرسانی فریم‌ور استفاده‌شده توسط تلفن و شاید ارائه یک فایل تنظیماتی که ممکن است شامل پارامترهای عملیاتی برای شبکه VoIP باشد، استفاده می‌شود. یک نمونه از فایل تنظیمات ممکن است به این شکل باشد:
```
SET MCIPADD 192.168.16.1
```
اما سرورهای TFTP همچنین برای ارائه فایل‌هایی که کدها یا تن‌هایی را که در یک منطقه خاص استفاده می‌شوند، توصیف می‌کنند نیز به کار می‌روند. به عنوان مثال، مجموعه وسیعی از فایل‌های قابل دانلود ممکن است هنگام پیکربندی پشتیبانی محلی سازی Cisco استفاده شوند. گرفتن تصویر نشان داده‌شده در شکل 1-17 از دید تلفن A است که آدرس IP 192.168.16.23 را دریافت می‌کند. با دنبال کردن مکالمه تا این نقطه، می‌توانیم توپولوژی را به‌صورت نشان‌داده‌شده در شکل 1-19 تغییر دهیم.

![](./image/1-19.png)

### ثبت‌نام تلفن
قبل از اینکه یک نقطه پایانی VoIP بتواند تماس برقرار کند، ابتدا باید با سرور تماس یا نگهبان ثبت‌نام کند. این فرآیند سرور تماس را از وجود تلفن آگاه می‌سازد و اطلاعاتی برای رابط کاربری تلفن فراهم می‌کند. با یک نصب یا ثبت‌نام جدید، کاربر با استفاده از شماره تلفنی که به او اختصاص داده شده است وارد تلفن می‌شود. در این نقطه، آدرس IP و MAC تلفن اکنون به آن تلفن یا شماره تماس خاص مرتبط شده‌اند.
ثبت‌نام از طریق پروتکل سیگنال‌دهی انجام می‌شود، و هر پروتکل سیگنال‌دهی از مجموعه‌ای از پیام‌ها برای انجام این کار استفاده می‌کند که کمی متفاوت است. از دو نمودار مکالمه، می‌بینیم که H.323 از پیام‌های RAS، یا ثبت‌نام، پذیرش و وضعیت استفاده می‌کند، در حالی که Skinny از یک پیام ثبت‌نام استفاده می‌کند. در هر دو حالت، به‌وضوح مشخص است که چه اتفاقی می‌افتد و تلفن‌ها این کار را قبل از هر چیز دیگری انجام می‌دهند.
شکل 1-20 برخی از تغییرات در پیام‌رسانی ثبت‌نام را نشان می‌دهد.

![](./image/1-20.png)

### راه‌اندازی تلفن
بسته به مدل تلفن، پیکربندی توپولوژی، و پروتکل سیگنال‌دهی، ممکن است چندین پیام H.323، Skinny، یا SIP بین سرور تماس و تلفن رد و بدل شود. این پیام‌ها ممکن است برای اطلاع‌رسانی به تلفن از رویدادها، ارائه پشتیبانی از ویژگی‌ها، یا پر کردن رابط کاربری استفاده شوند. هر یک از فصل‌های مربوط به سیگنال‌دهی جزئیات بیشتری را ارائه خواهند داد، اما برخی از این پیام‌ها را می‌توان در شکل 1-21 و شکل 1-22 مشاهده کرد.

![](./image/1-21.png)

این پیام‌ها روش‌های مجاز را تبادل می‌کنند (شکل 1-21) و دستورالعمل‌هایی را در مورد صفحه نمایش دریافت می‌کنند (شکل 1-22). هر دو پس از مرحله ثبت‌نام دریافت شدند.

### راه‌اندازی و اتصال تماس
در یک شبکه سنتی، برداشتن گوشی مدار را برای آماده‌سازی سیگنال صوتی می‌بندد. کاربران اعداد را شماره‌گیری می‌کنند و صداهایی تولید می‌شود که به سویچ تلفن ارسال می‌شوند. سویچ این صداها را از طریق کدک به اطلاعات دیجیتال تبدیل می‌کند. سویچ‌ها باید یک مدار انتها به انتها به مقصد برقرار کنند. هیچ‌کدام از این فرآیندها به صورت بسته‌بندی شده نیستند، به این معنی که بر اساس پروتکل‌های IP نیستند. برای VoIP، این فرآیند باید از پیام‌های سیستم سیگنالینگ 7 و فرکانس‌های تلفن (مانند فرکانس‌های ایجاد شده توسط نقاط انتهایی DTMF) به پیام‌هایی که در پروتکل‌هایی مانند آنچه در این بخش توضیح داده شده، کپسوله شده‌اند، تغییر کند.

پروتکل سیگنالینگ VoIP (مانند H.323، Skinny، SIP) پیام‌هایی به سرور تماس ارسال می‌کند که شماره شماره‌گیری شده را نشان می‌دهد، و سرور تماس باید با مقصد تماس بگیرد. در حالی که پروتکل‌ها روش‌شناسی‌های مختلفی دارند و در واقع ممکن است تفاوت‌های بیشتری توسط فروشندگان ایجاد شود، این پیام‌ها معمولاً درست قبل از شروع جریان RTP ظاهر می‌شوند. شکل 1-23 برخی از تغییرات در پیام‌هایی که اتصال را شروع می‌کنند، نشان می‌دهد.

![](./image/1-23.png)

همانطور که از ردگیری ضبط شده در شکل 1-18 می‌توانیم ببینیم، پیام‌های ثبت‌نام، راه‌اندازی، و اتصال همگی به سمت سرور تماس در آدرس 192.168.16.1 جریان می‌یابند. با به‌روزرسانی نمودار توپولوژی خود، نتیجه‌ای که در شکل 1-24 نشان داده شده است، به دست می‌آید.

![](./image/1-24.png)

### گفتگوی RTP
وقتی RTP برای انتقال داده‌های صوتی استفاده می‌شود. وقتی که بسته‌های RTP جریان پیدا می‌کنند، تماس برقرار شده است. با این حال، RTP می‌تواند برای انتقال نمونه‌هایی که برای صداهای دیگر ایجاد شده‌اند نیز استفاده شود. به عنوان مثال، یک صدای شماره‌گیری می‌تواند در بسته‌های RTP ارسال شده از سرور تماس قرار گیرد و این بسته‌ها قبل از داده‌های صوتی تماس رخ خواهند داد - بنابراین به آدرس‌های IP توجه داشته باشید. بسته RTP حاوی یک شناسه بارگذاری است که کدک مورد استفاده را نشان می‌دهد. وقتی کاربر نهایی در گوشی صحبت می‌کند، کدک صدای آنالوگ را می‌گیرد و بسته‌های صوتی را ایجاد می‌کند که در جریان RTP ارسال می‌شوند. با گرفتن یک قطعه از گفتگوی H.323 در شکل 1-17، می‌توانیم ببینیم که بسته‌های RTP بین تلفن‌ها جریان دارند. نمودار در شکل 1-16 نشان می‌دهد که تلفن‌ها دارای آدرس‌های IP 192.168.16.23 و 192.168.16.24 هستند.

در سمت دریافت، بسته‌های صوتی دیکد شده و در گوشی پخش می‌شوند. توجه داشته باشید که مقادیر Synchronizing Source (SSRC) در این بسته‌ها ثابت هستند و اجازه می‌دهند که جریان در هر دو انتها بازسازی شود. از دو گفتگو در شکل‌های 1-17 و 1-18 می‌توان دید که هر دو معماری از RTP استفاده می‌کنند. پیاده‌سازی‌های SIP نیز از RTP استفاده می‌کنند. نگاه دیگری به گفتگوی RTP در شکل 1-25 نشان می‌دهد که یک بسته RTCP نیز وارد شده است.

![](./image/1-25.png)

### RTCP
همانطور که قبلاً ذکر شد و در شکل 1-15 مشاهده می‌شود، بسته‌های RTCP اطلاعاتی درباره جریان RTP حمل می‌کنند که برای ارائه جزئیات درباره کیفیت یا عملکرد استفاده می‌شود. RFC 3550 بیان می‌کند که RTCP هر زمان که RTP استفاده شود، پیاده‌سازی خواهد شد. فهرست بسته‌ها این موضوع را تایید می‌کند. با این حال، هر پیاده‌سازی ممکن است قوانین را رعایت نکند. در حالی که فهرست بسته‌ها ویرایش شده‌اند، آنها به گونه‌ای ویرایش نشده‌اند که خواننده را گمراه کنند. بنابراین، اگر در بررسی توپولوژی Cisco متوجه شدید که بسته‌های RTCP وجود ندارند، چشمان شما فریب نخورده‌اند. Cisco از مکانیزم SCCP دیگری برای دستیابی به هدف RTCP استفاده می‌کند و این در شکل 1-26 نشان داده شده است.

اگر به توپولوژی خود نگاه دیگری بیندازیم، می‌بینیم که آدرس‌های IP نقطه انتهایی به طور مستقیم از طریق جریان RTP در حال ارتباط هستند، همانطور که در شکل 1-27 نشان داده شده است. توجه کنید که تمام دستگاه‌های دیگر در این نقطه از گفتگو خارج هستند.

![](./image/1-26.png)   
![](./image/1-27.png)   

### پایان تماس
در اکثر پیاده‌سازی‌های VoIP، تلاش می‌شود تا یک قطع ارتباط آرام و مرتب فراهم شود. این کار تضمین می‌کند که کانال یا جلسه خاموش شود، منابع بازیابی شوند، صورت‌حساب مشخص شود، و هیچ داده اتصالی دیگری برای آن Call-ID پذیرفته نشود. این روش در مقابل قطع ساده اتصال از یک نقطه انتهایی قرار دارد. با بررسی شکل 1-17، پروتکل سیگنالینگ در این نقطه دوباره به اتصال برمی‌گردد و پیام‌هایی را به طرف‌های درگیر ارائه می‌دهد تا مدار منطقی را تخریب کرده و منابع را بازیابی کند. تلفن‌ها دوباره به ارتباط با آدرس IP سرور تماس در 192.168.16.1 بازمی‌گردند.

### performance
با پروتکل‌هایی مانند RTCP یا پیام‌های Skinny، مانند آنچه در شکل 1-15 و شکل 1-24 نشان داده شده‌اند، توجه زیادی به شاخص‌های کیفیت برای جریان RTP می‌شود. این ممکن است شما را به این باور برساند که عملکرد VoIP اهمیت زیادی دارد. در واقع همین‌طور است. با تبدیل شدن بسیاری از سیستم‌ها به IP، به راحتی می‌توان تصور کرد که این‌ها فقط برنامه‌های اضافی هستند که روی شبکه اجرا می‌شوند و شبکه می‌تواند به پشتیبانی از این برنامه‌ها ادامه دهد. در حالی که برخی برنامه‌ها ممکن است در یک شبکه شلوغ زنده بمانند، صوت یک برنامه بسیار مهم و حساس است. انواع دیگر ترافیک (FTP، HTTP، ایمیل و غیره) معمولاً می‌توانند از یک قطعی یا مشکل خدماتی جان سالم به در ببرند. اما بدون ارتباط صوتی، مشکلات می‌توانند برای یک کسب‌وکار بسیار جدی شوند. اگر شما یک مدیر شبکه هستید، ممکن است در صورت عدم عملکرد ارتباطات صوتی، توجه نامطلوبی را جلب کنید. بنابراین، معمولاً سیستم‌های VoIP بودجه و نیروی انسانی اضافی دریافت می‌کنند. ما اغلب منابعی را تخصیص می‌دهیم تا اطمینان حاصل کنیم که سیستم نه تنها به کار خود ادامه می‌دهد بلکه دارای سطح بالایی از کیفیت نیز هست.

همانطور که قبلاً در این فصل ذکر شد، سه دشمن عملکرد VoIP تاخیر (latency)، نوسان (jitter) و از دست دادن بسته (packet loss) هستند. تقریباً هر شیء یا فرآیندی در مسیر تاخیر ایجاد می‌کند - از کدک مورد استفاده، جداول مسیریابی و سوئیچینگ در هر مرحله از مسیر، و رفتار ذاتی شبکه. نوسان یا تغییر در زمان رسیدن بسته‌ها منجر به عملکرد غیرقابل پیش‌بینی می‌شود. معمولاً مشکلات نوسان با بافرینگ مدیریت می‌شوند. اما با داده‌های بلادرنگ، امکان ارائه بافرینگ بسیار محدود است. از دست دادن بسته نیز یک مشکل مهم برای هر برنامه‌ای است، زیرا بازفرستی‌ها می‌توانند به شدت کیفیت تماس را کاهش دهند. جدول 1-2 شاخصی از کیفیت تماس‌ها را ارائه می‌دهد. اگرچه برخی از مقادیر ممکن است کمی متفاوت باشند، می‌بینیم که بیشتر فروشندگان و استانداردها به یکدیگر نزدیک هستند.

![](./image/t1-2.png)

### خلاصه
صدا بر بستر IP (VoIP) به سرعت در حال تبدیل شدن به یکی از اجزای مرکزی شبکه‌ها، صرف نظر از اندازه یا نوع کسب‌وکار است. از مدیران سیستم و شبکه اغلب خواسته می‌شود تا VoIP را به صورت بومی پیاده‌سازی کنند یا سیستم‌های تلفنی سنتی را به راه‌حل‌های VoIP مهاجرت دهند. درک عملکرد پروتکل‌های VoIP و خدمات لازم برای ایجاد یک راه‌حل موفق بسیار مهم است. این فصل به بررسی یک توپولوژی استاندارد VoIP پرداخت که شامل اجزای غیر اختصاصی VoIP مانند پروتکل پیکربندی پویای میزبان (DHCP) و پروتکل انتقال فایل ابتدایی (TFTP) می‌شود. پروتکل‌های سیگنالینگ شامل H.323، SIP، و SCCP نیز مرور شدند، همچنین RTP که سرورها از آن برای انتقال داده‌های صوتی استفاده می‌کنند. جزئیات بیشتر را می‌توان در فصل‌های اختصاص داده شده به این پروتکل‌ها یافت. این فصل همچنین با فایل‌های ضبط موجود در وب‌سایت کتاب پشتیبانی می‌شود.

# Chapter 2
## Traditional Telephony

## Introduction
چه شما در حال تبدیل به VoIP (Voice over IP) باشید یا از قبل آن را دارید، مدیران شبکه موظف به مدیریت مجموعه‌ای از مسائل با ماهیت سنتی‌تر و اتصال به دنیای خارج هستند. بنابراین حتی اگر ما آینده را پذیرفته‌ایم، جدا شدن کامل از گذشته دشوار است. برای آینده قابل پیش‌بینی، درک فناوری مدار سوئیچ شده آنالوگ و دیجیتال، سیم‌کشی تلفن و روش‌های آزموده‌شده برای اتصال به ISPها (ارائه‌دهندگان خدمات اینترنت) ضروری است. به عنوان مثال، یکی از مدارهای پرفروش هنوز هم T-1 است. علاوه بر این، داده‌های اتحادیه بین‌المللی مخابرات نشان می‌دهد که در حالی که رشد استفاده از اینترنت و دستگاه‌های متصل به اینترنت قابل توجه است، این به معنای پایان خدمات ثابت سنتی نیست. این داده‌ها در شکل 2-1 نشان داده شده است.

ورود فارغ‌التحصیلان به نیروی کار با مدارک و گواهینامه‌های شبکه کاملاً معمول است، اما پس از استخدام به آن‌ها گفته می‌شود که وظایفشان شامل نگهداری و مدیریت یک سیستم PBX (تلفن سانترال) قدیمی یا دسته‌ای از سیم‌های آبی و سفید نیز می‌شود.

![](./image/2-1.png)
![](./image/2-1.1.png)

از آنجایی که شبکه تلفن سوئیچ عمومی (PSTN) بسیار بزرگ و پیچیده است، این فصل به بررسی بخش‌هایی که احتمالاً برای یک مدیر VoIP مفید است، می‌پردازد. این فصل اجزای یک استقرار کوچک و سنتی شامل PBX و تلفن‌ها را پوشش می‌دهد. بحث شامل سیم‌کشی و اتصالات مورد استفاده نیز می‌شود. این فصل همچنین اتصالاتی که برای اتصال سایت‌ها و سوئیچ‌ها استفاده می‌شود، مانند T-1ها را نیز پوشش می‌دهد.

## Overview
یک روش ساده‌شده برای درک این موضوع، حداقل برای شروع، این است که اینترنت و شبکه‌های تلفن قبلاً دو موجودیت کاملاً جداگانه بودند که استانداردها و قوانین متفاوتی داشتند، همان‌طور که در شکل 2-2 نشان داده شده است.

![](./image/2-2.png)

اینترنت بر روی مجموعه پروتکل‌های مدل TCP/IP (پروتکل کنترل انتقال/پروتکل اینترنت) اجرا می‌شود. شبکه تلفن عمومی (PSTN) بر روی چیزی به نام سیستم سیگنال‌دهی ۷ (SS7) اجرا می‌شود. جالب است بدانید که در روزهای دسترسی دیال-آپ، شما از طریق PSTN به ارائه‌دهنده خدمات اینترنتی (ISP) خود متصل می‌شدید. علاوه بر این، بیشتر شرکت‌هایی که خدمات PSTN را ارائه می‌دهند، همان شرکت‌هایی هستند که به عنوان ISP فعالیت می‌کنند. این امر به ویژه اگر به تکامل این اتصالات از سال ۱۹۹۶ به بعد نگاه کنیم، درست است. بنابراین از دیدگاه کامپیوتری با یک مودم، توپولوژی واقعی ممکن است بیشتر شبیه به شکل 2-3 به نظر برسد.

![](./image/2-3.png)

در این حالت، ارائه‌دهنده محلی تبادل (local exchange provider) مودم شما (مدولاتور-دمولاتور) را با استخر مودم در ISP متصل می‌کند وقتی که شماره تلفن ISP را شماره‌گیری می‌کنید. هنگامی که ارتباط برقرار شد، این اتصال اساساً به عنوان یک سیم مستقیم بین دو دستگاه عمل می‌کند. همه مودم‌ها یک موج حامل را مدوله می‌کنند تا مقادیر باینری که نیاز به انتقال دارند را نشان دهند. چه اطلاعات صوتی باشد چه یک موج حامل مدوله شده، رفتار تجهیزات ارائه‌دهنده محلی تبادل یکسان است.

با یک اتصال اینترنتی کابلی پرسرعت، ارائه‌دهنده محلی تبادل اصلاً لازم نیست. خطوط مشترک دیجیتال (DSL) هنوز از سیم‌کشی حلقه محلی استفاده می‌کنند، اما دفتر برای مدیریت اجزای سیگنال اضافی و پهنای باند مورد نیاز برای DSL تنظیم شده است. حلقه محلی در جزئیات بیشتری در ادامه این فصل پوشش داده شده است.

## Organizations
در طول این فصل (و فصول دیگر) به چندین نهاد اشاره خواهد شد. این نهادها مسئول استانداردها یا مقرراتی هستند که بر اساس آن‌ها سیستم‌های ارتباطی خود را بنا کرده‌ایم.

## **اتحادیه بین‌المللی مخابرات-تله‌کام (ITU-T)**
این نهاد که در سال ۱۸۶۵ تأسیس شد، هدف اصلی‌اش ایجاد استانداردهای ارتباطات اطلاعاتی پذیرفته‌شده جهانی است. در سال ۱۹۴۷ به یک آژانس سازمان ملل متحد تبدیل شد. ITU-T همچنین با توسعه مخابرات در سراسر جهان به‌ویژه در کشورهای جهان سوم نیز مرتبط است. در ایالات متحده، این به معنی تلفن و داده است. ITU-T توصیه‌نامه‌هایی صادر می‌کند که در واقع به عنوان استاندارد در نظر گرفته می‌شوند. بیشتر قوانین شبکه PSTN که در شکل ۲-۳ نشان داده شده است (کدک‌ها، سیم‌کشی، سیگنال‌دهی و غیره) از ITU-T می‌آیند. شماره تلفن در توصیه‌نامه ITU-T E.164 توصیف شده است و به عنوان طرح شماره‌گذاری عمومی بین‌المللی مخابرات شناخته می‌شود. در آمریکای شمالی، ما از طرح شماره‌گذاری آمریکای شمالی (NANP) استفاده می‌کنیم که با E.164 مطابقت دارد. فرمت در جدول ۲-۱ نشان داده شده است. در این جدول، N یک رقم از ۲ تا ۹ است و x یک رقم از ۰ تا ۹ است. کد منطقه یک تخصیص جغرافیایی است، کد دفتر تخصیص سوئیچ محلی یا کلاس ۵ است و کد ایستگاه تخصیص پورت یا مدار است. ممکن است بیش از یک کد دفتر به یک سوئیچ محلی خاص اختصاص داده شود.

![](./image/t2-1.png)


## E164 number format
The E.164 format is an international telephone numbering plan used to ensure that phone numbers are globally unique and standardized. It defines how to format and dial phone numbers internationally. Here’s a simple explanation with an example:

### Key Features of E.164:
1. **Country Code:** A number that represents the country (1-3 digits).
2. **National Destination Code (NDC):** This includes area codes or service provider codes (optional, 1-4 digits).
3. **Subscriber Number:** The actual phone number of the person or service (up to 12 digits).

### Example Breakdown:
Let's take a phone number from the United States: **+1 234-567-8901**

1. **Country Code (+1):** The country code for the United States is "1".
2. **National Destination Code (234):** This could be an area code.
3. **Subscriber Number (567-8901):** The local phone number.

### Formatting Rules:
- Always starts with a plus sign (+).
- Followed by the country code.
- Then the NDC (if applicable).
- Finally, the subscriber number.

### Examples in E.164 Format:
- United States: `+12345678901`
  - Country code: 1
  - NDC: 234
  - Subscriber number: 5678901
- United Kingdom: `+442071838750`
  - Country code: 44
  - NDC: 2071
  - Subscriber number: 838750
- India: `+919876543210`
  - Country code: 91
  - NDC: 98
  - Subscriber number: 76543210

### Why Use E.164?
- **Consistency:** Ensures a standardized way of formatting numbers globally.
- **Interoperability:** Facilitates smooth international communication.
- **Clarity:** Removes ambiguity when dialing internationally.

### How to Dial:
1. **From your country:** Dial the international access code (often 00 or +) followed by the E.164 formatted number.
2. **Within the same country:** Dial as usual, often omitting the country code.

For example, to call the UK number `+442071838750` from the US:
- Dial `011` (US international access code), followed by `44` (UK country code), and then `2071838750` (local number). So, dial `011442071838750`.

Using the E.164 format ensures that everyone around the world understands and dials the number correctly.


Sure! Let's break down these telecom concepts in very simple terms with examples.

### Area Codes
**Area Codes** are the first few digits of a phone number that designate a specific geographic region. They help route calls to the right area.

- **Example:** In the phone number (415) 555-1234, "415" is the area code. It tells you that the call is going to San Francisco, California.

### Local Exchange
**Local Exchange** refers to a specific central office or switching system that connects calls within a local area.

- **Example:** For the number (415) 555-1234, "555" could be the local exchange code. This means it routes the call within a smaller area of San Francisco.

### Local Access and Transport Areas (LATAs)
**Local Access and Transport Areas (LATAs)** are regions that define where a phone company can provide local or long-distance services.

- **Example:** California might be divided into several LATAs. A call within a LATA is usually considered local, while a call between LATAs might be considered long-distance.

### Local Exchange Carriers (LECs)
**Local Exchange Carriers (LECs)** are companies that provide local telephone service. There are two types:

1. **Incumbent Local Exchange Carriers (ILECs):** These are the traditional phone companies that existed before the market was opened to competition.

   - **Example:** AT&T and Verizon are ILECs in many parts of the United States.

2. **Competitive Local Exchange Carriers (CLECs):** These are newer companies that compete with the incumbent carriers to offer local telephone service.

   - **Example:** Comcast and Vonage are CLECs offering local phone services in various regions.

### Inter-Exchange Carriers (IXCs)
**Inter-Exchange Carriers (IXCs)** are companies that provide long-distance telephone services between different LATAs or regions.

- **Example:** If you're in San Francisco (LATA 1) and you call someone in Los Angeles (LATA 2), the call might be handled by an IXC like Sprint or AT&T Long Distance.

### Putting It All Together
1. **Area Code:** Helps identify the region (e.g., 415 for San Francisco).
2. **Local Exchange:** Routes calls within the local area (e.g., 555).
3. **LATAs:** Defines the geographic region for local vs. long-distance (e.g., San Francisco and Los Angeles are different LATAs).
4. **LECs:** Provide local phone service.
   - **ILECs:** Traditional providers (e.g., AT&T).
   - **CLECs:** New competitors (e.g., Comcast).
5. **IXCs:** Handle long-distance calls between LATAs (e.g., Sprint).

### Example Phone Call:
- **You** (in San Francisco, CA, area code 415) call your friend in Los Angeles, CA, area code 213.
- **Area Code 415** tells the network you're in San Francisco.
- **Local Exchange 555** directs the call within your area.
- **LATA** identifies whether it's a local or long-distance call.
- **LEC** (like AT&T) connects your call locally.
- **IXC** (like Sprint) may handle the long-distance part of the call from San Francisco to Los Angeles.

Sure! Let's break down these telecom concepts into simple and detailed explanations with examples.

### 1. Local Access and Transport Areas (LATAs)

**LATA**:
- **Definition**: A geographic region used to determine local and long-distance telephone services.
- **Purpose**: To organize the delivery of phone services into manageable areas.

**Example**:
- **LATA 722** might cover Northern California, including San Francisco.
- **LATA 730** might cover Southern California, including Los Angeles.

A call within the same LATA (e.g., from San Francisco to another town in Northern California) is a local call. A call between different LATAs (e.g., from San Francisco to Los Angeles) is a long-distance call.

### 2. Local Exchange Carriers (LECs)

**LEC**:
- **Definition**: Companies that provide local telephone services.
- **Types**:
  1. **Incumbent Local Exchange Carriers (ILECs)**:
     - Traditional, established companies.
     - Example: AT&T, Verizon.
  2. **Competitive Local Exchange Carriers (CLECs)**:
     - Newer companies that compete with ILECs.
     - Example: Comcast, Vonage.

**Purpose**: To connect calls within the same LATA and provide local phone services.

**Example**:
- If you live in San Francisco and have a landline from AT&T, AT&T is your LEC.

### 3. Area Codes

**Area Code**:
- **Definition**: The first three digits of a phone number that designate a specific geographic region.
- **Purpose**: To help route calls to the correct region.

**Example**:
- In the phone number **(415) 555-1234**:
  - **415** is the area code for San Francisco, California.

### 4. Inter-Exchange Carriers (IXCs)

**IXC**:
- **Definition**: Companies that provide long-distance telephone services between different LATAs.
- **Purpose**: To handle calls that travel across LATAs, ensuring they reach the correct destination.

**Example**:
- If you call from San Francisco (LATA 722) to Los Angeles (LATA 730), a company like Sprint or AT&T Long Distance would handle the call as the IXC.

### Putting It All Together

#### Example Phone Call:

1. **You** are in San Francisco (area code 415) and want to call your friend in Los Angeles (area code 213).

2. **Area Code**:
   - **415** identifies your call as coming from San Francisco.
   - **213** identifies the call destination as Los Angeles.

3. **Local Exchange**:
   - Your local exchange (e.g., 555) within San Francisco routes the call locally.

4. **LATA**:
   - Your call is identified as traveling from LATA 722 (San Francisco) to LATA 730 (Los Angeles), marking it as a long-distance call.

5. **LEC**:
   - Your local LEC (e.g., AT&T in San Francisco) handles the initial routing of your call.

6. **IXC**:
   - The IXC (e.g., Sprint) takes over the long-distance portion of the call from San Francisco to Los Angeles.

7. **Receiving LEC**:
   - The LEC in Los Angeles (e.g., Verizon) receives the call and routes it to the final local exchange (e.g., 555) to connect with your friend's number.

### Summary
- **LATA**: Defines regions for local and long-distance calls.
- **LEC**: Provides local phone services within a LATA.
  - **ILEC**: Established traditional companies (e.g., AT&T).
  - **CLEC**: Newer competitors (e.g., Comcast).
- **Area Code**: The initial digits of a phone number that identify the geographic region (e.g., 415 for San Francisco).
- **IXC**: Handles long-distance calls between different LATAs (e.g., Sprint for calls from San Francisco to Los Angeles).

By understanding these concepts, you can see how calls are routed and managed across different regions and service providers.

## **کمیسیون ارتباطات فدرال (FCC)**
FCC یک نهاد نظارتی ایالات متحده است که با قانون ارتباطات سال ۱۹۳۴ تشکیل شده و به کنگره پاسخگو است. به نقل از سایت FCC، این آژانس:
ارتباطات بین‌المللی و بین‌المللی را از طریق رادیو، تلویزیون، سیم، ماهواره و کابل در تمام ۵۰ ایالت، ناحیه کلمبیا و مناطق ایالات متحده تنظیم می‌کند.
FCC قیمت‌ها را برای تلفن، داده و ویدئو بین‌المللی تعیین می‌کند، تخصیص طیف بی‌سیم را مدیریت می‌کند، تعیین می‌کند که کدام فروشندگان مجاز به ورود به بازارهای مختلف هستند و در توسعه استانداردهای الکتریکی و فیزیکی مشارکت دارد. FCC همچنین یک سازمان تحقیقاتی است که به شکایات و حفاظت از مصرف‌کننده رسیدگی می‌کند.

## **کمیسیون خدمات عمومی (PUC) و کمیسیون خدمات عمومی (PSC)**
همانطور که از نامش پیداست، این دو نهاد (که معمولاً یکی هستند، زیرا ایالت‌ها از این اصطلاحات به صورت جایگزین استفاده می‌کنند) با تمام خدمات در مرزهای ایالتی، مانند برق، گاز، بخار، آب و مخابرات مرتبط هستند. این‌ها سازمان‌های ایالتی هستند که می‌توانند محدودیت‌هایی اعمال کرده و نظارت در حوزه قضایی خود فراهم کنند.


## Connecting to the Traditional World
## **اتصال به دنیای سنتی**
شبکه تلفن سوئیچ عمومی (PSTN) توپولوژی جهانی است که همه تلفن‌ها را به یکدیگر متصل می‌کند. بنابراین، زمانی که تلفن خانگی شما از طریق شرکت تلفن شما متصل شد، خط تلفن شما و تمامی خطوط تلفن دیگر، از جمله آن‌هایی که شرکت‌های تلفن را به یکدیگر متصل می‌کنند، بخشی از PSTN هستند. حلقه محلی و تلفن‌های متصل برخی از آخرین بخش‌های آنالوگ باقی‌مانده هستند. برخی شرکت‌ها نیز خطوط آنالوگ داخلی دارند، اما به طور کلی، کل شبکه PSTN دیجیتال است. PSTN به عنوان یک شبکه سوئیچ مدار توصیف می‌شود که در آن اتصالات بر اساس نیاز تنظیم و قطع می‌شوند. سوئیچینگ مداری دو انتها را در سراسر شبکه با اختصاص منابع به خطوط در حال استفاده متصل می‌کند، بر خلاف ارسال ساده بسته‌ها به شبکه (سوئیچینگ بسته‌ای) برای تحویل به بهترین شکل ممکن. به همین دلیل، PSTN به دلیل ارائه کیفیت بالای خدمات برای مشتریان شهرت دارد.

PSTN از دو شبکه تشکیل شده است: شبکه حمل ترافیک و شبکه سیگنال‌دهی. ما از طریق شبکه حمل ترافیک صحبت کرده و اطلاعات ارسال می‌کنیم. این اتصالات توسط شبکه سیگنال‌دهی کنترل می‌شوند. شبکه سیگنال‌دهی دارای معماری و پروتکل مخصوص به خود است. شبکه سیگنال‌دهی می‌تواند ترافیک داده را نیز حمل کند. ما درباره این موضوع زمانی که شبکه دیجیتال خدمات یکپارچه (ISDN) را پوشش می‌دهیم صحبت خواهیم کرد. زبان شبکه سیگنال‌دهی PSTN سیستم سیگنال‌دهی ۷ (SS7) است، در حالی که زبان اینترنت مبتنی بر TCP/IP است. حتی با اینکه PSTN و اینترنت زبان‌های مختلفی دارند، اما بسیاری از نگرانی‌های مشترک مانند اتصال نقطه‌های پایانی و مسیریابی تماس‌ها، پیگیری استفاده، آدرس‌دهی و اجرای کنترل منابع را دارند. در ایالات متحده، PSTN اغلب به عنوان شبکه AT&T یا سیستم بل شناخته می‌شد.

از نظر ساختاری، PSTN از کدهای منطقه، نواحی تبادل محلی و حمل‌ونقل، حامل‌های تبادل محلی (ساکن و رقابتی) و حامل‌های بین‌المللی تشکیل شده است. این شبکه به شکلی بسیار جغرافیایی سازماندهی شده و از نظر هزینه، خدمات و رقابت تنظیم شده است. به‌روزرسانی نمودارمان با استفاده از تعاریف آینده، توپولوژی را به شکل تصویر ۲-۴ نشان می‌دهد.

برخی تعاریف مفید دیگر در این زمینه عبارتند از:

## **نواحی دسترسی و حمل‌ونقل محلی (LATA)**
کشور به ۱۹۶ ناحیه دسترسی و حمل‌ونقل محلی یا LATA تقسیم شده است. یک LATA یک ناحیه جغرافیایی را تعریف می‌کند که در آن یک حامل تبادل محلی (LEC) می‌تواند خدمات ارائه دهد. حامل تبادل محلی همچنین به عنوان شرکت تلفن محلی شما شناخته می‌شود. LATAs و کدهای منطقه به طور غیرمستقیم مرتبط هستند، زیرا تراکم جمعیت می‌تواند بر تعداد کدهای منطقه مورد نیاز در یک منطقه خاص تأثیر بگذارد. شماره‌گذاری LATA یک مقدار سه‌رقمی است که با کد منطقه آغاز می‌شود. در مثال ما، تمامی LATAs در منطقه جنوب مرکزی با "۵" شروع می‌شوند. مقایسه بین LATAs و کدهای منطقه در شکل ۲-۵ دیده می‌شود.

![](./image/2-4.png)
![](./image/2-5.png)

کانزاس انتخاب شد زیرا تراکم جمعیت آن چندان زیاد نیست و در نتیجه ایالت برای مقایسه ساده‌تر است. همان‌طور که در این نقشه‌ها دیده می‌شود، کانزاس دارای دو LATA و چهار کد منطقه است. این بدان معناست که شماره‌های تلفن مانند 785-111-2222 و 913-333-4444 در کدهای منطقه‌ای مختلفی هستند و بنابراین احتمالاً یک تماس راه دور محسوب می‌شوند. با این حال، از آنجایی که آن‌ها در یک LATA قرار دارند، ممکن است این تماس‌ها راه دور نباشند، بسته به پوشش شرکت تبادل محلی (LEC).

## **حامل‌های بین‌المللی (IXCs)**
حامل‌های بین‌المللی حامل‌های راه دور یا بین LATA هستند. این شرکت‌ها مانند AT&T، اسپرینت (که از راه‌آهن جنوب اقیانوس آرام - SPRint سرچشمه گرفته است) و MCI قدیمی بودند. برخی از IXCها اکنون می‌توانند به عنوان حامل‌های تبادل محلی رقابتی (CLEC) عمل کنند.

## Telecommunication Companies
### تجزیه و تحلیل

تقریباً هر کتابی درباره مخابرات بخشی برای حکم مالی تعدیل شده علیه AT&T دارد. این بخش برای ارائه دیدگاهی کمی به مجموعه‌ای بسیار پیچیده از شرکت‌ها گنجانده شده است. ابتدا باید بدانیم که شبکه تلفن دهه‌هاست وجود دارد و به زمانی بازمی‌گردد که اپراتور در پشت میز کلیدزنی نشسته و به صورت دستی تماس‌ها را متصل می‌کرد. اینترنت بسیار جوان‌تر است، و بیشتر مردم موافقند که آغاز آن به اوایل دهه ۱۹۹۰ بازمی‌گردد، هرچند خالص‌نگران به فعالیت‌های اولیه‌تری اشاره خواهند کرد. این دو شبکه متفاوت هستند و زبان‌های مختلفی صحبت می‌کنند. چیزی که تصویر را پیچیده‌تر می‌کند این است که بسیاری از شرکت‌های مشابه هر دو شبکه را اداره می‌کنند.

### پیش‌زمینه تاریخی

برای ارائه زمینه بیشتر، باید به قبل از سال ۱۹۸۲ بازگردیم، زمانی که شرکت آمریکایی تلفن و تلگراف (AT&T) انحصار کامل بر سیستم تلفن داشت. این شرکت می‌توانست قیمت‌ها را تعیین کند و دسترسی‌ها را کنترل کند. در سال ۱۹۸۲، وزارت دادگستری حکم داد که از تاریخ ۳۰ دسامبر ۱۹۸۳، AT&T باید به هفت شرکت عملیاتی منطقه‌ای بل (RBOCs) تقسیم شود. این یک سازماندهی مجدد از ۲۲ شرکت تلفن بل بود که در آن زمان وجود داشتند. RBOCs باید خدمات تبادل محلی را ارائه می‌دادند و AT&T خدمات راه دور را ارائه می‌داد. این باعث شد که RBOCs به عنوان حامل‌های تبادل محلی (LECs) و AT&T به عنوان حامل تبادل بین‌المللی (IXC) شناخته شوند. RBOCs اجازه نداشتند خدمات راه دور ارائه دهند و AT&T اجازه نداشت خدمات محلی ارائه دهد. با این حال، AT&T همیشه زیرکانه بود و حق ارائه خدمات داده‌ها را حفظ کرد.

### قانون مخابرات ۱۹۹۶

قانون مخابرات ۱۹۹۶ قوانین را تغییر داد تا رقابت بیشتری در بازار ایجاد کند. شرکت‌های تلفنی جدید ظهور کردند و محدودیت‌ها در ارائه خدمات کاهش یافت. از تاریخی که این قانون اجرایی شد، RBOCs به عنوان حامل‌های تبادل محلی موجود (ILECs) شناخته شدند و حامل‌های تبادل محلی رقابتی (CLECs) وارد عرصه مخابرات شدند. به نقل از این قانون، بخشی از اهداف آن به شرح زیر است:
"برای ترویج رقابت و کاهش مقررات به منظور تضمین قیمت‌های پایین‌تر و کیفیت خدمات بالاتر برای مصرف‌کنندگان مخابرات آمریکایی و تشویق به استقرار سریع فناوری‌های جدید مخابراتی."

### وضعیت امروزی

امروزه شرکت‌های تلفنی از شرکت‌های اینترنتی یا خدمات داده‌محور قابل تشخیص نیستند. هنگامی که این را با تبدیل نمونه‌های صوتی به بسته‌های داده صوتی ترکیب می‌کنیم، می‌توان آینده‌ای را تصور کرد که در آن اتصالات مدار سوئیچ دیگر بخشی از شبکه نباشند. ارائه‌دهندگان در حال تبدیل زیرساخت‌ها و مدل‌های کاربردی خود هستند تا به تقاضای خدمات مبتنی بر IP پاسخ دهند.

### نکته جالب

یک نکته جالب دیگر قدرت بالای این شرکت‌ها است. در روزهای اولیه اینترنت، ساختار آن بر اساس نقاط دسترسی شبکه (NAP) بود. در ابتدا چهار NAP وجود داشت که در کالیفرنیا، نیوجرسی، میشیگان و واشنگتن دی‌سی قرار داشتند. ایده این بود که همه کسانی که می‌خواستند به شبکه داده جهانی متصل شوند، از طریق NAP‌ها به هم متصل شوند. طولی نکشید که شرکت‌های بزرگ متوجه شدند اگر جدول‌های مسیریابی خود را نگه دارند، شرکت‌های کوچک نمی‌توانند به مشتریان خود اتصال کامل ارائه دهند مگر با کمک آنها. به هر حال، چه مزایایی برای یک ISP جهانی در اشتراک‌گذاری وجود دارد؟ ISP‌های بزرگ توافقنامه‌های پییرینگ و نقاط پییرینگ خصوصی (PPP) ایجاد کردند تا ترافیک داده را مبادله کنند. سرنوشت یک ISP کوچک معمولاً این بود که خریداری شود، از ISP‌های بزرگ‌تر خدمات بگیرد یا از کسب و کار خارج شود؛ ادامه دادن به کسب درآمد از فروش خدمات دایل‌آپ دشوار بود.


### مرکز تلفن (CO)
مرکز تلفن محلی سوئیچ محلی را در خود جای می‌دهد. به طور سنتی، پیش‌شماره یک شماره تلفن (تبادل) یک سوئیچ محلی مرکز تلفن خاص را شناسایی می‌کند. یک سوئیچ محلی مرکز تلفن می‌تواند به گونه‌ای برنامه‌ریزی شود که بیش از یک تبادل محلی داشته باشد.

### مرکز تلفن خصوصی (PBX)
این دستگاه تقریباً تمامی ویژگی‌ها و عملکردهای مرکز تلفن یا سوئیچ تلفن را مدیریت می‌کند. تلفن‌های داخلی به PBX متصل می‌شوند که به نوبه خود به شبکه ارائه‌دهنده خارجی متصل است. یک PBX می‌تواند به تمامی انواع تلفن‌ها، از جمله VoIP، سرویس ارائه دهد. یک PBX از نوع Avaya در شکل 2-6 نشان داده شده است. فلش‌ها کارت‌های نصب شده برای پشتیبانی از تلفن‌های آنالوگ و دیجیتال را نشان می‌دهند. فلش سمت چپ به پورت‌های اترنت در پایین شاسی اشاره دارد. بنابراین، PBX می‌تواند به شبکه داده متصل شود تا از تلفن‌های VoIP پشتیبانی کند. 

تلفن‌های آنالوگ و دیجیتال از طریق کابل‌های پچ یا بلوک‌های پانچ به PBX متصل می‌شوند. نمونه‌هایی از بلوک‌های پانچ در شکل 2-7 دیده می‌شوند. این‌ها نمونه‌هایی از بلوک‌های BIX (اتصال متقاطع صنعت ساختمان) و بلوک‌های 66 هستند. هر دو قابلیت خاتمه دادن به کابل‌های 25 جفتی مانند آنچه در شکل 2-8 نشان داده شده است را دارند.

![](./image/2-6.png)

### قاب‌های توزیع شبکه تلفن عمومی (PSTN)
این‌ها نقاط اتصال متقاطع با چگالی بالا هستند که در اطراف مرکز تلفن (CO) پراکنده شده‌اند تا به منظور فراهم کردن اتصال و خدمات به مناطق اطراف از طریق خطوط محلی استفاده شوند. کابل‌ها در این نقطه می‌توانند چگالی‌هایی از 50 تا 800 جفت یا خانوار داشته باشند.

### قاب‌های توزیع اصلی
این مناطق معمولاً برق‌دار هستند و دارای تجهیزات سوئیچینگ یا کدگذاری می‌باشند. آن‌ها می‌توانند کاربران را ترکیب یا تجمیع کرده و به فیدهای با چگالی بسیار بالا، مانند فیبر نوری، برای اتصال به مرکز تلفن (CO) تبدیل کنند. یک چینش قاب‌های توزیع در شکل 2-9 دیده می‌شود.

### حلقه محلی
این اصطلاح برای تعریف چیزی است که در خارج از مرکز تلفن قرار دارد. حلقه محلی شامل تجهیزات و سیم‌کشی‌های فراوانی از تجهیزات بیرونی (OSP) است که دسترسی و اتصال به ارائه‌دهنده خدمات آن منطقه را فراهم می‌کند. خطوط POTS (خدمات تلفن ساده) از خانه‌ها یا دفاتر کوچک با استفاده از این تجهیزات کشیده شده و به سوئیچ تلفنی که به آن حلقه محلی سرویس می‌دهد متصل می‌شوند. این خطوط در داخل کابل‌های بزرگتری که معمولاً دفن شده‌اند، کشیده می‌شوند. هر خط تلفن از یک جفت سیم به نام‌های "تیپ" و "رینگ" تشکیل شده است. در محل مشتری، سیم رینگ قرمز و سیم تیپ سبز است. اگر خط دومی وجود داشته باشد، جفت دوم سیم‌ها می‌تواند به ترتیب از سیم‌های سیاه و زرد برای تیپ و رینگ استفاده کند.

### POTS and the Local Loop
برای خانوارها و کسب‌وکارهای کوچک، اتصالات حلقه محلی همچنان عموماً آنالوگ هستند، در حالی که اتصالات بین سوئیچ‌ها یا دفاتر دیجیتال می‌باشند. به دلیل پهنای باند کم و آنالوگ بودن، اتصال POTS به یک خانه تا حدودی محدود است. این محدودیت به این دلیل است که ویژگی‌ها باید در همین پهنای باند کوچک پیاده‌سازی شوند. خدماتی که به کاربران حلقه محلی ارائه می‌شود، خدمات تلفن معمولی (POTS) نامیده می‌شود. به صورت الکتریکی، این یک حلقه الکتریکی ساده دو سیم (یک جفت) با ظرفیت حمل اطلاعات پایین است. هر اتصال آنالوگ حدود 4000 هرتز پهنای باند اختصاص داده می‌شود زیرا بیشتر صداهایی که هنگام صحبت کردن تولید می‌کنیم در این محدوده فرکانسی قرار دارند.

برای دقیق‌تر بودن، ساختار الکتریکی اتصال حلقه محلی در توصیه ITU-T Rec G.107 شرح داده شده است که مدل E باریک‌باند را توصیف می‌کند. مدل E کانال 3.1 کیلوهرتزی برای خطوط مشترکین از 300 تا 3400 هرتز را مشخص می‌کند. این مدل بعدها به مدل E پهن‌باند که از 50 تا 7000 هرتز گسترش می‌یابد، اصلاح شد. این همچنین به این معناست که تمامی سیگنال‌های شماره‌گیری (شماره‌ها، صدای شماره‌گیری، و غیره) باید در این محدوده 3.1 کیلوهرتزی قرار بگیرند. این سیگنال‌ها نه تنها از همان محدوده فرکانسی بلکه از همان مسیر فیزیکی که صدای انسان عبور می‌کند، استفاده می‌کنند. این روش، سیگنال‌دهی درون باند (in-band signaling) نامیده می‌شود. خود صداها در توصیه ITU-T Rec E.180 (Q.35) مشخص شده‌اند. به عنوان مثال، صدای شماره‌گیری باید بین 400-450 هرتز باشد اگر یک صدای تک استفاده شود. صدای اشغال نیز برای همین محدوده توصیه شده است، اما در زمان متفاوتی استفاده می‌شود و دارای بازه زمانی مرتبط است. صداها یا فرکانس‌های استفاده شده هنگام شماره‌گیری یک تلفن نیز در همین محدوده 3.1 کیلوهرتزی قرار دارند. به بخش فرکانس چندتنی (DTMF) در ادامه این فصل مراجعه کنید.

سیم‌های "تیپ" و "رینگ" سیم‌های مداری هستند که از شرکت مخابراتی محلی (LEC) به آن مکان اختصاص داده شده‌اند. بنابراین، این سیم‌ها را می‌توان تا یک پورت خاص بر روی یک سوئیچ تلفن یا PBX ردیابی کرد. کارت دارای اتصالات از یک PBX آسترکیس در شکل 2-14 نشان داده شده است. آسترکیس یک پروژه منبع باز است که می‌تواند اتصالات برای نقاط انتهایی سنتی و VoIP فراهم کند. در این حالت، جعبه آسترکیس دارای یک کارت آنالوگ و یک رابط اترنت برای اتصال به شبکه است.

هر یک از این پورت‌ها یک مدار است که به یک تلفن آنالوگ از طریق جفت سیم‌های تیپ و رینگ متصل می‌شود. توجه داشته باشید که رنگ سیم‌ها بر عملکرد تلفن آنالوگ تأثیری ندارد. در اینجا جفت‌های سیم بر اساس رنگ زرد نشان داده شده‌اند. آسترکیس پورت‌ها را به عنوان FXO یا FXS متمایز می‌کند. پورت‌های FXS و FXO نام دو واسطی هستند که برای اتصال مشتریان و شبکه استفاده می‌شوند. FXS به معنی ایستگاه خارجی است و FXO به معنی دفتر خارجی است.


به یاد داشته باشید از جدول 2-1 (E.164) که یک شماره تلفن دارای یک کد ایستگاه یا مدار برای چهار رقم آخر است. این خطوط از خانه یا دفتر به تیر تلفن و سپس به یک قاب توزیع (گاهی در حیاط همسایه‌تان دیده می‌شود) یا فضای OSP تلفن مرکزی جریان می‌یابند. این به عنوان یک نقطه تجمیع شناخته می‌شود. خطوط نهایتاً به یک سوئیچ تلفن خاتمه می‌یابند. یکی از رایج‌ترین سوئیچ‌های تلفن به نام سوئیچ کلاس 5 یا 5ESS شناخته می‌شود. این سوئیچ شامل کارت‌های خطوط مشترک است که به عنوان نقطه پایانی فیزیکی برای خطوط تلفن عمل می‌کنند. بنابراین، کل یک محله به تسهیلات توزیع محلی به روشی مشابه دسترسی پیدا می‌کنند.

تمام این خطوط در نقطه تجمیع به یک سیم یا کابل بزرگ‌تر بسته‌بندی می‌شوند. یک کابل رایج که در سیستم‌های سیم‌کشی ساختمان‌ها استفاده می‌شود، یک کابل 25 جفتی است که در شکل 2-8 نشان داده شده است. این کابل کمی سخت‌تر از یک جفت تکی است و اغلب با یک پوشش عایق خاکستری پوشیده می‌شود.

در مرکز تصویر، جفت‌های فردی به یک بلوک قابل جدا شدن خاتمه می‌یابند. سر دیگر با یک اتصال AMP Champ ختم می‌شود که امکان اتصالات ساده به اکثر تجهیزات تلفن را فراهم می‌کند.

برای نگه داشتن همه مدارها از یکدیگر، خط 25 جفتی دارای کد رنگی سختگیرانه‌ای است. به این ترتیب، خطوط محله به خروجی تلفن متصل می‌شوند و سپس دوباره تقسیم می‌شوند تا به مدارهای فردی خود متصل شوند، همان‌طور که در شکل 2-15 نشان داده شده است.

وقتی تماس‌های تلفنی برقرار یا دریافت می‌شوند، سیگنال‌ها یا به تلفن ارسال می‌شوند یا از آن دریافت می‌شوند. اتصال نهایی بین دو تلفن توسط شبکه SS7 کنترل می‌شود. شماره‌گیری یک شماره تلفن به سوئیچ خدمات‌دهنده مدار مقصدی که می‌خواهید در انتهای دیگر را فراهم می‌کند. وقتی کسی با شما تماس می‌گیرد، سیگنال‌هایی باید ارسال شوند تا شما را از یک تماس ورودی مطلع کنند (زنگ خوردن) و سپس به سوئیچ اطلاع دهند زمانی که شخص تلفن را قطع می‌کند (قطع اتصال).

در این مرحله، ما به یک مشکل اساسی می‌رسیم: تبدیل آنالوگ به دیجیتال. هسته PSTN دیجیتال است. یعنی سیگنال‌ها و پیام‌های ارسال شده بین گره‌های شبکه باینری (یک‌ها و صفرها) هستند. حلقه محلی یکی از آخرین بخش‌های شبکه سیمی است که هنوز آنالوگ است. هنگامی که یک شماره تلفن را شماره‌گیری می‌کنید، سیگنال‌هایی که ارسال می‌کنید در واقع تن‌ها یا امواج آنالوگ با فرکانس پایین هستند. در واقع، تلفن‌های آنالوگی که در بسیاری از خانه‌های آمریکایی وجود دارند به عنوان تلفن‌های چند فرکانسی (DTMF) شناخته می‌شوند. این تلفن‌ها با هر کلید فشرده شده یک جفت فرکانس ارسال می‌کنند. این تن‌ها باید پس از رسیدن به سوئیچ تلفن خدمات‌دهنده به سیگنال‌های دیجیتال تبدیل شوند. این معمولاً در کارت خط مشترک انجام می‌شود و از طریق استفاده از کدک (coder/decoder) انجام می‌شود. فصل 5 به تفصیل کدک‌ها را توصیف می‌کند، اما توضیح مختصری در پی می‌آید.

روش رایجی که توسط PSTN برای انجام این تبدیل استفاده می‌شود، مدولاسیون کد پالس (PCM) نامیده می‌شود. PCM در توصیه ITU-T G.711 توصیف شده است. G.711 نیز به طور گسترده با VoIP مستقر می‌شود. G.711 با نمونه‌برداری (گرفتن یک لحظه) از موج ورودی و ایجاد یک مقدار دیجیتال برای آن نمونه کار می‌کند. هدف این است که با نرخ بیشتری یا برابر با دو برابر پهنای باند سیگنال اصلی نمونه‌برداری شود. کار منجر به این نرخ نمونه‌برداری توسط هری نیکویست در دهه 1930 آغاز شد. مکالمات تلفنی با نرخ 8000 بار در ثانیه نمونه‌برداری می‌شوند و هر نمونه 8 بیت برای مقدار خود اختصاص داده می‌شود. به یاد داشته باشید که پهنای باند اختصاص داده شده به یک اتصال حلقه محلی حدود 4000 هرتز است. هر نمونه باید یک مقدار داده شود. برای G.711، 8 بیت برای هر نمونه اختصاص داده می‌شود. بنابراین مدار استاندارد تلفن دارای نیاز پهنای باند 64 کیلوبیت در ثانیه است.

64,000 = 8 بیت/نمونه x 8000 نمونه/ثانیه

این همچنین به عنوان یک سیگنال دیجیتال سطح 0 یا DS-0 شناخته می‌شود. این معمولاً به صورت DS-0 نوشته می‌شود.

## Basic Telephone-Call Operation
همان‌طور که قبلاً بحث کردیم، زبان کنترل شبکه PSTN (شبکه تلفن عمومی سوئیچ شده) سیستم سیگنال‌دهی شماره 7 (SS7) است. اگرچه پیچیده است، اما این معماری برای مدیریت ترافیک در شبکه تلفن و همچنین برخی از نیازهای ترافیک داده مبتنی بر IP بسیار موثر بوده است. همان‌طور که اینترنت دارای روترها و سوئیچ‌ها است، PSTN نیز عناصر مشابهی برای انجام وظایف مشابه دارد. برای افرادی که به فکر لایه‌ها و مدل‌ها هستند، معماری SS7 به همان شیوه مدل‌های Open Systems Interconnect (OSI) و Transmission Control Protocol/Internet Protocol (TCP/IP) ساخته شده است. لایه‌های پایین‌تر به ویژگی‌های الکتریکی و فیزیکی لینک می‌پردازند، در حالی که لایه‌های بالاتر با پیام‌رسانی و برنامه‌ها سروکار دارند. یک منبع خوب برای شروع، توصیه ITU-T Rec Q.700 است که نمای کلی از SS7 را ارائه می‌دهد. Q.700 در واقع تکامل معماری SS7 را از سال 1984 بر اساس مدل OSI توصیف می‌کند.

اطلاعات از همه نوع (نه فقط تماس‌های تلفنی) به طور مداوم از طریق شبکه جریان می‌یابند، زیرا پایگاه‌های داده به‌روزرسانی می‌شوند، اطلاعات مربوط به لینک‌ها منتقل می‌شود و تراکنش‌های داده حسابداری رخ می‌دهند. بر اساس Q.700، شبکه مجموعه‌ای از گره‌ها است که از طریق لینک‌ها با استفاده از سیگنال‌دهی کانال مشترک به هم متصل شده‌اند، و این گره‌ها بخشی از SS7 را پیاده‌سازی می‌کنند و به نقاط سیگنال‌دهی تبدیل می‌شوند. مثال‌هایی از نقاط سیگنال‌دهی شامل مبادلات، نقاط کنترل خدمات، نقاط انتقال سیگنال و گره‌هایی است که به اداره، عملیات و نگهداری می‌پردازند. نوع لینک بین گره‌های سیگنال‌دهی بستگی به رابطه آن‌ها دارد. به عنوان مثال، مبادلاتی که داده‌های تماس کاربر را منتقل می‌کنند، رابطه‌ای متفاوت با همدیگر دارند نسبت به یک گره‌ای که برای جستجوی پایگاه داده دسترسی پیدا می‌کند.

### نقطه سوئیچینگ خدمات (SSP)

نقاط سیگنال‌دهی مبدأ و مقصد، سوئیچ‌هایی هستند که تماس‌ها را آغاز یا خاتمه می‌دهند. به طور معمول، SSP‌ها انواع مختلفی از سیگنال‌دهی و رابط‌ها را درک می‌کنند. این‌ها سوئیچ‌های تبادل محلی هستند که قادر به پشتیبانی از SS7 هستند و می‌توانند با STP‌ها و دیگر SSP‌های شبکه SS7 ارتباط برقرار کنند.

### نقطه انتقال سیگنال (STP)

این گره‌ها تمامی پیام‌های سیگنال‌دهی را در شبکه SS7 مسیریابی می‌کنند و اتصال را از یک لینک به لینک دیگر انتقال می‌دهند. به عبارت دیگر، این‌ها منابع و مقصدهای گره‌ها نیستند، بلکه ستون فقرات شبکه SS7 را تشکیل می‌دهند.

### نقطه کنترل خدمات (SCP)

این گره‌ها دسترسی به پایگاه داده را برای مسیریابی اضافی و ارائه برنامه‌ها فراهم می‌کنند.

در نهایت، گره‌های سیگنال‌دهی دارای یک سلسله مراتب از نظر عملکرد هستند، به طوری که برخی گره‌ها به عنوان دروازه‌ها یا با قابلیت دسترسی منطقه‌ای، ملی یا بین‌المللی عمل می‌کنند. توصیه ITU-T Rec. Q.724 توضیحات دقیقی از روش‌های مختلفی که در هنگام برقراری یک تماس درگیر هستند ارائه می‌دهد، اما ما سعی خواهیم کرد در پاراگراف‌های بعدی کمی آن را ساده‌تر بیان کنیم.

به یاد بیاورید که در بحث قبلی ما، یک تلفن آنالوگ که بر روی یک حلقه محلی برای خدمات تلفن ساده (POTS) کار می‌کند، سیگنال‌ها را از شبکه تلفن محلی یا سوئیچ دریافت و به آن ارسال می‌کند. بنابراین، وقتی گوشی را برمی‌دارید، از همان سوئیچ صدای زنگ دریافت می‌کنید. وقتی شماره تلفن را شماره‌گیری می‌کنید، سیگنال‌های آنالوگ را به سوئیچ تلفن ارسال می‌کنید. این سیگنال‌ها همچنین به عنوان تن‌ها شناخته می‌شوند، زیرا قابل شنیدن هستند. برای شماره تلفن یا آدرس، تلفن‌های سیگنال‌دهی در واقع یک جفت تن ارسال می‌کنند، یکی برای ستون شماره و دیگری برای ردیف شماره. این به عنوان تن‌های چند فرکانسی دوگانه (DTMF) شناخته می‌شود. ما همچنین از این سیگنال‌ها برای تعامل با سیستم‌هایی که تماس می‌گیریم، مانند منوها، استفاده می‌کنیم. توزیع فرکانس در جدول 2-3 نشان داده شده است.

![](./image/t2-3.png)

سیگنال‌های شبکه تلفن به طور مشابهی ساختار یافته‌اند. به عنوان مثال، سیگنال اشغال ترکیبی از فرکانس‌های 480 و 620 هرتز است. کارت خط مشترک اعداد شماره‌گیری شده را در مرکز تلفن یا سوئیچ تلفن تبدیل می‌کند تا آدرس مقصد را فراهم کند. این نقطه سوئیچینگ خدمات یا سیگنال‌دهی اعداد شماره‌گیری شده را دریافت کرده و اتصال را آغاز می‌کند و پیام‌ها را به دیگر گره‌های سیگنال‌دهی ارسال می‌کند. بر اساس موقعیت مقصد، سوئیچ‌های واسطه با هم ارتباط برقرار می‌کنند تا منابع لازم برای تماس را تخصیص دهند. یکی از این مذاکرات، کانالی در T-1 است که برای آن تماس استفاده خواهد شد. نقاط سیگنال‌دهی از جداول مسیریابی خود برای تعیین گروه خروجی و مدار مورد نیاز استفاده می‌کنند. نقطه سوئیچینگ خدمات مبدأ (SSP) پیام تنظیم را به SSP مقصد از طریق STP‌ها ارسال می‌کند و درخواست اتصال در مدار مشخص شده را می‌دهد. پس از تأیید، مدار تخصیص داده می‌شود.

در این میان، ممکن است پیام‌های دیگری مانند پاک‌سازی، پاسخ و ازدحام نیز وجود داشته باشد. یک نمونه از پیکربندی مدار را می‌توان در شکل 2-19 مشاهده کرد. بخشی که نشان داده شده است یک سوئیچ مرکزی را با چندین خط چندگانه در حال ورود و یک خط در حال خروج نشان می‌دهد. در سمت چپ، کاربران با استفاده از تکنیک چندگانه‌سازی تقسیم زمانی (TDM) در کانال‌های خود تقسیم می‌شوند، اما با رسیدن به سوئیچ بعدی، ممکن است به دلیل مقصد یا دسترسی به منابع، کانال‌ها نیاز به تغییر داشته باشند.

![](./image/2-19.png)

### برقراری مدار
پس از تنظیم مدار، مقصد از حامل تبادل محلی ولتاژ زنگ دریافت می‌کند. این یک سیگنال 75-90 ولت AC است که باعث زنگ زدن تلفن می‌شود. هنگامی که مقصد گوشی را برمی‌دارد و مشتریان شروع به مکالمه می‌کنند، کدک‌ها در سوئیچ‌های هر دو انتها تبدیل‌های مدولاسیون کد پالس (PCM) را همان‌طور که قبلاً در این فصل توضیح داده شده و در فصل 5 به تفصیل شرح داده شده است، انجام می‌دهند. در مبدا، صدا به نمونه‌های دیجیتال تبدیل می‌شود و در مقصد، فرآیند معکوس انجام می‌شود. بنابراین، هنگامی که صدای طرف مقابل را می‌شنوید، در واقع یک بازسازی معقول از صداهای واقعی تولید شده توسط شخص در طرف دیگر است.

### گذار به سیستم‌های تلفنی جدید
همان‌طور که از یک نوع سیستم تلفن به دیگری انتقال می‌یابیم و حتی به VoIP منتقل می‌شویم، ایده‌های اساسی توصیف‌شده در اینجا همچنان صادق است. با این حال، حتی اگر همان فرآیندها و عملکردها ادامه داشته باشند، چگونگی و مکان وقوع آن‌ها به طور کامل تغییر می‌کند. به عنوان مثال، صدای زنگ ممکن است به صورت محلی تولید شود و یک کدک می‌تواند در خود تلفن وجود داشته باشد.

### خلاصه
شرکت‌ها و سازمان‌ها با نرخ‌های فزاینده‌ای به VoIP (صدا از طریق پروتکل اینترنت) و ارتباطات یکپارچه روی می‌آورند. برخی از این سیستم‌ها را قبلاً پیاده‌سازی کرده‌اند یا در حال مهاجرت هستند. بدون توجه به وضعیت فعلی پیاده‌سازی، مدیران VoIP نمی‌توانند از اتصالات و ایده‌های تلفنی سنتی چشم‌پوشی کنند. حتی اگر سیستم در حال حاضر به صورت بومی VoIP اجرا شود، در نهایت باید به PSTN و معماری SS7 متصل شود.

ایده‌های مرکزی شامل سیم‌کشی تلفن از تلفن به PBX و اتصالات به ارائه‌دهنده است. در میان این اتصالات، استفاده از حامل‌های T خارج از سایت و ISDN همچنان محبوب است. این فصل پوششی از این زمینه‌ها و توضیح پردازش تماس همراه با اجزا، معماری و سازمان‌های مرتبط ارائه می‌دهد.

In the context of telephone call operations within the Signaling System No. 7 (SS7) network, an SSP (Service Switching Point) plays a crucial role. Here’s a detailed explanation:

### Service Switching Point (SSP) in Telephone Call Operation

1. **Definition and Function**:
    - An SSP is a type of switch that initiates or terminates telephone calls. It is capable of understanding and handling various signaling types and interfaces.
    - It is essentially a local exchange switch that is SS7-capable, allowing it to communicate with other SS7 components such as Signal Transfer Points (STPs) and other SSPs.

2. **Role in Call Setup**:
    - **Dialed Number Interpretation**: When a user dials a number, the SSP interprets these digits to determine the destination address.
    - **Connection Initiation**: The SSP starts the call setup process by sending signaling messages to other nodes in the SS7 network, including STPs and possibly other SSPs.
    - **Resource Allocation**: It negotiates the allocation of resources necessary for the call, such as determining the appropriate trunk group and circuit needed to route the call.

3. **Communication with Other Nodes**:
    - **Signaling Messages**: The SSP sends a setup message to the destination SSP via the STPs. This message requests a connection on a specified circuit.
    - **Routing Decisions**: Using its routing tables, the SSP identifies the outgoing trunk group and circuits required to route the call efficiently.

4. **Circuit Establishment**:
    - Once the destination SSP acknowledges the setup message, the circuit is allocated, and the call can proceed.
    - Additional messages such as clearing, answer, and congestion control are exchanged to manage the call's lifecycle.

5. **Ring Voltage and Conversation**:
    - Upon successful circuit setup, the destination SSP sends a ringing voltage to the called party’s telephone, causing it to ring.
    - When the called party answers, the conversation begins, and the SSP manages the conversion of analog voice signals to digital form (and vice versa) using codecs. This conversion process ensures that voice communication is effectively transmitted over the network.

### Example Scenario
1. **Call Initiation**:
    - A user picks up their telephone and dials a number. The local SSP receives the dialed digits.
2. **Setup Message**:
    - The SSP interprets the digits, identifies the destination SSP, and sends a setup message via the STP network.
3. **Resource Allocation**:
    - The originating SSP and destination SSP negotiate the allocation of necessary resources, such as determining the specific channel in the T-1 line for the call.
4. **Call Ringing**:
    - The destination SSP sends a ringing voltage to the destination telephone, causing it to ring.
5. **Conversation**:
    - Once the destination party answers, the codecs in the SSPs at both ends handle the conversion between analog voice and digital signals, allowing the conversation to take place.

### Importance of SSP
- The SSP is crucial for ensuring that calls are correctly routed, resources are efficiently used, and that the call setup, management, and teardown processes are handled smoothly.
- It is a key component in both traditional PSTN networks and modern VoIP systems, bridging the gap between different types of telecommunication technologies.

In summary, the SSP is an essential switch in the SS7 network that manages the initiation, routing, and termination of telephone calls, ensuring seamless communication across the network.


------------

The passage describes the process of how traditional analog telephones, operating on a local loop provisioned for Plain Old Telephone Service (POTS), interact with the local telephone network or switch. Here is an explanation of the key points:

### Analog Telephones on a Local Loop

1. **Local Loop and POTS**:
    - The **local loop** is the physical connection between the subscriber's telephone and the local telephone exchange (or switch).
    - **POTS (Plain Old Telephone Service)** is the traditional analog telephone service that has been in use for many decades. It uses the local loop to connect telephones to the public switched telephone network (PSTN).

2. **Receiving a Dial Tone**:
    - When you pick up the receiver of an analog telephone, you hear a **dial tone**. This dial tone is generated by the local telephone switch and indicates that the switch is ready to accept a telephone number for dialing.

3. **Dialing a Number**:
    - When you dial a telephone number, the telephone converts the dialed digits into **analog signals** and sends them to the local telephone switch. These signals are **audible tones**, meaning you can hear them if you listen on the line.

4. **Dual-Tone Multifrequency (DTMF)**:
    - The signaling method used by analog telephones to send the dialed number to the switch is called **Dual-Tone Multifrequency (DTMF)**.
    - DTMF works by sending a pair of tones for each digit dialed. One tone represents the row and another represents the column of the digit on the keypad. Each digit on the telephone keypad is associated with a unique pair of tones.
    - For example, pressing the digit '1' on the keypad sends two specific frequencies corresponding to the row and column of '1' on the DTMF keypad.

5. **Interacting with Systems**:
    - DTMF tones are also used to interact with automated systems, such as voicemail menus, customer service menus, and other interactive voice response (IVR) systems. By pressing keys on the telephone keypad, users can navigate through these systems by sending DTMF signals.

### Detailed Explanation

- **Local Loop and POTS**: The local loop is the physical pair of wires that connects the user's home telephone to the local central office (telephone exchange). POTS uses these wires to carry analog voice signals.
  
- **Dial Tone**: When the receiver is lifted, the switch detects this action and sends a continuous dial tone to the telephone, indicating readiness to receive dialed numbers. This tone is generated by the local exchange switch and is a standard feature of POTS.

- **Dialing Process**:
  - As the user dials a number, each press of a keypad button generates a specific pair of frequencies (a high and a low frequency), which together form a unique tone for each digit.
  - These tones are sent through the local loop to the central office switch.

- **DTMF Signaling**:
  - **Frequency Pairs**: Each button on the phone's keypad is mapped to a pair of specific frequencies:
    - Low-frequency group: 697 Hz, 770 Hz, 852 Hz, 941 Hz
    - High-frequency group: 1209 Hz, 1336 Hz, 1477 Hz, 1633 Hz
  - For example, pressing '5' generates a combination of 770 Hz and 1336 Hz tones.

- **Interaction with Systems**: In addition to dialing telephone numbers, DTMF tones allow users to interact with automated phone systems by pressing buttons to navigate menus. This capability makes it possible to access services like voicemail, banking systems, and customer support lines without human intervention.

### Summary

The process described shows how traditional analog telephones communicate with the telephone network using DTMF tones. When a user dials a number, the telephone generates a pair of specific frequencies for each digit, sending these audible tones to the local exchange switch. This mechanism enables both dialing telephone numbers and interacting with automated systems through key presses.

### Dual-Tone Multifrequency (DTMF)

DTMF is a signaling system used for telecommunication signaling over analog telephone lines in the voice-frequency band between telephone handsets and other communication devices and the switching center. It is commonly known as "touch-tone" dialing.

### How DTMF Works

The DTMF system uses a matrix of 16 distinct tones, each associated with a key on the telephone keypad. The tones are generated in pairs: one from a set of low frequencies and one from a set of high frequencies. When a key is pressed, the corresponding pair of frequencies is sent over the telephone line.

### Frequency Table

Here's a table showing the frequency pairs used in DTMF:

|      | 1209 Hz | 1336 Hz | 1477 Hz | 1633 Hz |
|------|---------|---------|---------|---------|
| 697 Hz |   1    |    2    |    3    |    A    |
| 770 Hz |   4    |    5    |    6    |    B    |
| 852 Hz |   7    |    8    |    9    |    C    |
| 941 Hz |   *    |    0    |    #    |    D    |

### Example of DTMF

#### Pressing the Number "5"

- **Frequencies Involved**: 
  - Low frequency: 770 Hz
  - High frequency: 1336 Hz

When you press the "5" key on the keypad, the phone generates a tone composed of both 770 Hz and 1336 Hz frequencies simultaneously. This unique combination identifies the digit "5" to the telephone network.

#### Pressing the Number "9"

- **Frequencies Involved**: 
  - Low frequency: 852 Hz
  - High frequency: 1477 Hz

When you press the "9" key on the keypad, the phone generates a tone composed of both 852 Hz and 1477 Hz frequencies simultaneously. This combination uniquely identifies the digit "9".

### DTMF Tone Generation

To illustrate how DTMF works with another example, consider the process of dialing the number "123":

1. **Press "1"**:
   - Low frequency: 697 Hz
   - High frequency: 1209 Hz

2. **Press "2"**:
   - Low frequency: 697 Hz
   - High frequency: 1336 Hz

3. **Press "3"**:
   - Low frequency: 697 Hz
   - High frequency: 1477 Hz

Each time a key is pressed, the telephone generates the corresponding pair of frequencies, which are then sent down the line to the telephone switch. The switch decodes these frequencies to understand which numbers were dialed.

### Interacting with Automated Systems

DTMF is also used for interacting with automated voice response systems. For example, when calling a customer service line, you might hear an automated message saying, "Press 1 for English, Press 2 for Spanish." When you press "1," your phone sends the 697 Hz and 1209 Hz tones to the system, which interprets it as a request for English language support.

### Summary

DTMF is a method used by telephones to communicate dialed numbers and commands to the telephone network. It works by generating pairs of audible tones for each key pressed on the phone keypad. These tones are recognized and interpreted by the telephone exchange to route calls and interact with automated systems.

-----------

### T-1 Line Overview

A T-1 line is a type of high-speed digital communication line used to transmit voice and data between locations. It is one of the standards in the family of T-carrier systems developed by Bell Labs and is primarily used in North America and Japan.

### Specifications and Structure

- **Data Rate**: A T-1 line has a data rate of 1.544 megabits per second (Mbps).
- **Channels**: It is divided into 24 individual channels, each capable of carrying 64 kilobits per second (Kbps).
- **Framing**: The most common framing format for T-1 is called D4 or Superframe (SF), which groups 12 frames into a superframe. Another common format is Extended Superframe (ESF), which groups 24 frames and provides additional features.

### How T-1 Works

1. **Multiplexing**:
    - **Time Division Multiplexing (TDM)**: T-1 lines use TDM to divide the 1.544 Mbps into 24 separate channels. Each channel is assigned a specific time slot in a repeating sequence.
    - **Voice and Data**: Each channel can carry a voice call or data. For voice, each channel uses Pulse Code Modulation (PCM) to convert analog voice signals into digital form.

2. **Signaling**:
    - **Robbed-bit Signaling**: In traditional telephony, one bit from each channel's 8-bit byte is "robbed" for signaling purposes, reducing the effective data rate slightly but allowing for call setup and teardown signals.

### Example Use Case

#### Scenario: Connecting Two Offices

Imagine two offices, Office A and Office B, need to communicate regularly. They can use a T-1 line to connect their private branch exchanges (PBXs), allowing for multiple simultaneous phone calls and data transfer between the offices.

1. **Installation**:
    - The T-1 line is installed by the telecommunications provider, connecting Office A and Office B.
    - Each office has a T-1 CSU/DSU (Channel Service Unit/Data Service Unit) that interfaces between the T-1 line and the office’s network equipment.

2. **Voice Communication**:
    - Office A has a PBX that routes internal and external phone calls.
    - When a call is made from Office A to Office B, the PBX sends the call over one of the 24 channels on the T-1 line.
    - The TDM technique ensures that each channel is allocated a specific time slot, allowing multiple calls to be carried simultaneously without interference.

3. **Data Communication**:
    - In addition to voice, the offices can use the T-1 line for data communication.
    - For instance, Office A can send large files or run a video conference over the T-1 line using the available channels not in use for voice calls.

### Technical Details

1. **Physical Medium**:
    - T-1 lines typically use twisted-pair copper wires, though they can also be delivered over fiber optics or microwave radio links.

2. **Line Coding**:
    - **Bipolar with Eight-Zero Substitution (B8ZS)**: This is a common line coding method used to ensure a sufficient number of transitions to maintain synchronization.

3. **Framing**:
    - **D4 Framing**: Divides the data into frames of 192 bits, with each frame containing 24 channels of 8 bits each, plus an additional framing bit.
    - **Extended Superframe (ESF)**: Enhances D4 by providing 24 frames in a superframe, adding improved error detection and additional data channels.

### Benefits

- **Reliability**: T-1 lines are known for their reliability and dedicated bandwidth.
- **Scalability**: Businesses can combine multiple T-1 lines to increase bandwidth (e.g., a T-3 line, which is equivalent to 28 T-1 lines).
- **Consistency**: Unlike some internet connections, T-1 lines provide consistent and guaranteed bandwidth.

### Summary

A T-1 line is a digital transmission link capable of carrying 24 separate channels of voice or data at a total data rate of 1.544 Mbps. It uses TDM to allocate bandwidth and can be used for both voice and data communication, making it a versatile and reliable solution for businesses needing consistent and high-capacity connections.